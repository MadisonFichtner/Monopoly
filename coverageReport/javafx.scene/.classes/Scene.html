


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Scene</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javafx.scene</a> ]
</div>

<h1>Coverage Summary for Class: Scene (javafx.scene)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Scene</td>
<td class="coverageStat">
  <span class="percent">
    32.6%
  </span>
  <span class="absValue">
    (88/ 270)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    32.4%
  </span>
  <span class="absValue">
    (321/ 992)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Scene$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (1/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$10</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (1/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$12</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (20/ 24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$19</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$2</td>
<td class="coverageStat">
  <span class="percent">
    52.9%
  </span>
  <span class="absValue">
    (9/ 17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.3%
  </span>
  <span class="absValue">
    (14/ 29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$2$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$20</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$21</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$22</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$23</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$24</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$25</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$26</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$27</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$28</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$29</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$30</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$31</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$32</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$33</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$34</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$35</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$36</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$37</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$38</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$39</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$40</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$41</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$42</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$43</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$44</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$45</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$46</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$47</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$48</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$49</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$5</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$50</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$51</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$52</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$53</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$7</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$8</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (14/ 28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$9</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$ClickCounter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.3%
  </span>
  <span class="absValue">
    (36/ 37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$ClickGenerator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (52/ 52)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$DirtyBits</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$DnDGesture</td>
<td class="coverageStat">
  <span class="percent">
    41.2%
  </span>
  <span class="absValue">
    (7/ 17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30.4%
  </span>
  <span class="absValue">
    (55/ 181)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$DragDetectedState</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$DropTargetListener</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.1%
  </span>
  <span class="absValue">
    (1/ 47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$EffectiveOrientationProperty</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$InputMethodRequestsDelegate</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3%
  </span>
  <span class="absValue">
    (1/ 33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$KeyHandler</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.3%
  </span>
  <span class="absValue">
    (29/ 34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$MouseHandler</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (146/ 227)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$MouseHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$ScenePeerListener</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (5/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.2%
  </span>
  <span class="absValue">
    (14/ 153)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$ScenePeerPaintListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$ScenePulseListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.5%
  </span>
  <span class="absValue">
    (88/ 115)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$TargetWrapper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/ 10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (42/ 42)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$TouchGesture</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Scene$TouchMap</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    19.4%
  </span>
  <span class="absValue">
    (7/ 36)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    30.9%
  </span>
  <span class="absValue">
    (188/ 609)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.9%
  </span>
  <span class="absValue">
    (898/ 2367)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package javafx.scene;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.glass.ui.Application;
<i>29</i>&nbsp;import com.sun.glass.ui.Accessible;
<i>30</i>&nbsp;import com.sun.javafx.util.Logging;
<i>31</i>&nbsp;import com.sun.javafx.util.Utils;
<i>32</i>&nbsp;import com.sun.javafx.application.PlatformImpl;
<i>33</i>&nbsp;import com.sun.javafx.collections.TrackableObservableList;
<i>34</i>&nbsp;import com.sun.javafx.css.StyleManager;
<i>35</i>&nbsp;import com.sun.javafx.cursor.CursorFrame;
<i>36</i>&nbsp;import com.sun.javafx.event.EventQueue;
<i>37</i>&nbsp;import com.sun.javafx.geom.PickRay;
<i>38</i>&nbsp;import com.sun.javafx.geom.Vec3d;
<i>39</i>&nbsp;import com.sun.javafx.geom.transform.BaseTransform;
<i>40</i>&nbsp;import com.sun.javafx.perf.PerformanceTracker;
<i>41</i>&nbsp;import com.sun.javafx.runtime.SystemProperties;
<i>42</i>&nbsp;import com.sun.javafx.scene.CssFlags;
<i>43</i>&nbsp;import com.sun.javafx.scene.LayoutFlags;
<i>44</i>&nbsp;import com.sun.javafx.scene.SceneEventDispatcher;
<i>45</i>&nbsp;import com.sun.javafx.scene.SceneHelper;
<i>46</i>&nbsp;import com.sun.javafx.scene.input.DragboardHelper;
<i>47</i>&nbsp;import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
<i>48</i>&nbsp;import com.sun.javafx.scene.input.InputEventUtils;
<i>49</i>&nbsp;import com.sun.javafx.scene.input.PickResultChooser;
<i>50</i>&nbsp;import com.sun.javafx.scene.traversal.Direction;
<i>51</i>&nbsp;import com.sun.javafx.scene.traversal.SceneTraversalEngine;
<i>52</i>&nbsp;import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
<i>53</i>&nbsp;import com.sun.javafx.sg.prism.NGCamera;
<i>54</i>&nbsp;import com.sun.javafx.sg.prism.NGLightBase;
<i>55</i>&nbsp;import com.sun.javafx.tk.*;
<i>56</i>&nbsp;import com.sun.prism.impl.PrismSettings;
<i>57</i>&nbsp;
<i>58</i>&nbsp;import javafx.animation.KeyFrame;
<i>59</i>&nbsp;import javafx.animation.Timeline;
<i>60</i>&nbsp;import javafx.application.ConditionalFeature;
<i>61</i>&nbsp;import javafx.application.Platform;
<i>62</i>&nbsp;import javafx.beans.DefaultProperty;
<i>63</i>&nbsp;import javafx.beans.InvalidationListener;
<i>64</i>&nbsp;import javafx.beans.NamedArg;
<i>65</i>&nbsp;import javafx.beans.property.*;
<i>66</i>&nbsp;import javafx.collections.FXCollections;
<i>67</i>&nbsp;import javafx.collections.ListChangeListener.Change;
<i>68</i>&nbsp;import javafx.collections.ObservableList;
<i>69</i>&nbsp;import javafx.collections.ObservableMap;
<i>70</i>&nbsp;import javafx.css.CssMetaData;
<i>71</i>&nbsp;import javafx.css.StyleableObjectProperty;
<i>72</i>&nbsp;import javafx.event.*;
<i>73</i>&nbsp;import javafx.geometry.*;
<i>74</i>&nbsp;import javafx.scene.image.WritableImage;
<i>75</i>&nbsp;import javafx.scene.input.*;
<i>76</i>&nbsp;import javafx.scene.paint.Color;
<i>77</i>&nbsp;import javafx.scene.paint.Paint;
<i>78</i>&nbsp;import javafx.stage.PopupWindow;
<i>79</i>&nbsp;import javafx.stage.Stage;
<i>80</i>&nbsp;import javafx.stage.StageStyle;
<i>81</i>&nbsp;import javafx.stage.Window;
<i>82</i>&nbsp;import javafx.util.Callback;
<i>83</i>&nbsp;import javafx.util.Duration;
<i>84</i>&nbsp;import sun.util.logging.PlatformLogger;
<i>85</i>&nbsp;import sun.util.logging.PlatformLogger.Level;
<i>86</i>&nbsp;
<i>87</i>&nbsp;import java.security.AccessControlContext;
<i>88</i>&nbsp;import java.security.AccessController;
<i>89</i>&nbsp;import java.security.PrivilegedAction;
<i>90</i>&nbsp;import java.util.*;
<i>91</i>&nbsp;import java.util.concurrent.CopyOnWriteArrayList;
<i>92</i>&nbsp;
<i>93</i>&nbsp;import com.sun.javafx.logging.PulseLogger;
<i>94</i>&nbsp;
<i>95</i>&nbsp;import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
<i>96</i>&nbsp;import com.sun.javafx.scene.NodeHelper;
<i>97</i>&nbsp;import com.sun.javafx.stage.WindowHelper;
<i>98</i>&nbsp;import com.sun.javafx.scene.input.ClipboardHelper;
<i>99</i>&nbsp;import com.sun.javafx.scene.input.TouchPointHelper;
<i>100</i>&nbsp;import java.lang.ref.WeakReference;
<i>101</i>&nbsp;
<i>102</i>&nbsp;/**
<i>103</i>&nbsp; * The JavaFX {@code Scene} class is the container for all content in a scene graph.
<i>104</i>&nbsp; * The background of the scene is filled as specified by the {@code fill} property.
<i>105</i>&nbsp; * &lt;p&gt;
<i>106</i>&nbsp; * The application must specify the root {@code Node} for the scene graph by setting
<i>107</i>&nbsp; * the {@code root} property.   If a {@code Group} is used as the root, the
<i>108</i>&nbsp; * contents of the scene graph will be clipped by the scene&#39;s width and height and
<i>109</i>&nbsp; * changes to the scene&#39;s size (if user resizes the stage) will not alter the
<i>110</i>&nbsp; * layout of the scene graph.    If a resizable node (layout {@code Region} or
<i>111</i>&nbsp; * {@code Control} is set as the root, then the root&#39;s size will track the
<i>112</i>&nbsp; * scene&#39;s size, causing the contents to be relayed out as necessary.
<i>113</i>&nbsp; * &lt;p&gt;
<i>114</i>&nbsp; * The scene&#39;s size may be initialized by the application during construction.
<i>115</i>&nbsp; * If no size is specified, the scene will automatically compute its initial
<i>116</i>&nbsp; * size based on the preferred size of its content. If only one dimension is specified,
<i>117</i>&nbsp; * the other dimension is computed using the specified dimension, respecting content bias
<i>118</i>&nbsp; * of a root.
<i>119</i>&nbsp; * &lt;p&gt;
<i>120</i>&nbsp; * An application may request depth buffer support or scene anti-aliasing
<i>121</i>&nbsp; * support at the creation of a {@code Scene}. A scene with only 2D shapes and
<i>122</i>&nbsp; * without any 3D transforms does not need a depth buffer nor scene
<i>123</i>&nbsp; * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
<i>124</i>&nbsp; * transforms may use depth buffer support for proper depth sorted rendering; to
<i>125</i>&nbsp; * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
<i>126</i>&nbsp; * shapes that have no 3D transforms. See
<i>127</i>&nbsp; * {@link Node#depthTestProperty depthTest} for more information. A scene with
<i>128</i>&nbsp; * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
<i>129</i>&nbsp; * &lt;p&gt;
<i>130</i>&nbsp; * The depthBuffer and antiAliasing flags are conditional features. With the
<i>131</i>&nbsp; * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
<i>132</i>&nbsp; * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
<i>133</i>&nbsp; * for more information.
<i>134</i>&nbsp; * &lt;p&gt;
<i>135</i>&nbsp; * A default headlight will be added to a scene that contains one or more
<i>136</i>&nbsp; * {@code Shape3D} nodes, but no light nodes. This light source is a
<i>137</i>&nbsp; * {@code Color.WHITE} {@code PointLight} placed at the camera position.
<i>138</i>&nbsp; *
<i>139</i>&nbsp; * &lt;p&gt;
<i>140</i>&nbsp; * A {@code Scene} may be created and modified on any thread until it is attached
<i>141</i>&nbsp; * to a {@link Window} that is {@link Window#isShowing showing}.
<i>142</i>&nbsp; * After that, it must be modified only on the JavaFX Application Thread.
<i>143</i>&nbsp; * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
<i>144</i>&nbsp; * multiple threads at the same time will lead to unpredictable results and
<i>145</i>&nbsp; * must be avoided.
<i>146</i>&nbsp; * &lt;/p&gt;
<i>147</i>&nbsp; *
<i>148</i>&nbsp; * &lt;p&gt;
<i>149</i>&nbsp; * The JavaFX Application Thread is created as part of the startup process for
<i>150</i>&nbsp; * the JavaFX runtime. See the {@link javafx.application.Application} class and
<i>151</i>&nbsp; * the {@link Platform#startup(Runnable)} method for more information.
<i>152</i>&nbsp; * &lt;/p&gt;
<i>153</i>&nbsp; *
<i>154</i>&nbsp; * &lt;p&gt;Example:&lt;/p&gt;
<i>155</i>&nbsp; *
<i>156</i>&nbsp; * &lt;pre&gt;
<i>157</i>&nbsp;import javafx.scene.*;
<i>158</i>&nbsp;import javafx.scene.paint.*;
<i>159</i>&nbsp;import javafx.scene.shape.*;
<i>160</i>&nbsp;
<i>161</i>&nbsp;Group root = new Group();
<i>162</i>&nbsp;Scene s = new Scene(root, 300, 300, Color.BLACK);
<i>163</i>&nbsp;
<i>164</i>&nbsp;Rectangle r = new Rectangle(25,25,250,250);
<i>165</i>&nbsp;r.setFill(Color.BLUE);
<i>166</i>&nbsp;
<i>167</i>&nbsp;root.getChildren().add(r);
<i>168</i>&nbsp; * &lt;/pre&gt;
<i>169</i>&nbsp; *
<i>170</i>&nbsp; * @since JavaFX 2.0
<i>171</i>&nbsp; */
<b class="fc"><i>172</i>&nbsp;@DefaultProperty(&quot;root&quot;)</b>
<b class="fc"><i>173</i>&nbsp;public class Scene implements EventTarget {</b>
<i>174</i>&nbsp;
<b class="fc"><i>175</i>&nbsp;    private double widthSetByUser = -1.0;</b>
<b class="fc"><i>176</i>&nbsp;    private double heightSetByUser = -1.0;</b>
<b class="fc"><i>177</i>&nbsp;    private boolean sizeInitialized = false;</b>
<i>178</i>&nbsp;    private final boolean depthBuffer;
<i>179</i>&nbsp;    private final SceneAntialiasing antiAliasing;
<i>180</i>&nbsp;
<i>181</i>&nbsp;    private int dirtyBits;
<i>182</i>&nbsp;
<b class="fc"><i>183</i>&nbsp;    final AccessControlContext acc = AccessController.getContext();</b>
<i>184</i>&nbsp;
<i>185</i>&nbsp;    private Camera defaultCamera;
<i>186</i>&nbsp;
<i>187</i>&nbsp;    /**
<i>188</i>&nbsp;     * A node that is temporarily responsible for the FOCUS_NODE
<i>189</i>&nbsp;     * accessibility attribute. E.g. a currently active MenuBar.
<i>190</i>&nbsp;     */
<i>191</i>&nbsp;    private Node transientFocusContainer;
<i>192</i>&nbsp;
<i>193</i>&nbsp;    //Neither width nor height are initialized and will be calculated according to content when this Scene
<i>194</i>&nbsp;    //is shown for the first time.
<i>195</i>&nbsp;//    public Scene() {
<i>196</i>&nbsp;//        //this(-1, -1, (Parent) new Group());
<i>197</i>&nbsp;//        this(-1, -1, (Parent)null);
<i>198</i>&nbsp;//    }
<i>199</i>&nbsp;
<i>200</i>&nbsp;    /**
<i>201</i>&nbsp;     * Creates a Scene for a specific root Node.
<i>202</i>&nbsp;     *
<i>203</i>&nbsp;     * @param root The root node of the scene graph
<i>204</i>&nbsp;     *
<i>205</i>&nbsp;     * @throws NullPointerException if root is null
<i>206</i>&nbsp;     */
<i>207</i>&nbsp;    public Scene(@NamedArg(&quot;root&quot;) Parent root) {
<b class="fc"><i>208</i>&nbsp;        this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);</b>
<b class="fc"><i>209</i>&nbsp;    }</b>
<i>210</i>&nbsp;
<i>211</i>&nbsp;//Public constructor initializing public-init properties
<i>212</i>&nbsp;//When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
<i>213</i>&nbsp;//Unitialized dimension is calculated when Scene is shown for the first time.
<i>214</i>&nbsp;//    public Scene(
<i>215</i>&nbsp;//            @Default(&quot;-1&quot;) double width,
<i>216</i>&nbsp;//            @Default(&quot;-1&quot;) double height) {
<i>217</i>&nbsp;//        //this(width, height, (Parent)new Group());
<i>218</i>&nbsp;//        this(width, height, (Parent)null);
<i>219</i>&nbsp;//    }
<i>220</i>&nbsp;//
<i>221</i>&nbsp;//    public Scene(double width, double height, Paint fill) {
<i>222</i>&nbsp;//        //this(width, height, (Parent) new Group());
<i>223</i>&nbsp;//        this(width, height, (Parent)null);
<i>224</i>&nbsp;//        setFill(fill);
<i>225</i>&nbsp;//    }
<i>226</i>&nbsp;
<i>227</i>&nbsp;    /**
<i>228</i>&nbsp;     * Creates a Scene for a specific root Node with a specific size.
<i>229</i>&nbsp;     *
<i>230</i>&nbsp;     * @param root The root node of the scene graph
<i>231</i>&nbsp;     * @param width The width of the scene
<i>232</i>&nbsp;     * @param height The height of the scene
<i>233</i>&nbsp;     *
<i>234</i>&nbsp;     * @throws NullPointerException if root is null
<i>235</i>&nbsp;     */
<i>236</i>&nbsp;    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
<b class="nc"><i>237</i>&nbsp;        this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);</b>
<b class="nc"><i>238</i>&nbsp;    }</b>
<i>239</i>&nbsp;
<i>240</i>&nbsp;    /**
<i>241</i>&nbsp;     * Creates a Scene for a specific root Node with a fill.
<i>242</i>&nbsp;     *
<i>243</i>&nbsp;     * @param root The parent
<i>244</i>&nbsp;     * @param fill The fill
<i>245</i>&nbsp;     *
<i>246</i>&nbsp;     * @throws NullPointerException if root is null
<i>247</i>&nbsp;     */
<i>248</i>&nbsp;    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
<b class="nc"><i>249</i>&nbsp;        this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);</b>
<b class="nc"><i>250</i>&nbsp;    }</b>
<i>251</i>&nbsp;
<i>252</i>&nbsp;    /**
<i>253</i>&nbsp;     * Creates a Scene for a specific root Node with a specific size and fill.
<i>254</i>&nbsp;     *
<i>255</i>&nbsp;     * @param root The root node of the scene graph
<i>256</i>&nbsp;     * @param width The width of the scene
<i>257</i>&nbsp;     * @param height The height of the scene
<i>258</i>&nbsp;     * @param fill The fill
<i>259</i>&nbsp;     *
<i>260</i>&nbsp;     * @throws NullPointerException if root is null
<i>261</i>&nbsp;     */
<i>262</i>&nbsp;    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
<i>263</i>&nbsp;            @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
<b class="nc"><i>264</i>&nbsp;        this(root, width, height, fill, false, SceneAntialiasing.DISABLED);</b>
<b class="nc"><i>265</i>&nbsp;    }</b>
<i>266</i>&nbsp;
<i>267</i>&nbsp;    /**
<i>268</i>&nbsp;     * Constructs a scene consisting of a root, with a dimension of width and
<i>269</i>&nbsp;     * height, and specifies whether a depth buffer is created for this scene.
<i>270</i>&nbsp;     * &lt;p&gt;
<i>271</i>&nbsp;     * A scene with only 2D shapes and without any 3D transforms does not need a
<i>272</i>&nbsp;     * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
<i>273</i>&nbsp;     * transforms may use depth buffer support for proper depth sorted
<i>274</i>&nbsp;     * rendering; to avoid depth fighting (also known as Z fighting), disable
<i>275</i>&nbsp;     * depth testing on 2D shapes that have no 3D transforms. See
<i>276</i>&nbsp;     * {@link Node#depthTestProperty depthTest} for more information.
<i>277</i>&nbsp;     *
<i>278</i>&nbsp;     * @param root The root node of the scene graph
<i>279</i>&nbsp;     * @param width The width of the scene
<i>280</i>&nbsp;     * @param height The height of the scene
<i>281</i>&nbsp;     * @param depthBuffer The depth buffer flag
<i>282</i>&nbsp;     * &lt;p&gt;
<i>283</i>&nbsp;     * The depthBuffer flag is a conditional feature and its default value is
<i>284</i>&nbsp;     * false. See
<i>285</i>&nbsp;     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
<i>286</i>&nbsp;     * for more information.
<i>287</i>&nbsp;     *
<i>288</i>&nbsp;     * @throws NullPointerException if root is null
<i>289</i>&nbsp;     *
<i>290</i>&nbsp;     * @see javafx.scene.Node#setDepthTest(DepthTest)
<i>291</i>&nbsp;     */
<i>292</i>&nbsp;    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
<b class="nc"><i>293</i>&nbsp;        this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);</b>
<b class="nc"><i>294</i>&nbsp;    }</b>
<i>295</i>&nbsp;
<i>296</i>&nbsp;    /**
<i>297</i>&nbsp;     * Constructs a scene consisting of a root, with a dimension of width and
<i>298</i>&nbsp;     * height, specifies whether a depth buffer is created for this scene and
<i>299</i>&nbsp;     * specifies whether scene anti-aliasing is requested.
<i>300</i>&nbsp;     * &lt;p&gt;
<i>301</i>&nbsp;     * A scene with only 2D shapes and without any 3D transforms does not need a
<i>302</i>&nbsp;     * depth buffer nor scene anti-aliasing support. A scene containing 3D
<i>303</i>&nbsp;     * shapes or 2D shapes with 3D transforms may use depth buffer support for
<i>304</i>&nbsp;     * proper depth sorted rendering; to avoid depth fighting (also known as Z
<i>305</i>&nbsp;     * fighting), disable depth testing on 2D shapes that have no 3D transforms.
<i>306</i>&nbsp;     * See {@link Node#depthTestProperty depthTest} for more information. A
<i>307</i>&nbsp;     * scene with 3D shapes may enable scene anti-aliasing to improve its
<i>308</i>&nbsp;     * rendering quality.
<i>309</i>&nbsp;     *
<i>310</i>&nbsp;     * @param root The root node of the scene graph
<i>311</i>&nbsp;     * @param width The width of the scene
<i>312</i>&nbsp;     * @param height The height of the scene
<i>313</i>&nbsp;     * @param depthBuffer The depth buffer flag
<i>314</i>&nbsp;     * @param antiAliasing The scene anti-aliasing attribute. A value of
<i>315</i>&nbsp;     * {@code null} is treated as DISABLED.
<i>316</i>&nbsp;     * &lt;p&gt;
<i>317</i>&nbsp;     * The depthBuffer and antiAliasing are conditional features. With the
<i>318</i>&nbsp;     * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
<i>319</i>&nbsp;     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
<i>320</i>&nbsp;     * for more information.
<i>321</i>&nbsp;     *
<i>322</i>&nbsp;     * @throws NullPointerException if root is null
<i>323</i>&nbsp;     *
<i>324</i>&nbsp;     * @see javafx.scene.Node#setDepthTest(DepthTest)
<i>325</i>&nbsp;     * @since JavaFX 8.0
<i>326</i>&nbsp;     */
<i>327</i>&nbsp;    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
<i>328</i>&nbsp;            @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
<i>329</i>&nbsp;            @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
<b class="nc"><i>330</i>&nbsp;        this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);</b>
<i>331</i>&nbsp;
<b class="nc"><i>332</i>&nbsp;        if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;</b>
<b class="nc"><i>333</i>&nbsp;                !Toolkit.getToolkit().isMSAASupported())</b>
<i>334</i>&nbsp;        {
<b class="nc"><i>335</i>&nbsp;            String logname = Scene.class.getName();</b>
<b class="nc"><i>336</i>&nbsp;            PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;</b>
<i>337</i>&nbsp;                + &quot;antiAliasing&quot;);
<i>338</i>&nbsp;        }
<b class="nc"><i>339</i>&nbsp;    }</b>
<i>340</i>&nbsp;
<i>341</i>&nbsp;    private Scene(Parent root, double width, double height, Paint fill,
<b class="fc"><i>342</i>&nbsp;            boolean depthBuffer, SceneAntialiasing antiAliasing) {</b>
<b class="fc"><i>343</i>&nbsp;        this.depthBuffer = depthBuffer;</b>
<b class="fc"><i>344</i>&nbsp;        this.antiAliasing = antiAliasing;</b>
<b class="fc"><i>345</i>&nbsp;        if (root == null) {</b>
<b class="nc"><i>346</i>&nbsp;            throw new NullPointerException(&quot;Root cannot be null&quot;);</b>
<i>347</i>&nbsp;        }
<i>348</i>&nbsp;
<b class="fc"><i>349</i>&nbsp;        if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))</b>
<b class="nc"><i>350</i>&nbsp;                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {</b>
<b class="nc"><i>351</i>&nbsp;            String logname = Scene.class.getName();</b>
<b class="nc"><i>352</i>&nbsp;            PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;</b>
<i>353</i>&nbsp;                    + &quot;ConditionalFeature.SCENE3D&quot;);
<i>354</i>&nbsp;        }
<i>355</i>&nbsp;
<b class="fc"><i>356</i>&nbsp;        init();</b>
<b class="fc"><i>357</i>&nbsp;        setRoot(root);</b>
<b class="fc"><i>358</i>&nbsp;        init(width, height);</b>
<b class="fc"><i>359</i>&nbsp;        setFill(fill);</b>
<b class="fc"><i>360</i>&nbsp;    }</b>
<i>361</i>&nbsp;
<i>362</i>&nbsp;    static {
<b class="fc"><i>363</i>&nbsp;            PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {</b>
<i>364</i>&nbsp;                public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
<b class="nc"><i>365</i>&nbsp;                    synchronized (trackerMonitor) {</b>
<b class="nc"><i>366</i>&nbsp;                        scene.tracker = tracker;</b>
<b class="nc"><i>367</i>&nbsp;                    }</b>
<b class="nc"><i>368</i>&nbsp;                }</b>
<i>369</i>&nbsp;                public PerformanceTracker getPerfTracker(Scene scene) {
<b class="nc"><i>370</i>&nbsp;                    synchronized (trackerMonitor) {</b>
<b class="nc"><i>371</i>&nbsp;                        return scene.tracker;</b>
<b class="nc"><i>372</i>&nbsp;                    }</b>
<i>373</i>&nbsp;                }
<i>374</i>&nbsp;            });
<b class="fc"><i>375</i>&nbsp;            SceneHelper.setSceneAccessor(</b>
<b class="fc"><i>376</i>&nbsp;                    new SceneHelper.SceneAccessor() {</b>
<i>377</i>&nbsp;                        @Override
<i>378</i>&nbsp;                        public void enableInputMethodEvents(Scene scene, boolean enable) {
<b class="nc"><i>379</i>&nbsp;                            scene.enableInputMethodEvents(enable);</b>
<b class="nc"><i>380</i>&nbsp;                        }</b>
<i>381</i>&nbsp;
<i>382</i>&nbsp;                        @Override
<i>383</i>&nbsp;                        public void processKeyEvent(Scene scene, KeyEvent e) {
<b class="nc"><i>384</i>&nbsp;                            scene.processKeyEvent(e);</b>
<b class="nc"><i>385</i>&nbsp;                        }</b>
<i>386</i>&nbsp;
<i>387</i>&nbsp;                        @Override
<i>388</i>&nbsp;                        public void processMouseEvent(Scene scene, MouseEvent e) {
<b class="nc"><i>389</i>&nbsp;                            scene.processMouseEvent(e);</b>
<b class="nc"><i>390</i>&nbsp;                        }</b>
<i>391</i>&nbsp;
<i>392</i>&nbsp;                        @Override
<i>393</i>&nbsp;                        public void preferredSize(Scene scene) {
<b class="fc"><i>394</i>&nbsp;                            scene.preferredSize();</b>
<b class="fc"><i>395</i>&nbsp;                        }</b>
<i>396</i>&nbsp;
<i>397</i>&nbsp;                        @Override
<i>398</i>&nbsp;                        public void disposePeer(Scene scene) {
<b class="fc"><i>399</i>&nbsp;                            scene.disposePeer();</b>
<b class="fc"><i>400</i>&nbsp;                        }</b>
<i>401</i>&nbsp;
<i>402</i>&nbsp;                        @Override
<i>403</i>&nbsp;                        public void initPeer(Scene scene) {
<b class="fc"><i>404</i>&nbsp;                            scene.initPeer();</b>
<b class="fc"><i>405</i>&nbsp;                        }</b>
<i>406</i>&nbsp;
<i>407</i>&nbsp;                        @Override
<i>408</i>&nbsp;                        public void setWindow(Scene scene, Window window) {
<b class="fc"><i>409</i>&nbsp;                            scene.setWindow(window);</b>
<b class="fc"><i>410</i>&nbsp;                        }</b>
<i>411</i>&nbsp;
<i>412</i>&nbsp;                        @Override
<i>413</i>&nbsp;                        public TKPulseListener getScenePulseListener(Scene scene) {
<b class="nc"><i>414</i>&nbsp;                            return scene.getScenePulseListener();</b>
<i>415</i>&nbsp;                        }
<i>416</i>&nbsp;
<i>417</i>&nbsp;                        @Override
<i>418</i>&nbsp;                        public TKScene getPeer(Scene scene) {
<b class="fc"><i>419</i>&nbsp;                            return scene.getPeer();</b>
<i>420</i>&nbsp;                        }
<i>421</i>&nbsp;
<i>422</i>&nbsp;                        @Override
<i>423</i>&nbsp;                        public void setAllowPGAccess(boolean flag) {
<b class="nc"><i>424</i>&nbsp;                            Scene.setAllowPGAccess(flag);</b>
<b class="nc"><i>425</i>&nbsp;                        }</b>
<i>426</i>&nbsp;
<i>427</i>&nbsp;                        @Override
<i>428</i>&nbsp;                        public void setPaused(boolean paused) {
<b class="nc"><i>429</i>&nbsp;                            Scene.paused = paused;</b>
<b class="nc"><i>430</i>&nbsp;                        }</b>
<i>431</i>&nbsp;
<i>432</i>&nbsp;                        @Override
<i>433</i>&nbsp;                        public void parentEffectiveOrientationInvalidated(
<i>434</i>&nbsp;                                final Scene scene) {
<b class="fc"><i>435</i>&nbsp;                            scene.parentEffectiveOrientationInvalidated();</b>
<b class="fc"><i>436</i>&nbsp;                        }</b>
<i>437</i>&nbsp;
<i>438</i>&nbsp;                        @Override
<i>439</i>&nbsp;                        public Camera getEffectiveCamera(Scene scene) {
<b class="fc"><i>440</i>&nbsp;                            return scene.getEffectiveCamera();</b>
<i>441</i>&nbsp;                        }
<i>442</i>&nbsp;
<i>443</i>&nbsp;                        @Override
<i>444</i>&nbsp;                        public Scene createPopupScene(Parent root) {
<b class="fc"><i>445</i>&nbsp;                            return new Scene(root) {</b>
<i>446</i>&nbsp;                                       @Override
<i>447</i>&nbsp;                                       void doLayoutPass() {
<b class="fc"><i>448</i>&nbsp;                                           resizeRootToPreferredSize(getRoot());</b>
<b class="fc"><i>449</i>&nbsp;                                           super.doLayoutPass();</b>
<b class="fc"><i>450</i>&nbsp;                                       }</b>
<i>451</i>&nbsp;
<i>452</i>&nbsp;                                       @Override
<i>453</i>&nbsp;                                       void resizeRootOnSceneSizeChange(
<i>454</i>&nbsp;                                               double newWidth,
<i>455</i>&nbsp;                                               double newHeight) {
<i>456</i>&nbsp;                                           // don&#39;t resize
<b class="fc"><i>457</i>&nbsp;                                       }</b>
<i>458</i>&nbsp;                                   };
<i>459</i>&nbsp;                        }
<i>460</i>&nbsp;
<i>461</i>&nbsp;                        @Override
<i>462</i>&nbsp;                        public void setTransientFocusContainer(Scene scene, Node node) {
<b class="nc"><i>463</i>&nbsp;                            if (scene != null) {</b>
<b class="nc"><i>464</i>&nbsp;                                scene.transientFocusContainer = node;</b>
<i>465</i>&nbsp;                            }
<b class="nc"><i>466</i>&nbsp;                        }</b>
<i>467</i>&nbsp;
<i>468</i>&nbsp;                        @Override
<i>469</i>&nbsp;                        public Accessible getAccessible(Scene scene) {
<b class="nc"><i>470</i>&nbsp;                            return scene.getAccessible();</b>
<i>471</i>&nbsp;                        }
<i>472</i>&nbsp;                    });
<i>473</i>&nbsp;        }
<i>474</i>&nbsp;
<i>475</i>&nbsp;        // Reserve space for 30 nodes in the dirtyNodes set.
<i>476</i>&nbsp;        private static final int MIN_DIRTY_CAPACITY = 30;
<i>477</i>&nbsp;
<i>478</i>&nbsp;        // For debugging
<b class="fc"><i>479</i>&nbsp;        private static boolean inSynchronizer = false;</b>
<b class="fc"><i>480</i>&nbsp;        private static boolean inMousePick = false;</b>
<b class="fc"><i>481</i>&nbsp;        private static boolean allowPGAccess = false;</b>
<b class="fc"><i>482</i>&nbsp;        private static int pgAccessCount = 0;</b>
<i>483</i>&nbsp;
<i>484</i>&nbsp;        // Flag set by the Toolkit when we are paused for JMX debugging
<b class="fc"><i>485</i>&nbsp;        private static boolean paused = false;</b>
<i>486</i>&nbsp;
<i>487</i>&nbsp;        /**
<i>488</i>&nbsp;         * Used for debugging purposes. Returns true if we are in either the
<i>489</i>&nbsp;         * mouse event code (picking) or the synchronizer, or if the scene is
<i>490</i>&nbsp;         * not yet initialized,
<i>491</i>&nbsp;         *
<i>492</i>&nbsp;         */
<i>493</i>&nbsp;        static boolean isPGAccessAllowed() {
<b class="nc"><i>494</i>&nbsp;            return inSynchronizer || inMousePick || allowPGAccess;</b>
<i>495</i>&nbsp;        }
<i>496</i>&nbsp;
<i>497</i>&nbsp;        static void setAllowPGAccess(boolean flag) {
<b class="fc"><i>498</i>&nbsp;            if (Utils.assertionEnabled()) {</b>
<b class="nc"><i>499</i>&nbsp;                if (flag) {</b>
<b class="nc"><i>500</i>&nbsp;                    pgAccessCount++;</b>
<b class="nc"><i>501</i>&nbsp;                    allowPGAccess = true;</b>
<i>502</i>&nbsp;                }
<i>503</i>&nbsp;                else {
<b class="nc"><i>504</i>&nbsp;                    if (pgAccessCount &lt;= 0) {</b>
<b class="nc"><i>505</i>&nbsp;                        throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);</b>
<i>506</i>&nbsp;                    }
<b class="nc"><i>507</i>&nbsp;                    if (--pgAccessCount == 0) {</b>
<b class="nc"><i>508</i>&nbsp;                        allowPGAccess = false;</b>
<i>509</i>&nbsp;                    }
<i>510</i>&nbsp;                }
<i>511</i>&nbsp;            }
<b class="fc"><i>512</i>&nbsp;        }</b>
<i>513</i>&nbsp;
<i>514</i>&nbsp;        /**
<i>515</i>&nbsp;         * If true, use the platform&#39;s drag gesture detection
<i>516</i>&nbsp;         * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
<i>517</i>&nbsp;         */
<i>518</i>&nbsp;        private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;
<i>519</i>&nbsp;
<i>520</i>&nbsp;    /**
<i>521</i>&nbsp;     * Set of dirty nodes; processed once per frame by the synchronizer.
<i>522</i>&nbsp;     * When a node&#39;s state changes such that it becomes &quot;dirty&quot; with respect
<i>523</i>&nbsp;     * to the graphics stack and requires synchronization, then that node
<i>524</i>&nbsp;     * is added to this list. Note that if state on the Node changes, but it
<i>525</i>&nbsp;     * was already dirty, then the Node doesn&#39;t add itself again.
<i>526</i>&nbsp;     * &lt;p&gt;
<i>527</i>&nbsp;     * Because at initialization time every node in the scene graph is dirty,
<i>528</i>&nbsp;     * we have a special state and special code path during initialization
<i>529</i>&nbsp;     * that does not involve adding each node to the dirtyNodes list. When
<i>530</i>&nbsp;     * dirtyNodes is null, that means this Scene has not yet been synchronized.
<i>531</i>&nbsp;     * A good default size is then created for the dirtyNodes list.
<i>532</i>&nbsp;     * &lt;p&gt;
<i>533</i>&nbsp;     * We double-buffer the set so that we can add new nodes to the
<i>534</i>&nbsp;     * set while processing the existing set. This avoids our having to
<i>535</i>&nbsp;     * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
<i>536</i>&nbsp;     */
<i>537</i>&nbsp;    private Node[] dirtyNodes;
<i>538</i>&nbsp;    private int dirtyNodesSize;
<i>539</i>&nbsp;
<i>540</i>&nbsp;    /**
<i>541</i>&nbsp;     * Add the specified node to this scene&#39;s dirty list. Called by the
<i>542</i>&nbsp;     * markDirty method in Node or when the Node&#39;s scene changes.
<i>543</i>&nbsp;     */
<i>544</i>&nbsp;    void addToDirtyList(Node n) {
<b class="fc"><i>545</i>&nbsp;        if (dirtyNodes == null || dirtyNodesSize == 0) {</b>
<b class="fc"><i>546</i>&nbsp;            if (peer != null) {</b>
<b class="fc"><i>547</i>&nbsp;                Toolkit.getToolkit().requestNextPulse();</b>
<i>548</i>&nbsp;            }
<i>549</i>&nbsp;        }
<i>550</i>&nbsp;
<b class="fc"><i>551</i>&nbsp;        if (dirtyNodes != null) {</b>
<b class="fc"><i>552</i>&nbsp;            if (dirtyNodesSize == dirtyNodes.length) {</b>
<b class="nc"><i>553</i>&nbsp;                Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];</b>
<b class="nc"><i>554</i>&nbsp;                System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);</b>
<b class="nc"><i>555</i>&nbsp;                dirtyNodes = tmp;</b>
<i>556</i>&nbsp;            }
<b class="fc"><i>557</i>&nbsp;            dirtyNodes[dirtyNodesSize++] = n;</b>
<i>558</i>&nbsp;        }
<b class="fc"><i>559</i>&nbsp;    }</b>
<i>560</i>&nbsp;
<i>561</i>&nbsp;    private void doCSSPass() {
<b class="fc"><i>562</i>&nbsp;        final Parent sceneRoot = getRoot();</b>
<i>563</i>&nbsp;        //
<i>564</i>&nbsp;        // RT-17547: when the tree is synchronized, the dirty bits are
<i>565</i>&nbsp;        // are cleared but the cssFlag might still be something other than
<i>566</i>&nbsp;        // clean.
<i>567</i>&nbsp;        //
<i>568</i>&nbsp;        // Before RT-17547, the code checked the dirty bit. But this is
<i>569</i>&nbsp;        // superfluous since the dirty bit will be set if the flag is not clean,
<i>570</i>&nbsp;        // but the flag will never be anything other than clean if the dirty
<i>571</i>&nbsp;        // bit is not set. The dirty bit is still needed, however, since setting
<i>572</i>&nbsp;        // it ensures a pulse if no other dirty bits have been set.
<i>573</i>&nbsp;        //
<i>574</i>&nbsp;        // For the purpose of showing the change, the dirty bit
<i>575</i>&nbsp;        // check code was commented out and not removed.
<i>576</i>&nbsp;        //
<i>577</i>&nbsp;//        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
<b class="fc"><i>578</i>&nbsp;        if (sceneRoot.cssFlag != CssFlags.CLEAN) {</b>
<i>579</i>&nbsp;            // The dirty bit isn&#39;t checked but we must ensure it is cleared.
<i>580</i>&nbsp;            // The cssFlag is set to clean in either Node.processCSS or
<i>581</i>&nbsp;            // NodeHelper.processCSS
<b class="fc"><i>582</i>&nbsp;            sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);</b>
<b class="fc"><i>583</i>&nbsp;            sceneRoot.processCSS();</b>
<i>584</i>&nbsp;        }
<b class="fc"><i>585</i>&nbsp;    }</b>
<i>586</i>&nbsp;
<i>587</i>&nbsp;    void doLayoutPass() {
<b class="fc"><i>588</i>&nbsp;        final Parent r = getRoot();</b>
<b class="fc"><i>589</i>&nbsp;        if (r != null) {</b>
<b class="fc"><i>590</i>&nbsp;            r.layout();</b>
<i>591</i>&nbsp;        }
<b class="fc"><i>592</i>&nbsp;    }</b>
<i>593</i>&nbsp;
<i>594</i>&nbsp;    /**
<i>595</i>&nbsp;     * The peer of this scene
<i>596</i>&nbsp;     */
<i>597</i>&nbsp;    private TKScene peer;
<i>598</i>&nbsp;
<i>599</i>&nbsp;    /*
<i>600</i>&nbsp;     * Get Scene&#39;s peer
<i>601</i>&nbsp;     */
<i>602</i>&nbsp;    TKScene getPeer() {
<b class="fc"><i>603</i>&nbsp;        return peer;</b>
<i>604</i>&nbsp;    }
<i>605</i>&nbsp;
<i>606</i>&nbsp;    /**
<i>607</i>&nbsp;     * The scene pulse listener that gets called on toolkit pulses
<i>608</i>&nbsp;     */
<b class="fc"><i>609</i>&nbsp;    ScenePulseListener scenePulseListener = new ScenePulseListener();</b>
<i>610</i>&nbsp;
<i>611</i>&nbsp;    TKPulseListener getScenePulseListener() {
<b class="nc"><i>612</i>&nbsp;        if (SystemProperties.isDebug()) {</b>
<b class="nc"><i>613</i>&nbsp;            return scenePulseListener;</b>
<i>614</i>&nbsp;        }
<b class="nc"><i>615</i>&nbsp;        return null;</b>
<i>616</i>&nbsp;    }
<i>617</i>&nbsp;
<i>618</i>&nbsp;    private List&lt;Runnable&gt; preLayoutPulseListeners;
<i>619</i>&nbsp;    private List&lt;Runnable&gt; postLayoutPulseListeners;
<i>620</i>&nbsp;
<i>621</i>&nbsp;    /**
<i>622</i>&nbsp;     * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
<i>623</i>&nbsp;     * this listener will be called on the JavaFX Application Thread directly
<i>624</i>&nbsp;     * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
<i>625</i>&nbsp;     * any rendering is done for
<i>626</i>&nbsp;     * this frame. This scene pulse listener is suitable for knowing when a
<i>627</i>&nbsp;     * scenegraph pulse is happening and also for modifying the scenegraph
<i>628</i>&nbsp;     * (as it is called before CSS and layout, so any changes made will be properly
<i>629</i>&nbsp;     * styled and positioned).
<i>630</i>&nbsp;     *
<i>631</i>&nbsp;     * This method must be called on the JavaFX Application thread.
<i>632</i>&nbsp;     *
<i>633</i>&nbsp;     * @param r The Runnable to be called when the pulse occurs.
<i>634</i>&nbsp;     *
<i>635</i>&nbsp;     * @throws IllegalStateException if this method is called on a thread
<i>636</i>&nbsp;     * other than the JavaFX Application Thread.
<i>637</i>&nbsp;     *
<i>638</i>&nbsp;     * @throws NullPointerException if the provided Runnable is null.
<i>639</i>&nbsp;     *
<i>640</i>&nbsp;     * @since 9
<i>641</i>&nbsp;     */
<i>642</i>&nbsp;    public final void addPreLayoutPulseListener(Runnable r) {
<b class="nc"><i>643</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<i>644</i>&nbsp;
<b class="nc"><i>645</i>&nbsp;        if (r == null) {</b>
<b class="nc"><i>646</i>&nbsp;            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);</b>
<i>647</i>&nbsp;        }
<b class="nc"><i>648</i>&nbsp;        if (preLayoutPulseListeners == null) {</b>
<b class="nc"><i>649</i>&nbsp;            preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();</b>
<i>650</i>&nbsp;        }
<b class="nc"><i>651</i>&nbsp;        preLayoutPulseListeners.add(r);</b>
<b class="nc"><i>652</i>&nbsp;    }</b>
<i>653</i>&nbsp;
<i>654</i>&nbsp;    /**
<i>655</i>&nbsp;     * Removes a previously registered scene pre layout pulse listener from listening to
<i>656</i>&nbsp;     * pulses in this scene. This method does nothing if the specified Runnable is
<i>657</i>&nbsp;     * not already in the list.
<i>658</i>&nbsp;     *
<i>659</i>&nbsp;     * This method must be called on the JavaFX Application thread.
<i>660</i>&nbsp;     *
<i>661</i>&nbsp;     * @param r The Runnable that should no longer be called when the pulse
<i>662</i>&nbsp;     * occurs for this scene.
<i>663</i>&nbsp;     *
<i>664</i>&nbsp;     * @throws IllegalStateException if this method is called on a thread
<i>665</i>&nbsp;     * other than the JavaFX Application Thread.
<i>666</i>&nbsp;     *
<i>667</i>&nbsp;     * @since 9
<i>668</i>&nbsp;     */
<i>669</i>&nbsp;    public final void removePreLayoutPulseListener(Runnable r) {
<b class="nc"><i>670</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<i>671</i>&nbsp;
<b class="nc"><i>672</i>&nbsp;        if (preLayoutPulseListeners == null) {</b>
<b class="nc"><i>673</i>&nbsp;            return;</b>
<i>674</i>&nbsp;        }
<b class="nc"><i>675</i>&nbsp;        preLayoutPulseListeners.remove(r);</b>
<b class="nc"><i>676</i>&nbsp;    }</b>
<i>677</i>&nbsp;
<i>678</i>&nbsp;    /**
<i>679</i>&nbsp;     * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
<i>680</i>&nbsp;     * this listener will be called on the JavaFX Application Thread directly
<i>681</i>&nbsp;     * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
<i>682</i>&nbsp;     * this frame. This scene pulse listener is suitable for knowing when a
<i>683</i>&nbsp;     * scenegraph pulse is happening, but it is not suited to use cases related
<i>684</i>&nbsp;     * to modifying the scenegraph (as it is called after CSS and layout, so
<i>685</i>&nbsp;     * any changes will possibly be incorrect until the next pulse is run).
<i>686</i>&nbsp;     * An alternative (and better) solution for situations where a scenegraph
<i>687</i>&nbsp;     * modification is required to happen is to use either the
<i>688</i>&nbsp;     * {@link #addPreLayoutPulseListener(Runnable)} API or the the
<i>689</i>&nbsp;     * {@link javafx.animation.AnimationTimer} API.
<i>690</i>&nbsp;     *
<i>691</i>&nbsp;     * This method must be called on the JavaFX Application thread.
<i>692</i>&nbsp;     *
<i>693</i>&nbsp;     * @param r The Runnable to be called when the pulse occurs.
<i>694</i>&nbsp;     *
<i>695</i>&nbsp;     * @throws IllegalStateException if this method is called on a thread
<i>696</i>&nbsp;     * other than the JavaFX Application Thread.
<i>697</i>&nbsp;     *
<i>698</i>&nbsp;     * @throws NullPointerException if the provided Runnable is null.
<i>699</i>&nbsp;     *
<i>700</i>&nbsp;     * @since 9
<i>701</i>&nbsp;     */
<i>702</i>&nbsp;    public final void addPostLayoutPulseListener(Runnable r) {
<b class="nc"><i>703</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<i>704</i>&nbsp;
<b class="nc"><i>705</i>&nbsp;        if (r == null) {</b>
<b class="nc"><i>706</i>&nbsp;            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);</b>
<i>707</i>&nbsp;        }
<b class="nc"><i>708</i>&nbsp;        if (postLayoutPulseListeners == null) {</b>
<b class="nc"><i>709</i>&nbsp;            postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();</b>
<i>710</i>&nbsp;        }
<b class="nc"><i>711</i>&nbsp;        postLayoutPulseListeners.add(r);</b>
<b class="nc"><i>712</i>&nbsp;    }</b>
<i>713</i>&nbsp;
<i>714</i>&nbsp;    /**
<i>715</i>&nbsp;     * Removes a previously registered scene post layout pulse listener from listening to
<i>716</i>&nbsp;     * pulses in this scene. This method does nothing if the specified Runnable is
<i>717</i>&nbsp;     * not already in the list.
<i>718</i>&nbsp;     *
<i>719</i>&nbsp;     * This method must be called on the JavaFX Application thread.
<i>720</i>&nbsp;     *
<i>721</i>&nbsp;     * @param r The Runnable that should no longer be called when the pulse
<i>722</i>&nbsp;     * occurs for this scene.
<i>723</i>&nbsp;     *
<i>724</i>&nbsp;     * @throws IllegalStateException if this method is called on a thread
<i>725</i>&nbsp;     * other than the JavaFX Application Thread.
<i>726</i>&nbsp;     *
<i>727</i>&nbsp;     * @since 9
<i>728</i>&nbsp;     */
<i>729</i>&nbsp;    public final void removePostLayoutPulseListener(Runnable r) {
<b class="nc"><i>730</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<i>731</i>&nbsp;
<b class="nc"><i>732</i>&nbsp;        if (postLayoutPulseListeners == null) {</b>
<b class="nc"><i>733</i>&nbsp;            return;</b>
<i>734</i>&nbsp;        }
<b class="nc"><i>735</i>&nbsp;        postLayoutPulseListeners.remove(r);</b>
<b class="nc"><i>736</i>&nbsp;    }</b>
<i>737</i>&nbsp;
<i>738</i>&nbsp;    /**
<i>739</i>&nbsp;     * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
<i>740</i>&nbsp;     * &lt;p&gt;
<i>741</i>&nbsp;     * Note: this is a conditional feature. See
<i>742</i>&nbsp;     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
<i>743</i>&nbsp;     * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
<i>744</i>&nbsp;     * for more information.
<i>745</i>&nbsp;     * @return the SceneAntialiasing for this scene
<i>746</i>&nbsp;     * @since JavaFX 8.0
<i>747</i>&nbsp;     */
<i>748</i>&nbsp;    public final SceneAntialiasing getAntiAliasing() {
<b class="nc"><i>749</i>&nbsp;        return antiAliasing;</b>
<i>750</i>&nbsp;    }
<i>751</i>&nbsp;
<i>752</i>&nbsp;    private boolean getAntiAliasingInternal() {
<b class="fc"><i>753</i>&nbsp;        return (antiAliasing != null &amp;&amp;</b>
<b class="fc"><i>754</i>&nbsp;                Toolkit.getToolkit().isMSAASupported() &amp;&amp;</b>
<b class="fc"><i>755</i>&nbsp;                Platform.isSupported(ConditionalFeature.SCENE3D)) ?</b>
<b class="fc"><i>756</i>&nbsp;                antiAliasing != SceneAntialiasing.DISABLED : false;</b>
<i>757</i>&nbsp;    }
<i>758</i>&nbsp;
<i>759</i>&nbsp;    /**
<i>760</i>&nbsp;     * The {@code Window} for this {@code Scene}
<i>761</i>&nbsp;     */
<i>762</i>&nbsp;    private ReadOnlyObjectWrapper&lt;Window&gt; window;
<i>763</i>&nbsp;
<i>764</i>&nbsp;    void setWindow(Window value) {
<b class="fc"><i>765</i>&nbsp;        windowPropertyImpl().set(value);</b>
<b class="fc"><i>766</i>&nbsp;    }</b>
<i>767</i>&nbsp;
<i>768</i>&nbsp;    public final Window getWindow() {
<b class="fc"><i>769</i>&nbsp;        return window == null ? null : window.get();</b>
<i>770</i>&nbsp;    }
<i>771</i>&nbsp;
<i>772</i>&nbsp;    public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
<b class="fc"><i>773</i>&nbsp;        return windowPropertyImpl().getReadOnlyProperty();</b>
<i>774</i>&nbsp;    }
<i>775</i>&nbsp;
<i>776</i>&nbsp;    private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
<b class="fc"><i>777</i>&nbsp;        if (window == null) {</b>
<b class="fc"><i>778</i>&nbsp;            window = new ReadOnlyObjectWrapper&lt;Window&gt;() {</b>
<i>779</i>&nbsp;                private Window oldWindow;
<i>780</i>&nbsp;
<i>781</i>&nbsp;                @Override protected void invalidated() {
<b class="fc"><i>782</i>&nbsp;                    final Window newWindow = get();</b>
<b class="fc"><i>783</i>&nbsp;                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);</b>
<b class="fc"><i>784</i>&nbsp;                    if (oldWindow != null) {</b>
<b class="nc"><i>785</i>&nbsp;                        disposePeer();</b>
<i>786</i>&nbsp;                    }
<b class="fc"><i>787</i>&nbsp;                    if (newWindow != null) {</b>
<b class="fc"><i>788</i>&nbsp;                        initPeer();</b>
<i>789</i>&nbsp;                    }
<b class="fc"><i>790</i>&nbsp;                    parentEffectiveOrientationInvalidated();</b>
<i>791</i>&nbsp;
<b class="fc"><i>792</i>&nbsp;                    oldWindow = newWindow;</b>
<b class="fc"><i>793</i>&nbsp;                }</b>
<i>794</i>&nbsp;
<i>795</i>&nbsp;                @Override
<i>796</i>&nbsp;                public Object getBean() {
<b class="nc"><i>797</i>&nbsp;                    return Scene.this;</b>
<i>798</i>&nbsp;                }
<i>799</i>&nbsp;
<i>800</i>&nbsp;                @Override
<i>801</i>&nbsp;                public String getName() {
<b class="nc"><i>802</i>&nbsp;                    return &quot;window&quot;;</b>
<i>803</i>&nbsp;                }
<i>804</i>&nbsp;            };
<i>805</i>&nbsp;        }
<b class="fc"><i>806</i>&nbsp;        return window;</b>
<i>807</i>&nbsp;    }
<i>808</i>&nbsp;
<i>809</i>&nbsp;    void initPeer() {
<b class="fc"><i>810</i>&nbsp;        assert peer == null;</b>
<i>811</i>&nbsp;
<b class="fc"><i>812</i>&nbsp;        Window window = getWindow();</b>
<i>813</i>&nbsp;        // initPeer() is only called from Window, either when the window
<i>814</i>&nbsp;        // is being shown, or the window scene is being changed. In any case
<i>815</i>&nbsp;        // this scene&#39;s window cannot be null.
<b class="fc"><i>816</i>&nbsp;        assert window != null;</b>
<i>817</i>&nbsp;
<b class="fc"><i>818</i>&nbsp;        TKStage windowPeer = WindowHelper.getPeer(window);</b>
<b class="fc"><i>819</i>&nbsp;        if (windowPeer == null) {</b>
<i>820</i>&nbsp;            // This is fine, the window is not visible. initPeer() will
<i>821</i>&nbsp;            // be called again later, when the window is being shown.
<b class="fc"><i>822</i>&nbsp;            return;</b>
<i>823</i>&nbsp;        }
<i>824</i>&nbsp;
<b class="fc"><i>825</i>&nbsp;        final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);</b>
<b class="fc"><i>826</i>&nbsp;        if (!isTransparentWindowsSupported) {</b>
<b class="nc"><i>827</i>&nbsp;            PlatformImpl.addNoTransparencyStylesheetToScene(this);</b>
<i>828</i>&nbsp;        }
<i>829</i>&nbsp;
<b class="fc"><i>830</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);</b>
<i>831</i>&nbsp;
<b class="fc"><i>832</i>&nbsp;        setAllowPGAccess(true);</b>
<i>833</i>&nbsp;
<b class="fc"><i>834</i>&nbsp;        Toolkit tk = Toolkit.getToolkit();</b>
<b class="fc"><i>835</i>&nbsp;        peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);</b>
<b class="fc"><i>836</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);</b>
<b class="fc"><i>837</i>&nbsp;        peer.setTKSceneListener(new ScenePeerListener());</b>
<b class="fc"><i>838</i>&nbsp;        peer.setTKScenePaintListener(new ScenePeerPaintListener());</b>
<b class="fc"><i>839</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);</b>
<b class="fc"><i>840</i>&nbsp;        peer.setRoot(getRoot().getPeer());</b>
<b class="fc"><i>841</i>&nbsp;        peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));</b>
<b class="fc"><i>842</i>&nbsp;        NodeHelper.updatePeer(getEffectiveCamera());</b>
<b class="fc"><i>843</i>&nbsp;        peer.setCamera((NGCamera) getEffectiveCamera().getPeer());</b>
<b class="fc"><i>844</i>&nbsp;        peer.markDirty();</b>
<b class="fc"><i>845</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);</b>
<i>846</i>&nbsp;
<b class="fc"><i>847</i>&nbsp;        setAllowPGAccess(false);</b>
<i>848</i>&nbsp;
<b class="fc"><i>849</i>&nbsp;        tk.addSceneTkPulseListener(scenePulseListener);</b>
<i>850</i>&nbsp;        // listen to dnd gestures coming from the platform
<i>851</i>&nbsp;        if (PLATFORM_DRAG_GESTURE_INITIATION) {
<i>852</i>&nbsp;            if (dragGestureListener == null) {
<i>853</i>&nbsp;                dragGestureListener = new DragGestureListener();
<i>854</i>&nbsp;            }
<i>855</i>&nbsp;            tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
<i>856</i>&nbsp;        }
<b class="fc"><i>857</i>&nbsp;        tk.enableDrop(peer, new DropTargetListener());</b>
<b class="fc"><i>858</i>&nbsp;        tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());</b>
<i>859</i>&nbsp;
<b class="fc"><i>860</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);</b>
<b class="fc"><i>861</i>&nbsp;    }</b>
<i>862</i>&nbsp;
<i>863</i>&nbsp;    public void disposePeer() {
<b class="fc"><i>864</i>&nbsp;        if (peer == null) {</b>
<i>865</i>&nbsp;            // This is fine, the window is either not shown yet and there is no
<i>866</i>&nbsp;            // need in disposing scene peer, or is hidden and disposePeer()
<i>867</i>&nbsp;            // has already been called.
<b class="nc"><i>868</i>&nbsp;            return;</b>
<i>869</i>&nbsp;        }
<i>870</i>&nbsp;
<b class="fc"><i>871</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);</b>
<i>872</i>&nbsp;
<b class="fc"><i>873</i>&nbsp;        Toolkit tk = Toolkit.getToolkit();</b>
<b class="fc"><i>874</i>&nbsp;        tk.removeSceneTkPulseListener(scenePulseListener);</b>
<b class="fc"><i>875</i>&nbsp;        if (accessible != null) {</b>
<b class="nc"><i>876</i>&nbsp;            disposeAccessibles();</b>
<b class="nc"><i>877</i>&nbsp;            Node root = getRoot();</b>
<b class="nc"><i>878</i>&nbsp;            if (root != null) root.releaseAccessible();</b>
<b class="nc"><i>879</i>&nbsp;            accessible.dispose();</b>
<b class="nc"><i>880</i>&nbsp;            accessible = null;</b>
<i>881</i>&nbsp;        }
<b class="fc"><i>882</i>&nbsp;        peer.dispose();</b>
<b class="fc"><i>883</i>&nbsp;        peer = null;</b>
<i>884</i>&nbsp;
<b class="fc"><i>885</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);</b>
<b class="fc"><i>886</i>&nbsp;    }</b>
<i>887</i>&nbsp;
<b class="fc"><i>888</i>&nbsp;    DnDGesture dndGesture = null;</b>
<i>889</i>&nbsp;    DragGestureListener dragGestureListener;
<i>890</i>&nbsp;    /**
<i>891</i>&nbsp;     * The horizontal location of this {@code Scene} on the {@code Window}.
<i>892</i>&nbsp;     */
<i>893</i>&nbsp;    private ReadOnlyDoubleWrapper x;
<i>894</i>&nbsp;
<i>895</i>&nbsp;    private final void setX(double value) {
<b class="fc"><i>896</i>&nbsp;        xPropertyImpl().set(value);</b>
<b class="fc"><i>897</i>&nbsp;    }</b>
<i>898</i>&nbsp;
<i>899</i>&nbsp;    public final double getX() {
<b class="fc"><i>900</i>&nbsp;        return x == null ? 0.0 : x.get();</b>
<i>901</i>&nbsp;    }
<i>902</i>&nbsp;
<i>903</i>&nbsp;    public final ReadOnlyDoubleProperty xProperty() {
<b class="nc"><i>904</i>&nbsp;        return xPropertyImpl().getReadOnlyProperty();</b>
<i>905</i>&nbsp;    }
<i>906</i>&nbsp;
<i>907</i>&nbsp;    private ReadOnlyDoubleWrapper xPropertyImpl() {
<b class="fc"><i>908</i>&nbsp;        if (x == null) {</b>
<b class="fc"><i>909</i>&nbsp;            x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);</b>
<i>910</i>&nbsp;        }
<b class="fc"><i>911</i>&nbsp;        return x;</b>
<i>912</i>&nbsp;    }
<i>913</i>&nbsp;
<i>914</i>&nbsp;    /**
<i>915</i>&nbsp;     * The vertical location of this {@code Scene} on the {@code Window}.
<i>916</i>&nbsp;     */
<i>917</i>&nbsp;    private ReadOnlyDoubleWrapper y;
<i>918</i>&nbsp;
<i>919</i>&nbsp;    private final void setY(double value) {
<b class="fc"><i>920</i>&nbsp;        yPropertyImpl().set(value);</b>
<b class="fc"><i>921</i>&nbsp;    }</b>
<i>922</i>&nbsp;
<i>923</i>&nbsp;    public final double getY() {
<b class="fc"><i>924</i>&nbsp;        return y == null ? 0.0 : y.get();</b>
<i>925</i>&nbsp;    }
<i>926</i>&nbsp;
<i>927</i>&nbsp;    public final ReadOnlyDoubleProperty yProperty() {
<b class="nc"><i>928</i>&nbsp;        return yPropertyImpl().getReadOnlyProperty();</b>
<i>929</i>&nbsp;    }
<i>930</i>&nbsp;
<i>931</i>&nbsp;    private ReadOnlyDoubleWrapper yPropertyImpl() {
<b class="fc"><i>932</i>&nbsp;        if (y == null) {</b>
<b class="fc"><i>933</i>&nbsp;            y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);</b>
<i>934</i>&nbsp;        }
<b class="fc"><i>935</i>&nbsp;        return y;</b>
<i>936</i>&nbsp;    }
<i>937</i>&nbsp;
<i>938</i>&nbsp;    /**
<i>939</i>&nbsp;     * The width of this {@code Scene}
<i>940</i>&nbsp;     */
<i>941</i>&nbsp;    private ReadOnlyDoubleWrapper width;
<i>942</i>&nbsp;
<i>943</i>&nbsp;    private final void setWidth(double value) {
<b class="fc"><i>944</i>&nbsp;        widthPropertyImpl().set(value);</b>
<b class="fc"><i>945</i>&nbsp;    }</b>
<i>946</i>&nbsp;
<i>947</i>&nbsp;    public final double getWidth() {
<b class="fc"><i>948</i>&nbsp;        return width == null ? 0.0 : width.get();</b>
<i>949</i>&nbsp;    }
<i>950</i>&nbsp;
<i>951</i>&nbsp;    public final ReadOnlyDoubleProperty widthProperty() {
<b class="nc"><i>952</i>&nbsp;        return widthPropertyImpl().getReadOnlyProperty();</b>
<i>953</i>&nbsp;    }
<i>954</i>&nbsp;
<i>955</i>&nbsp;    private ReadOnlyDoubleWrapper widthPropertyImpl() {
<b class="fc"><i>956</i>&nbsp;        if (width == null) {</b>
<b class="fc"><i>957</i>&nbsp;            width = new ReadOnlyDoubleWrapper() {</b>
<i>958</i>&nbsp;
<i>959</i>&nbsp;                @Override
<i>960</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>961</i>&nbsp;                    final Parent _root = getRoot();</b>
<i>962</i>&nbsp;                    //TODO - use a better method to update mirroring
<b class="fc"><i>963</i>&nbsp;                    if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {</b>
<b class="nc"><i>964</i>&nbsp;                        NodeHelper.transformsChanged(_root);</b>
<i>965</i>&nbsp;                    }
<b class="fc"><i>966</i>&nbsp;                    if (_root.isResizable()) {</b>
<b class="fc"><i>967</i>&nbsp;                        resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());</b>
<i>968</i>&nbsp;                    }
<i>969</i>&nbsp;
<b class="fc"><i>970</i>&nbsp;                    getEffectiveCamera().setViewWidth(get());</b>
<b class="fc"><i>971</i>&nbsp;                }</b>
<i>972</i>&nbsp;
<i>973</i>&nbsp;                @Override
<i>974</i>&nbsp;                public Object getBean() {
<b class="nc"><i>975</i>&nbsp;                    return Scene.this;</b>
<i>976</i>&nbsp;                }
<i>977</i>&nbsp;
<i>978</i>&nbsp;                @Override
<i>979</i>&nbsp;                public String getName() {
<b class="nc"><i>980</i>&nbsp;                    return &quot;width&quot;;</b>
<i>981</i>&nbsp;                }
<i>982</i>&nbsp;            };
<i>983</i>&nbsp;        }
<b class="fc"><i>984</i>&nbsp;        return width;</b>
<i>985</i>&nbsp;    }
<i>986</i>&nbsp;
<i>987</i>&nbsp;    /**
<i>988</i>&nbsp;     * The height of this {@code Scene}
<i>989</i>&nbsp;     */
<i>990</i>&nbsp;    private ReadOnlyDoubleWrapper height;
<i>991</i>&nbsp;
<i>992</i>&nbsp;    private final void setHeight(double value) {
<b class="fc"><i>993</i>&nbsp;        heightPropertyImpl().set(value);</b>
<b class="fc"><i>994</i>&nbsp;    }</b>
<i>995</i>&nbsp;
<i>996</i>&nbsp;    public final double getHeight() {
<b class="fc"><i>997</i>&nbsp;        return height == null ? 0.0 : height.get();</b>
<i>998</i>&nbsp;    }
<i>999</i>&nbsp;
<i>1000</i>&nbsp;    public final ReadOnlyDoubleProperty heightProperty() {
<b class="nc"><i>1001</i>&nbsp;        return heightPropertyImpl().getReadOnlyProperty();</b>
<i>1002</i>&nbsp;    }
<i>1003</i>&nbsp;
<i>1004</i>&nbsp;    private ReadOnlyDoubleWrapper heightPropertyImpl() {
<b class="fc"><i>1005</i>&nbsp;        if (height == null) {</b>
<b class="fc"><i>1006</i>&nbsp;            height = new ReadOnlyDoubleWrapper() {</b>
<i>1007</i>&nbsp;
<i>1008</i>&nbsp;                @Override
<i>1009</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>1010</i>&nbsp;                    final Parent _root = getRoot();</b>
<b class="fc"><i>1011</i>&nbsp;                    if (_root.isResizable()) {</b>
<b class="fc"><i>1012</i>&nbsp;                        resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());</b>
<i>1013</i>&nbsp;                    }
<i>1014</i>&nbsp;
<b class="fc"><i>1015</i>&nbsp;                    getEffectiveCamera().setViewHeight(get());</b>
<b class="fc"><i>1016</i>&nbsp;                }</b>
<i>1017</i>&nbsp;
<i>1018</i>&nbsp;                @Override
<i>1019</i>&nbsp;                public Object getBean() {
<b class="nc"><i>1020</i>&nbsp;                    return Scene.this;</b>
<i>1021</i>&nbsp;                }
<i>1022</i>&nbsp;
<i>1023</i>&nbsp;                @Override
<i>1024</i>&nbsp;                public String getName() {
<b class="nc"><i>1025</i>&nbsp;                    return &quot;height&quot;;</b>
<i>1026</i>&nbsp;                }
<i>1027</i>&nbsp;            };
<i>1028</i>&nbsp;        }
<b class="fc"><i>1029</i>&nbsp;        return height;</b>
<i>1030</i>&nbsp;    }
<i>1031</i>&nbsp;
<i>1032</i>&nbsp;    void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
<b class="fc"><i>1033</i>&nbsp;        getRoot().resize(newWidth, newHeight);</b>
<b class="fc"><i>1034</i>&nbsp;    }</b>
<i>1035</i>&nbsp;
<i>1036</i>&nbsp;    // Reusable target wrapper (to avoid creating new one for each picking)
<b class="fc"><i>1037</i>&nbsp;    private TargetWrapper tmpTargetWrapper = new TargetWrapper();</b>
<i>1038</i>&nbsp;
<i>1039</i>&nbsp;    /**
<i>1040</i>&nbsp;     * Specifies the type of camera use for rendering this {@code Scene}.
<i>1041</i>&nbsp;     * If {@code camera} is null, a parallel camera is used for rendering.
<i>1042</i>&nbsp;     * It is illegal to set a camera that belongs to other {@code Scene}
<i>1043</i>&nbsp;     * or {@code SubScene}.
<i>1044</i>&nbsp;     * &lt;p&gt;
<i>1045</i>&nbsp;     * Note: this is a conditional feature. See
<i>1046</i>&nbsp;     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
<i>1047</i>&nbsp;     * for more information.
<i>1048</i>&nbsp;     *
<i>1049</i>&nbsp;     * @defaultValue null
<i>1050</i>&nbsp;     */
<i>1051</i>&nbsp;    private ObjectProperty&lt;Camera&gt; camera;
<i>1052</i>&nbsp;
<i>1053</i>&nbsp;    public final void setCamera(Camera value) {
<b class="nc"><i>1054</i>&nbsp;        cameraProperty().set(value);</b>
<b class="nc"><i>1055</i>&nbsp;    }</b>
<i>1056</i>&nbsp;
<i>1057</i>&nbsp;    public final Camera getCamera() {
<b class="fc"><i>1058</i>&nbsp;        return camera == null ? null : camera.get();</b>
<i>1059</i>&nbsp;    }
<i>1060</i>&nbsp;
<i>1061</i>&nbsp;    public final ObjectProperty&lt;Camera&gt; cameraProperty() {
<b class="nc"><i>1062</i>&nbsp;        if (camera == null) {</b>
<b class="nc"><i>1063</i>&nbsp;            camera = new ObjectPropertyBase&lt;Camera&gt;() {</b>
<b class="nc"><i>1064</i>&nbsp;                Camera oldCamera = null;</b>
<i>1065</i>&nbsp;
<i>1066</i>&nbsp;                @Override
<i>1067</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>1068</i>&nbsp;                    Camera _value = get();</b>
<b class="nc"><i>1069</i>&nbsp;                    if (_value != null) {</b>
<b class="nc"><i>1070</i>&nbsp;                        if (_value instanceof PerspectiveCamera</b>
<b class="nc"><i>1071</i>&nbsp;                                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {</b>
<b class="nc"><i>1072</i>&nbsp;                            String logname = Scene.class.getName();</b>
<b class="nc"><i>1073</i>&nbsp;                            PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;</b>
<i>1074</i>&nbsp;                                    + &quot;ConditionalFeature.SCENE3D&quot;);
<i>1075</i>&nbsp;                        }
<i>1076</i>&nbsp;                        // Illegal value if it belongs to other scene or any subscene
<b class="nc"><i>1077</i>&nbsp;                        if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)</b>
<b class="nc"><i>1078</i>&nbsp;                                || _value.getSubScene() != null) {</b>
<b class="nc"><i>1079</i>&nbsp;                            throw new IllegalArgumentException(_value</b>
<i>1080</i>&nbsp;                                    + &quot;is already part of other scene or subscene&quot;);
<i>1081</i>&nbsp;                        }
<i>1082</i>&nbsp;                        // throws exception if the camera already has a different owner
<b class="nc"><i>1083</i>&nbsp;                        _value.setOwnerScene(Scene.this);</b>
<b class="nc"><i>1084</i>&nbsp;                        _value.setViewWidth(getWidth());</b>
<b class="nc"><i>1085</i>&nbsp;                        _value.setViewHeight(getHeight());</b>
<i>1086</i>&nbsp;                    }
<b class="nc"><i>1087</i>&nbsp;                    if (oldCamera != null &amp;&amp; oldCamera != _value) {</b>
<b class="nc"><i>1088</i>&nbsp;                        oldCamera.setOwnerScene(null);</b>
<i>1089</i>&nbsp;                    }
<b class="nc"><i>1090</i>&nbsp;                    oldCamera = _value;</b>
<b class="nc"><i>1091</i>&nbsp;                }</b>
<i>1092</i>&nbsp;
<i>1093</i>&nbsp;                @Override
<i>1094</i>&nbsp;                public Object getBean() {
<b class="nc"><i>1095</i>&nbsp;                    return Scene.this;</b>
<i>1096</i>&nbsp;                }
<i>1097</i>&nbsp;
<i>1098</i>&nbsp;                @Override
<i>1099</i>&nbsp;                public String getName() {
<b class="nc"><i>1100</i>&nbsp;                    return &quot;camera&quot;;</b>
<i>1101</i>&nbsp;                }
<i>1102</i>&nbsp;            };
<i>1103</i>&nbsp;        }
<b class="nc"><i>1104</i>&nbsp;        return camera;</b>
<i>1105</i>&nbsp;    }
<i>1106</i>&nbsp;
<i>1107</i>&nbsp;    Camera getEffectiveCamera() {
<b class="fc"><i>1108</i>&nbsp;        final Camera cam = getCamera();</b>
<b class="fc"><i>1109</i>&nbsp;        if (cam == null</b>
<i>1110</i>&nbsp;                || (cam instanceof PerspectiveCamera
<b class="nc"><i>1111</i>&nbsp;                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {</b>
<b class="fc"><i>1112</i>&nbsp;            if (defaultCamera == null) {</b>
<b class="fc"><i>1113</i>&nbsp;                defaultCamera = new ParallelCamera();</b>
<b class="fc"><i>1114</i>&nbsp;                defaultCamera.setOwnerScene(this);</b>
<b class="fc"><i>1115</i>&nbsp;                defaultCamera.setViewWidth(getWidth());</b>
<b class="fc"><i>1116</i>&nbsp;                defaultCamera.setViewHeight(getHeight());</b>
<i>1117</i>&nbsp;            }
<b class="fc"><i>1118</i>&nbsp;            return defaultCamera;</b>
<i>1119</i>&nbsp;        }
<i>1120</i>&nbsp;
<b class="nc"><i>1121</i>&nbsp;        return cam;</b>
<i>1122</i>&nbsp;    }
<i>1123</i>&nbsp;
<i>1124</i>&nbsp;    // Used by the camera
<i>1125</i>&nbsp;    void markCameraDirty() {
<b class="fc"><i>1126</i>&nbsp;        markDirty(DirtyBits.CAMERA_DIRTY);</b>
<b class="fc"><i>1127</i>&nbsp;        setNeedsRepaint();</b>
<b class="fc"><i>1128</i>&nbsp;    }</b>
<i>1129</i>&nbsp;
<i>1130</i>&nbsp;    void markCursorDirty() {
<b class="fc"><i>1131</i>&nbsp;        markDirty(DirtyBits.CURSOR_DIRTY);</b>
<b class="fc"><i>1132</i>&nbsp;    }</b>
<i>1133</i>&nbsp;
<i>1134</i>&nbsp;    /**
<i>1135</i>&nbsp;     * Defines the background fill of this {@code Scene}. Both a {@code null}
<i>1136</i>&nbsp;     * value meaning &#39;paint no background&#39; and a {@link javafx.scene.paint.Paint}
<i>1137</i>&nbsp;     * with transparency are supported. The default fill of the Scene is
<i>1138</i>&nbsp;     * {@link Color#WHITE}, but it is more commonly the case that the initial
<i>1139</i>&nbsp;     * color shown to users is the background fill of the
<i>1140</i>&nbsp;     * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
<i>1141</i>&nbsp;     * stretched to take up all available space in the {@code Scene}. The
<i>1142</i>&nbsp;     * root node of the {@code Scene} is given the CSS style class &#39;root&#39;, and
<i>1143</i>&nbsp;     * the default user agent stylesheets that ship with JavaFX (presently
<i>1144</i>&nbsp;     * Caspian and Modena) apply styling on to this root style class. In the
<i>1145</i>&nbsp;     * case of Caspian this does not impact the background fill color of the
<i>1146</i>&nbsp;     * root node, but in the case of Modena the default fill is set to be a
<i>1147</i>&nbsp;     * light gray color.
<i>1148</i>&nbsp;     *
<i>1149</i>&nbsp;     * @defaultValue WHITE
<i>1150</i>&nbsp;     */
<i>1151</i>&nbsp;    private ObjectProperty&lt;Paint&gt; fill;
<i>1152</i>&nbsp;
<i>1153</i>&nbsp;    public final void setFill(Paint value) {
<b class="fc"><i>1154</i>&nbsp;        fillProperty().set(value);</b>
<b class="fc"><i>1155</i>&nbsp;    }</b>
<i>1156</i>&nbsp;
<i>1157</i>&nbsp;    public final Paint getFill() {
<b class="fc"><i>1158</i>&nbsp;        return fill == null ? Color.WHITE : fill.get();</b>
<i>1159</i>&nbsp;    }
<i>1160</i>&nbsp;
<i>1161</i>&nbsp;    public final ObjectProperty&lt;Paint&gt; fillProperty() {
<b class="fc"><i>1162</i>&nbsp;        if (fill == null) {</b>
<b class="fc"><i>1163</i>&nbsp;            fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {</b>
<i>1164</i>&nbsp;
<i>1165</i>&nbsp;                @Override
<i>1166</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>1167</i>&nbsp;                    markDirty(DirtyBits.FILL_DIRTY);</b>
<b class="fc"><i>1168</i>&nbsp;                }</b>
<i>1169</i>&nbsp;
<i>1170</i>&nbsp;                @Override
<i>1171</i>&nbsp;                public Object getBean() {
<b class="nc"><i>1172</i>&nbsp;                    return Scene.this;</b>
<i>1173</i>&nbsp;                }
<i>1174</i>&nbsp;
<i>1175</i>&nbsp;                @Override
<i>1176</i>&nbsp;                public String getName() {
<b class="nc"><i>1177</i>&nbsp;                    return &quot;fill&quot;;</b>
<i>1178</i>&nbsp;                }
<i>1179</i>&nbsp;            };
<i>1180</i>&nbsp;        }
<b class="fc"><i>1181</i>&nbsp;        return fill;</b>
<i>1182</i>&nbsp;    }
<i>1183</i>&nbsp;
<i>1184</i>&nbsp;    /**
<i>1185</i>&nbsp;     * Defines the root {@code Node} of the scene graph.
<i>1186</i>&nbsp;     * If a {@code Group} is used as the root, the
<i>1187</i>&nbsp;     * contents of the scene graph will be clipped by the scene&#39;s width and height and
<i>1188</i>&nbsp;     * changes to the scene&#39;s size (if user resizes the stage) will not alter the
<i>1189</i>&nbsp;     * layout of the scene graph.    If a resizable node (layout {@code Region} or
<i>1190</i>&nbsp;     * {@code Control}) is set as the root, then the root&#39;s size will track the
<i>1191</i>&nbsp;     * scene&#39;s size, causing the contents to be relayed out as necessary.
<i>1192</i>&nbsp;     *
<i>1193</i>&nbsp;     * Scene doesn&#39;t accept null root.
<i>1194</i>&nbsp;     *
<i>1195</i>&nbsp;     */
<i>1196</i>&nbsp;    private ObjectProperty&lt;Parent&gt; root;
<i>1197</i>&nbsp;
<i>1198</i>&nbsp;    public final void setRoot(Parent value) {
<b class="fc"><i>1199</i>&nbsp;        rootProperty().set(value);</b>
<b class="fc"><i>1200</i>&nbsp;    }</b>
<i>1201</i>&nbsp;
<i>1202</i>&nbsp;    public final Parent getRoot() {
<b class="fc"><i>1203</i>&nbsp;        return root == null ? null : root.get();</b>
<i>1204</i>&nbsp;    }
<i>1205</i>&nbsp;
<i>1206</i>&nbsp;    Parent oldRoot;
<i>1207</i>&nbsp;    public final ObjectProperty&lt;Parent&gt; rootProperty() {
<b class="fc"><i>1208</i>&nbsp;        if (root == null) {</b>
<b class="fc"><i>1209</i>&nbsp;            root = new ObjectPropertyBase&lt;Parent&gt;() {</b>
<i>1210</i>&nbsp;
<i>1211</i>&nbsp;                private void forceUnbind() {
<b class="nc"><i>1212</i>&nbsp;                    System.err.println(&quot;Unbinding illegal root.&quot;);</b>
<b class="nc"><i>1213</i>&nbsp;                    unbind();</b>
<b class="nc"><i>1214</i>&nbsp;                }</b>
<i>1215</i>&nbsp;
<i>1216</i>&nbsp;                @Override
<i>1217</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>1218</i>&nbsp;                    Parent _value = get();</b>
<i>1219</i>&nbsp;
<b class="fc"><i>1220</i>&nbsp;                    if (_value == null) {</b>
<b class="nc"><i>1221</i>&nbsp;                        if (isBound()) forceUnbind();</b>
<b class="nc"><i>1222</i>&nbsp;                        throw new NullPointerException(&quot;Scene&#39;s root cannot be null&quot;);</b>
<i>1223</i>&nbsp;                    }
<i>1224</i>&nbsp;
<b class="fc"><i>1225</i>&nbsp;                    if (_value.getParent() != null) {</b>
<b class="nc"><i>1226</i>&nbsp;                        if (isBound()) forceUnbind();</b>
<b class="nc"><i>1227</i>&nbsp;                        throw new IllegalArgumentException(_value +</b>
<i>1228</i>&nbsp;                                &quot;is already inside a scene-graph and cannot be set as root&quot;);
<i>1229</i>&nbsp;                    }
<b class="fc"><i>1230</i>&nbsp;                    if (_value.getClipParent() != null) {</b>
<b class="nc"><i>1231</i>&nbsp;                        if (isBound()) forceUnbind();</b>
<b class="nc"><i>1232</i>&nbsp;                        throw new IllegalArgumentException(_value +</b>
<i>1233</i>&nbsp;                                &quot;is set as a clip on another node, so cannot be set as root&quot;);
<i>1234</i>&nbsp;                    }
<b class="fc"><i>1235</i>&nbsp;                    if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {</b>
<b class="nc"><i>1236</i>&nbsp;                        if (isBound()) forceUnbind();</b>
<b class="nc"><i>1237</i>&nbsp;                        throw new IllegalArgumentException(_value +</b>
<i>1238</i>&nbsp;                                &quot;is already set as root of another scene&quot;);
<i>1239</i>&nbsp;                    }
<i>1240</i>&nbsp;
<b class="fc"><i>1241</i>&nbsp;                    if (oldRoot != null) {</b>
<b class="nc"><i>1242</i>&nbsp;                        oldRoot.setScenes(null, null, /* reapplyCSS*/ false);</b>
<i>1243</i>&nbsp;                    }
<b class="fc"><i>1244</i>&nbsp;                    oldRoot = _value;</b>
<b class="fc"><i>1245</i>&nbsp;                    _value.getStyleClass().add(0, &quot;root&quot;);</b>
<b class="fc"><i>1246</i>&nbsp;                    _value.setScenes(Scene.this, null, /* reapplyCSS*/ true);</b>
<b class="fc"><i>1247</i>&nbsp;                    markDirty(DirtyBits.ROOT_DIRTY);</b>
<b class="fc"><i>1248</i>&nbsp;                    _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable</b>
<b class="fc"><i>1249</i>&nbsp;                    _value.requestLayout();</b>
<b class="fc"><i>1250</i>&nbsp;                }</b>
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;                @Override
<i>1253</i>&nbsp;                public Object getBean() {
<b class="nc"><i>1254</i>&nbsp;                    return Scene.this;</b>
<i>1255</i>&nbsp;                }
<i>1256</i>&nbsp;
<i>1257</i>&nbsp;                @Override
<i>1258</i>&nbsp;                public String getName() {
<b class="nc"><i>1259</i>&nbsp;                    return &quot;root&quot;;</b>
<i>1260</i>&nbsp;                }
<i>1261</i>&nbsp;            };
<i>1262</i>&nbsp;        }
<b class="fc"><i>1263</i>&nbsp;        return root;</b>
<i>1264</i>&nbsp;    }
<i>1265</i>&nbsp;
<i>1266</i>&nbsp;    void setNeedsRepaint() {
<b class="fc"><i>1267</i>&nbsp;        if (this.peer != null) {</b>
<b class="fc"><i>1268</i>&nbsp;            peer.entireSceneNeedsRepaint();</b>
<i>1269</i>&nbsp;        }
<b class="fc"><i>1270</i>&nbsp;    }</b>
<i>1271</i>&nbsp;
<i>1272</i>&nbsp;    // Process CSS and layout and sync the scene prior to the snapshot
<i>1273</i>&nbsp;    // operation of the given node for this scene (currently the node
<i>1274</i>&nbsp;    // is unused but could possibly be used in the future to optimize this)
<i>1275</i>&nbsp;    void doCSSLayoutSyncForSnapshot(Node node) {
<b class="nc"><i>1276</i>&nbsp;        if (!sizeInitialized) {</b>
<b class="nc"><i>1277</i>&nbsp;            preferredSize();</b>
<i>1278</i>&nbsp;        } else {
<b class="nc"><i>1279</i>&nbsp;            doCSSPass();</b>
<i>1280</i>&nbsp;        }
<i>1281</i>&nbsp;
<i>1282</i>&nbsp;        // we do not need pulse in the snapshot code
<i>1283</i>&nbsp;        // because this scene can be stage-less
<b class="nc"><i>1284</i>&nbsp;        doLayoutPass();</b>
<i>1285</i>&nbsp;
<b class="nc"><i>1286</i>&nbsp;        if (!paused) {</b>
<b class="nc"><i>1287</i>&nbsp;            getRoot().updateBounds();</b>
<b class="nc"><i>1288</i>&nbsp;            if (peer != null) {</b>
<b class="nc"><i>1289</i>&nbsp;                peer.waitForRenderingToComplete();</b>
<b class="nc"><i>1290</i>&nbsp;                peer.waitForSynchronization();</b>
<i>1291</i>&nbsp;                try {
<i>1292</i>&nbsp;                    // Run the synchronizer while holding the render lock
<b class="nc"><i>1293</i>&nbsp;                    scenePulseListener.synchronizeSceneNodes();</b>
<i>1294</i>&nbsp;                } finally {
<b class="nc"><i>1295</i>&nbsp;                    peer.releaseSynchronization(false);</b>
<b class="nc"><i>1296</i>&nbsp;                }</b>
<i>1297</i>&nbsp;            } else {
<b class="nc"><i>1298</i>&nbsp;                scenePulseListener.synchronizeSceneNodes();</b>
<i>1299</i>&nbsp;            }
<i>1300</i>&nbsp;        }
<i>1301</i>&nbsp;
<b class="nc"><i>1302</i>&nbsp;    }</b>
<i>1303</i>&nbsp;
<i>1304</i>&nbsp;    // Shared method for Scene.snapshot and Node.snapshot. It is static because
<i>1305</i>&nbsp;    // we might be doing a Node snapshot with a null scene
<i>1306</i>&nbsp;    static WritableImage doSnapshot(Scene scene,
<i>1307</i>&nbsp;            double x, double y, double w, double h,
<i>1308</i>&nbsp;            Node root, BaseTransform transform, boolean depthBuffer,
<i>1309</i>&nbsp;            Paint fill, Camera camera, WritableImage wimg) {
<i>1310</i>&nbsp;
<b class="nc"><i>1311</i>&nbsp;        Toolkit tk = Toolkit.getToolkit();</b>
<b class="nc"><i>1312</i>&nbsp;        Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</b>
<i>1313</i>&nbsp;
<b class="nc"><i>1314</i>&nbsp;        int xMin = (int)Math.floor(x);</b>
<b class="nc"><i>1315</i>&nbsp;        int yMin = (int)Math.floor(y);</b>
<b class="nc"><i>1316</i>&nbsp;        int xMax = (int)Math.ceil(x + w);</b>
<b class="nc"><i>1317</i>&nbsp;        int yMax = (int)Math.ceil(y + h);</b>
<b class="nc"><i>1318</i>&nbsp;        int width = Math.max(xMax - xMin, 1);</b>
<b class="nc"><i>1319</i>&nbsp;        int height = Math.max(yMax - yMin, 1);</b>
<b class="nc"><i>1320</i>&nbsp;        if (wimg == null) {</b>
<b class="nc"><i>1321</i>&nbsp;            wimg = new WritableImage(width, height);</b>
<i>1322</i>&nbsp;        } else {
<b class="nc"><i>1323</i>&nbsp;            width = (int)wimg.getWidth();</b>
<b class="nc"><i>1324</i>&nbsp;            height = (int)wimg.getHeight();</b>
<i>1325</i>&nbsp;        }
<i>1326</i>&nbsp;
<b class="nc"><i>1327</i>&nbsp;        setAllowPGAccess(true);</b>
<b class="nc"><i>1328</i>&nbsp;        context.x = xMin;</b>
<b class="nc"><i>1329</i>&nbsp;        context.y = yMin;</b>
<b class="nc"><i>1330</i>&nbsp;        context.width = width;</b>
<b class="nc"><i>1331</i>&nbsp;        context.height = height;</b>
<b class="nc"><i>1332</i>&nbsp;        context.transform = transform;</b>
<b class="nc"><i>1333</i>&nbsp;        context.depthBuffer = depthBuffer;</b>
<b class="nc"><i>1334</i>&nbsp;        context.root = root.getPeer();</b>
<b class="nc"><i>1335</i>&nbsp;        context.platformPaint = fill == null ? null : tk.getPaint(fill);</b>
<b class="nc"><i>1336</i>&nbsp;        double cameraViewWidth = 1.0;</b>
<b class="nc"><i>1337</i>&nbsp;        double cameraViewHeight = 1.0;</b>
<b class="nc"><i>1338</i>&nbsp;        if (camera != null) {</b>
<i>1339</i>&nbsp;            // temporarily adjust camera viewport to the snapshot size
<b class="nc"><i>1340</i>&nbsp;            cameraViewWidth = camera.getViewWidth();</b>
<b class="nc"><i>1341</i>&nbsp;            cameraViewHeight = camera.getViewHeight();</b>
<b class="nc"><i>1342</i>&nbsp;            camera.setViewWidth(width);</b>
<b class="nc"><i>1343</i>&nbsp;            camera.setViewHeight(height);</b>
<b class="nc"><i>1344</i>&nbsp;            NodeHelper.updatePeer(camera);</b>
<b class="nc"><i>1345</i>&nbsp;            context.camera = camera.getPeer();</b>
<i>1346</i>&nbsp;        } else {
<b class="nc"><i>1347</i>&nbsp;            context.camera = null;</b>
<i>1348</i>&nbsp;        }
<i>1349</i>&nbsp;
<i>1350</i>&nbsp;        // Grab the lights from the scene
<b class="nc"><i>1351</i>&nbsp;        context.lights = null;</b>
<b class="nc"><i>1352</i>&nbsp;        if (scene != null &amp;&amp; !scene.lights.isEmpty()) {</b>
<b class="nc"><i>1353</i>&nbsp;            context.lights = new NGLightBase[scene.lights.size()];</b>
<b class="nc"><i>1354</i>&nbsp;            for (int i = 0; i &lt; scene.lights.size(); i++) {</b>
<b class="nc"><i>1355</i>&nbsp;                context.lights[i] = scene.lights.get(i).getPeer();</b>
<i>1356</i>&nbsp;            }
<i>1357</i>&nbsp;        }
<i>1358</i>&nbsp;
<b class="nc"><i>1359</i>&nbsp;        Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();</b>
<b class="nc"><i>1360</i>&nbsp;        context.platformImage = accessor.getTkImageLoader(wimg);</b>
<b class="nc"><i>1361</i>&nbsp;        setAllowPGAccess(false);</b>
<b class="nc"><i>1362</i>&nbsp;        Object tkImage = tk.renderToImage(context);</b>
<b class="nc"><i>1363</i>&nbsp;        accessor.loadTkImage(wimg, tkImage);</b>
<i>1364</i>&nbsp;
<b class="nc"><i>1365</i>&nbsp;        if (camera != null) {</b>
<b class="nc"><i>1366</i>&nbsp;            setAllowPGAccess(true);</b>
<b class="nc"><i>1367</i>&nbsp;            camera.setViewWidth(cameraViewWidth);</b>
<b class="nc"><i>1368</i>&nbsp;            camera.setViewHeight(cameraViewHeight);</b>
<b class="nc"><i>1369</i>&nbsp;            NodeHelper.updatePeer(camera);</b>
<b class="nc"><i>1370</i>&nbsp;            setAllowPGAccess(false);</b>
<i>1371</i>&nbsp;        }
<i>1372</i>&nbsp;
<i>1373</i>&nbsp;        // if this scene belongs to some stage
<i>1374</i>&nbsp;        // we need to mark the entire scene as dirty
<i>1375</i>&nbsp;        // because dirty logic is buggy
<b class="nc"><i>1376</i>&nbsp;        if (scene != null &amp;&amp; scene.peer != null) {</b>
<b class="nc"><i>1377</i>&nbsp;            scene.setNeedsRepaint();</b>
<i>1378</i>&nbsp;        }
<i>1379</i>&nbsp;
<b class="nc"><i>1380</i>&nbsp;        return wimg;</b>
<i>1381</i>&nbsp;    }
<i>1382</i>&nbsp;
<i>1383</i>&nbsp;    /**
<i>1384</i>&nbsp;     * Implementation method for snapshot
<i>1385</i>&nbsp;     */
<i>1386</i>&nbsp;    private WritableImage doSnapshot(WritableImage img) {
<i>1387</i>&nbsp;        // TODO: no need to do CSS, layout or sync in the deferred case,
<i>1388</i>&nbsp;        // if this scene is attached to a visible stage
<b class="nc"><i>1389</i>&nbsp;        doCSSLayoutSyncForSnapshot(getRoot());</b>
<i>1390</i>&nbsp;
<b class="nc"><i>1391</i>&nbsp;        double w = getWidth();</b>
<b class="nc"><i>1392</i>&nbsp;        double h = getHeight();</b>
<b class="nc"><i>1393</i>&nbsp;        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;</b>
<i>1394</i>&nbsp;
<b class="nc"><i>1395</i>&nbsp;        return doSnapshot(this, 0, 0, w, h,</b>
<b class="nc"><i>1396</i>&nbsp;                getRoot(), transform, isDepthBufferInternal(),</b>
<b class="nc"><i>1397</i>&nbsp;                getFill(), getEffectiveCamera(), img);</b>
<i>1398</i>&nbsp;    }
<i>1399</i>&nbsp;
<i>1400</i>&nbsp;    // Pulse listener used to run all deferred (async) snapshot requests
<b class="fc"><i>1401</i>&nbsp;    private static TKPulseListener snapshotPulseListener = null;</b>
<i>1402</i>&nbsp;
<i>1403</i>&nbsp;    private static List&lt;Runnable&gt; snapshotRunnableListA;
<i>1404</i>&nbsp;    private static List&lt;Runnable&gt; snapshotRunnableListB;
<i>1405</i>&nbsp;    private static List&lt;Runnable&gt; snapshotRunnableList;
<i>1406</i>&nbsp;
<i>1407</i>&nbsp;    static void addSnapshotRunnable(final Runnable runnable) {
<b class="nc"><i>1408</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<i>1409</i>&nbsp;
<b class="nc"><i>1410</i>&nbsp;        if (snapshotPulseListener == null) {</b>
<b class="nc"><i>1411</i>&nbsp;            snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();</b>
<b class="nc"><i>1412</i>&nbsp;            snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();</b>
<b class="nc"><i>1413</i>&nbsp;            snapshotRunnableList = snapshotRunnableListA;</b>
<i>1414</i>&nbsp;
<b class="nc"><i>1415</i>&nbsp;            snapshotPulseListener = () -&gt; {</b>
<b class="nc"><i>1416</i>&nbsp;                if (snapshotRunnableList.size() &gt; 0) {</b>
<b class="nc"><i>1417</i>&nbsp;                    List&lt;Runnable&gt; runnables = snapshotRunnableList;</b>
<b class="nc"><i>1418</i>&nbsp;                    if (snapshotRunnableList == snapshotRunnableListA) {</b>
<b class="nc"><i>1419</i>&nbsp;                        snapshotRunnableList = snapshotRunnableListB;</b>
<i>1420</i>&nbsp;                    } else {
<b class="nc"><i>1421</i>&nbsp;                        snapshotRunnableList = snapshotRunnableListA;</b>
<i>1422</i>&nbsp;                    }
<b class="nc"><i>1423</i>&nbsp;                    for (Runnable r : runnables) {</b>
<i>1424</i>&nbsp;                        try {
<b class="nc"><i>1425</i>&nbsp;                            r.run();</b>
<b class="nc"><i>1426</i>&nbsp;                        } catch (Throwable th) {</b>
<b class="nc"><i>1427</i>&nbsp;                            System.err.println(&quot;Exception in snapshot runnable&quot;);</b>
<b class="nc"><i>1428</i>&nbsp;                            th.printStackTrace(System.err);</b>
<b class="nc"><i>1429</i>&nbsp;                        }</b>
<b class="nc"><i>1430</i>&nbsp;                    }</b>
<b class="nc"><i>1431</i>&nbsp;                    runnables.clear();</b>
<i>1432</i>&nbsp;                }
<b class="nc"><i>1433</i>&nbsp;            };</b>
<i>1434</i>&nbsp;
<i>1435</i>&nbsp;            // Add listener that will be called after all of the scenes have
<i>1436</i>&nbsp;            // had layout and CSS processing, and have been synced
<b class="nc"><i>1437</i>&nbsp;            Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);</b>
<i>1438</i>&nbsp;        }
<i>1439</i>&nbsp;
<b class="nc"><i>1440</i>&nbsp;        final AccessControlContext acc = AccessController.getContext();</b>
<b class="nc"><i>1441</i>&nbsp;        snapshotRunnableList.add(() -&gt; {</b>
<b class="nc"><i>1442</i>&nbsp;            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {</b>
<b class="nc"><i>1443</i>&nbsp;                runnable.run();</b>
<b class="nc"><i>1444</i>&nbsp;                return null;</b>
<i>1445</i>&nbsp;            }, acc);
<b class="nc"><i>1446</i>&nbsp;        });</b>
<b class="nc"><i>1447</i>&nbsp;        Toolkit.getToolkit().requestNextPulse();</b>
<b class="nc"><i>1448</i>&nbsp;    }</b>
<i>1449</i>&nbsp;
<i>1450</i>&nbsp;    /**
<i>1451</i>&nbsp;     * Takes a snapshot of this scene and returns the rendered image when
<i>1452</i>&nbsp;     * it is ready.
<i>1453</i>&nbsp;     * CSS and layout processing will be done for the scene prior to
<i>1454</i>&nbsp;     * rendering it.
<i>1455</i>&nbsp;     * The entire destination image is cleared using the fill {@code Paint}
<i>1456</i>&nbsp;     * of this scene. The nodes in the scene are then rendered to the image.
<i>1457</i>&nbsp;     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
<i>1458</i>&nbsp;     * If the image is smaller than the size of the scene, then the rendering
<i>1459</i>&nbsp;     * will be clipped by the image.
<i>1460</i>&nbsp;     *
<i>1461</i>&nbsp;     * &lt;p&gt;
<i>1462</i>&nbsp;     * When taking a snapshot of a scene that is being animated, either
<i>1463</i>&nbsp;     * explicitly by the application or implicitly (such as chart animation),
<i>1464</i>&nbsp;     * the snapshot will be rendered based on the state of the scene graph at
<i>1465</i>&nbsp;     * the moment the snapshot is taken and will not reflect any subsequent
<i>1466</i>&nbsp;     * animation changes.
<i>1467</i>&nbsp;     * &lt;/p&gt;
<i>1468</i>&nbsp;     *
<i>1469</i>&nbsp;     * @param image the writable image that will be used to hold the rendered scene.
<i>1470</i>&nbsp;     * It may be null in which case a new WritableImage will be constructed.
<i>1471</i>&nbsp;     * If the image is non-null, the scene will be rendered into the
<i>1472</i>&nbsp;     * existing image.
<i>1473</i>&nbsp;     * In this case, the width and height of the image determine the area
<i>1474</i>&nbsp;     * that is rendered instead of the width and height of the scene.
<i>1475</i>&nbsp;     *
<i>1476</i>&nbsp;     * @throws IllegalStateException if this method is called on a thread
<i>1477</i>&nbsp;     *     other than the JavaFX Application Thread.
<i>1478</i>&nbsp;     *
<i>1479</i>&nbsp;     * @return the rendered image
<i>1480</i>&nbsp;     * @since JavaFX 2.2
<i>1481</i>&nbsp;     */
<i>1482</i>&nbsp;    public WritableImage snapshot(WritableImage image) {
<b class="nc"><i>1483</i>&nbsp;        if (!paused) {</b>
<b class="nc"><i>1484</i>&nbsp;            Toolkit.getToolkit().checkFxUserThread();</b>
<i>1485</i>&nbsp;        }
<i>1486</i>&nbsp;
<b class="nc"><i>1487</i>&nbsp;        return doSnapshot(image);</b>
<i>1488</i>&nbsp;    }
<i>1489</i>&nbsp;
<i>1490</i>&nbsp;    /**
<i>1491</i>&nbsp;     * Takes a snapshot of this scene at the next frame and calls the
<i>1492</i>&nbsp;     * specified callback method when the image is ready.
<i>1493</i>&nbsp;     * CSS and layout processing will be done for the scene prior to
<i>1494</i>&nbsp;     * rendering it.
<i>1495</i>&nbsp;     * The entire destination image is cleared using the fill {@code Paint}
<i>1496</i>&nbsp;     * of this scene. The nodes in the scene are then rendered to the image.
<i>1497</i>&nbsp;     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
<i>1498</i>&nbsp;     * If the image is smaller than the size of the scene, then the rendering
<i>1499</i>&nbsp;     * will be clipped by the image.
<i>1500</i>&nbsp;     *
<i>1501</i>&nbsp;     * &lt;p&gt;
<i>1502</i>&nbsp;     * This is an asynchronous call, which means that other
<i>1503</i>&nbsp;     * events or animation might be processed before the scene is rendered.
<i>1504</i>&nbsp;     * If any such events modify a node in the scene that modification will
<i>1505</i>&nbsp;     * be reflected in the rendered image (as it will also be reflected in
<i>1506</i>&nbsp;     * the frame rendered to the Stage).
<i>1507</i>&nbsp;     * &lt;/p&gt;
<i>1508</i>&nbsp;     *
<i>1509</i>&nbsp;     * &lt;p&gt;
<i>1510</i>&nbsp;     * When taking a snapshot of a scene that is being animated, either
<i>1511</i>&nbsp;     * explicitly by the application or implicitly (such as chart animation),
<i>1512</i>&nbsp;     * the snapshot will be rendered based on the state of the scene graph at
<i>1513</i>&nbsp;     * the moment the snapshot is taken and will not reflect any subsequent
<i>1514</i>&nbsp;     * animation changes.
<i>1515</i>&nbsp;     * &lt;/p&gt;
<i>1516</i>&nbsp;     *
<i>1517</i>&nbsp;     * @param callback a class whose call method will be called when the image
<i>1518</i>&nbsp;     * is ready. The SnapshotResult that is passed into the call method of
<i>1519</i>&nbsp;     * the callback will contain the rendered image and the source scene
<i>1520</i>&nbsp;     * that was rendered. The callback parameter must not be null.
<i>1521</i>&nbsp;     *
<i>1522</i>&nbsp;     * @param image the writable image that will be used to hold the rendered scene.
<i>1523</i>&nbsp;     * It may be null in which case a new WritableImage will be constructed.
<i>1524</i>&nbsp;     * If the image is non-null, the scene will be rendered into the
<i>1525</i>&nbsp;     * existing image.
<i>1526</i>&nbsp;     * In this case, the width and height of the image determine the area
<i>1527</i>&nbsp;     * that is rendered instead of the width and height of the scene.
<i>1528</i>&nbsp;     *
<i>1529</i>&nbsp;     * @throws IllegalStateException if this method is called on a thread
<i>1530</i>&nbsp;     *     other than the JavaFX Application Thread.
<i>1531</i>&nbsp;     *
<i>1532</i>&nbsp;     * @throws NullPointerException if the callback parameter is null.
<i>1533</i>&nbsp;     * @since JavaFX 2.2
<i>1534</i>&nbsp;     */
<i>1535</i>&nbsp;    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
<b class="nc"><i>1536</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<b class="nc"><i>1537</i>&nbsp;        if (callback == null) {</b>
<b class="nc"><i>1538</i>&nbsp;            throw new NullPointerException(&quot;The callback must not be null&quot;);</b>
<i>1539</i>&nbsp;        }
<i>1540</i>&nbsp;
<b class="nc"><i>1541</i>&nbsp;        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;</b>
<b class="nc"><i>1542</i>&nbsp;        final WritableImage theImage = image;</b>
<i>1543</i>&nbsp;
<i>1544</i>&nbsp;        // Create a deferred runnable that will be run from a pulse listener
<i>1545</i>&nbsp;        // that is called after all of the scenes have been synced but before
<i>1546</i>&nbsp;        // any of them have been rendered.
<b class="nc"><i>1547</i>&nbsp;        final Runnable snapshotRunnable = () -&gt; {</b>
<b class="nc"><i>1548</i>&nbsp;            WritableImage img = doSnapshot(theImage);</b>
<i>1549</i>&nbsp;//                System.err.println(&quot;Calling snapshot callback&quot;);
<b class="nc"><i>1550</i>&nbsp;            SnapshotResult result = new SnapshotResult(img, Scene.this, null);</b>
<i>1551</i>&nbsp;            try {
<b class="nc"><i>1552</i>&nbsp;                Void v = theCallback.call(result);</b>
<b class="nc"><i>1553</i>&nbsp;            } catch (Throwable th) {</b>
<b class="nc"><i>1554</i>&nbsp;                System.err.println(&quot;Exception in snapshot callback&quot;);</b>
<b class="nc"><i>1555</i>&nbsp;                th.printStackTrace(System.err);</b>
<b class="nc"><i>1556</i>&nbsp;            }</b>
<b class="nc"><i>1557</i>&nbsp;        };</b>
<i>1558</i>&nbsp;//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
<b class="nc"><i>1559</i>&nbsp;        addSnapshotRunnable(snapshotRunnable);</b>
<b class="nc"><i>1560</i>&nbsp;    }</b>
<i>1561</i>&nbsp;
<i>1562</i>&nbsp;    /**
<i>1563</i>&nbsp;     * Defines the mouse cursor for this {@code Scene}.
<i>1564</i>&nbsp;     */
<i>1565</i>&nbsp;    private ObjectProperty&lt;Cursor&gt; cursor;
<i>1566</i>&nbsp;
<i>1567</i>&nbsp;    public final void setCursor(Cursor value) {
<b class="fc"><i>1568</i>&nbsp;        cursorProperty().set(value);</b>
<b class="fc"><i>1569</i>&nbsp;    }</b>
<i>1570</i>&nbsp;
<i>1571</i>&nbsp;    public final Cursor getCursor() {
<b class="fc"><i>1572</i>&nbsp;        return cursor == null ? null : cursor.get();</b>
<i>1573</i>&nbsp;    }
<i>1574</i>&nbsp;
<i>1575</i>&nbsp;    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
<b class="fc"><i>1576</i>&nbsp;        if (cursor == null) {</b>
<b class="fc"><i>1577</i>&nbsp;            cursor = new ObjectPropertyBase&lt;Cursor&gt;() {</b>
<i>1578</i>&nbsp;                         @Override
<i>1579</i>&nbsp;                         protected void invalidated() {
<b class="nc"><i>1580</i>&nbsp;                             markCursorDirty();</b>
<b class="nc"><i>1581</i>&nbsp;                         }</b>
<i>1582</i>&nbsp;
<i>1583</i>&nbsp;                         @Override
<i>1584</i>&nbsp;                         public Object getBean() {
<b class="nc"><i>1585</i>&nbsp;                             return Scene.this;</b>
<i>1586</i>&nbsp;                         }
<i>1587</i>&nbsp;
<i>1588</i>&nbsp;                         @Override
<i>1589</i>&nbsp;                         public String getName() {
<b class="nc"><i>1590</i>&nbsp;                             return &quot;cursor&quot;;</b>
<i>1591</i>&nbsp;                         }
<i>1592</i>&nbsp;                     };
<i>1593</i>&nbsp;        }
<b class="fc"><i>1594</i>&nbsp;        return cursor;</b>
<i>1595</i>&nbsp;    }
<i>1596</i>&nbsp;
<i>1597</i>&nbsp;    /**
<i>1598</i>&nbsp;     * Looks for any node within the scene graph based on the specified CSS selector.
<i>1599</i>&nbsp;     * If more than one node matches the specified selector, this function
<i>1600</i>&nbsp;     * returns the first of them.
<i>1601</i>&nbsp;     * If no nodes are found with this id, then null is returned.
<i>1602</i>&nbsp;     *
<i>1603</i>&nbsp;     * @param selector The css selector to look up
<i>1604</i>&nbsp;     * @return the {@code Node} in the scene which matches the CSS {@code selector},
<i>1605</i>&nbsp;     * or {@code null} if none is found.
<i>1606</i>&nbsp;     */
<i>1607</i>&nbsp;     public Node lookup(String selector) {
<b class="nc"><i>1608</i>&nbsp;         return getRoot().lookup(selector);</b>
<i>1609</i>&nbsp;     }
<i>1610</i>&nbsp;    /**
<i>1611</i>&nbsp;     * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
<i>1612</i>&nbsp;     * contents. For additional information about using CSS with the
<i>1613</i>&nbsp;     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
<i>1614</i>&nbsp;     * Guide&lt;/a&gt;.
<i>1615</i>&nbsp;     */
<b class="fc"><i>1616</i>&nbsp;    private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {</b>
<i>1617</i>&nbsp;        @Override
<i>1618</i>&nbsp;        protected void onChanged(Change&lt;String&gt; c) {
<b class="nc"><i>1619</i>&nbsp;            StyleManager.getInstance().stylesheetsChanged(Scene.this, c);</b>
<i>1620</i>&nbsp;            // RT-9784 - if stylesheet is removed, reset styled properties to
<i>1621</i>&nbsp;            // their initial value.
<b class="nc"><i>1622</i>&nbsp;            c.reset();</b>
<b class="nc"><i>1623</i>&nbsp;            while(c.next()) {</b>
<b class="nc"><i>1624</i>&nbsp;                if (c.wasRemoved() == false) {</b>
<b class="nc"><i>1625</i>&nbsp;                    continue;</b>
<i>1626</i>&nbsp;                }
<i>1627</i>&nbsp;                break; // no point in resetting more than once...
<i>1628</i>&nbsp;            }
<b class="nc"><i>1629</i>&nbsp;            getRoot().reapplyCSS();</b>
<b class="nc"><i>1630</i>&nbsp;        }</b>
<i>1631</i>&nbsp;    };
<i>1632</i>&nbsp;
<i>1633</i>&nbsp;    /**
<i>1634</i>&nbsp;     * Gets an observable list of string URLs linking to the stylesheets to use
<i>1635</i>&nbsp;     * with this scene&#39;s contents.
<i>1636</i>&nbsp;     * &lt;p&gt;
<i>1637</i>&nbsp;     * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
<i>1638</i>&nbsp;     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
<i>1639</i>&nbsp;     * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
<i>1640</i>&nbsp;     * the root of the application&#39;s classpath.
<i>1641</i>&nbsp;     * &lt;/p&gt;
<i>1642</i>&nbsp;     * &lt;pre&gt;&lt;code&gt;
<i>1643</i>&nbsp;     *
<i>1644</i>&nbsp;     * package com.example.javafx.app;
<i>1645</i>&nbsp;     *
<i>1646</i>&nbsp;     * import javafx.application.Application;
<i>1647</i>&nbsp;     * import javafx.scene.Group;
<i>1648</i>&nbsp;     * import javafx.scene.Scene;
<i>1649</i>&nbsp;     * import javafx.stage.Stage;
<i>1650</i>&nbsp;     *
<i>1651</i>&nbsp;     * public class MyApp extends Application {
<i>1652</i>&nbsp;     *
<i>1653</i>&nbsp;     *     {@literal @}Override public void start(Stage stage) {
<i>1654</i>&nbsp;     *         Scene scene = new Scene(new Group());
<i>1655</i>&nbsp;     *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
<i>1656</i>&nbsp;     *         stage.setScene(scene);
<i>1657</i>&nbsp;     *         stage.show();
<i>1658</i>&nbsp;     *     }
<i>1659</i>&nbsp;     *
<i>1660</i>&nbsp;     *     public static void main(String[] args) {
<i>1661</i>&nbsp;     *         launch(args);
<i>1662</i>&nbsp;     *     }
<i>1663</i>&nbsp;     * }
<i>1664</i>&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
<i>1665</i>&nbsp;     * For additional information about using CSS with the scene graph,
<i>1666</i>&nbsp;     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
<i>1667</i>&nbsp;     *
<i>1668</i>&nbsp;     * @return the list of stylesheets to use with this scene
<i>1669</i>&nbsp;     */
<b class="fc"><i>1670</i>&nbsp;    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }</b>
<i>1671</i>&nbsp;
<b class="fc"><i>1672</i>&nbsp;    private ObjectProperty&lt;String&gt; userAgentStylesheet = null;</b>
<i>1673</i>&nbsp;
<i>1674</i>&nbsp;    /**
<i>1675</i>&nbsp;     * @return the userAgentStylesheet property.
<i>1676</i>&nbsp;     * @see #getUserAgentStylesheet()
<i>1677</i>&nbsp;     * @see #setUserAgentStylesheet(String)
<i>1678</i>&nbsp;     * @since  JavaFX 8u20
<i>1679</i>&nbsp;     */
<i>1680</i>&nbsp;    public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
<b class="nc"><i>1681</i>&nbsp;        if (userAgentStylesheet == null) {</b>
<b class="nc"><i>1682</i>&nbsp;            userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {</b>
<i>1683</i>&nbsp;                @Override protected void invalidated() {
<b class="nc"><i>1684</i>&nbsp;                    StyleManager.getInstance().forget(Scene.this);</b>
<b class="nc"><i>1685</i>&nbsp;                    getRoot().reapplyCSS();</b>
<b class="nc"><i>1686</i>&nbsp;                }</b>
<i>1687</i>&nbsp;            };
<i>1688</i>&nbsp;        }
<b class="nc"><i>1689</i>&nbsp;        return userAgentStylesheet;</b>
<i>1690</i>&nbsp;    }
<i>1691</i>&nbsp;
<i>1692</i>&nbsp;    /**
<i>1693</i>&nbsp;     * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
<i>1694</i>&nbsp;     * the platform-default user-agent stylesheet will be used.
<i>1695</i>&nbsp;     * &lt;p&gt;
<i>1696</i>&nbsp;     * For additional information about using CSS with the scene graph,
<i>1697</i>&nbsp;     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
<i>1698</i>&nbsp;     * &lt;/p&gt;
<i>1699</i>&nbsp;     * @return The URL of the user-agent stylesheet that will be used by this Scene,
<i>1700</i>&nbsp;     * or null if has not been set.
<i>1701</i>&nbsp;     * @since  JavaFX 8u20
<i>1702</i>&nbsp;     */
<i>1703</i>&nbsp;    public final String getUserAgentStylesheet() {
<b class="fc"><i>1704</i>&nbsp;        return userAgentStylesheet == null ? null : userAgentStylesheet.get();</b>
<i>1705</i>&nbsp;    }
<i>1706</i>&nbsp;
<i>1707</i>&nbsp;    /**
<i>1708</i>&nbsp;     * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
<i>1709</i>&nbsp;     * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
<i>1710</i>&nbsp;     * the platform-default user-agent stylesheet will be used.
<i>1711</i>&nbsp;     * &lt;p&gt;
<i>1712</i>&nbsp;     * For additional information about using CSS with the scene graph,
<i>1713</i>&nbsp;     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
<i>1714</i>&nbsp;     * &lt;/p&gt;
<i>1715</i>&nbsp;     * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
<i>1716</i>&nbsp;     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
<i>1717</i>&nbsp;     * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
<i>1718</i>&nbsp;     * the root of the application&#39;s classpath.
<i>1719</i>&nbsp;     * @since  JavaFX 8u20
<i>1720</i>&nbsp;     */
<i>1721</i>&nbsp;    public final void setUserAgentStylesheet(String url) {
<b class="nc"><i>1722</i>&nbsp;        userAgentStylesheetProperty().set(url);</b>
<b class="nc"><i>1723</i>&nbsp;    }</b>
<i>1724</i>&nbsp;
<i>1725</i>&nbsp;    /**
<i>1726</i>&nbsp;     * Retrieves the depth buffer attribute for this scene.
<i>1727</i>&nbsp;     * @return the depth buffer attribute.
<i>1728</i>&nbsp;     */
<i>1729</i>&nbsp;    public final boolean isDepthBuffer() {
<b class="fc"><i>1730</i>&nbsp;        return depthBuffer;</b>
<i>1731</i>&nbsp;    }
<i>1732</i>&nbsp;
<i>1733</i>&nbsp;    boolean isDepthBufferInternal() {
<b class="fc"><i>1734</i>&nbsp;        if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {</b>
<b class="nc"><i>1735</i>&nbsp;            return false;</b>
<i>1736</i>&nbsp;        }
<b class="fc"><i>1737</i>&nbsp;        return depthBuffer;</b>
<i>1738</i>&nbsp;    }
<i>1739</i>&nbsp;
<i>1740</i>&nbsp;    private void init(double width, double height) {
<b class="fc"><i>1741</i>&nbsp;        if (width &gt;= 0) {</b>
<b class="nc"><i>1742</i>&nbsp;            widthSetByUser = width;</b>
<b class="nc"><i>1743</i>&nbsp;            setWidth((float)width);</b>
<i>1744</i>&nbsp;        }
<b class="fc"><i>1745</i>&nbsp;        if (height &gt;= 0) {</b>
<b class="nc"><i>1746</i>&nbsp;            heightSetByUser = height;</b>
<b class="nc"><i>1747</i>&nbsp;            setHeight((float)height);</b>
<i>1748</i>&nbsp;        }
<b class="fc"><i>1749</i>&nbsp;        sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);</b>
<b class="fc"><i>1750</i>&nbsp;    }</b>
<i>1751</i>&nbsp;
<i>1752</i>&nbsp;    private void init() {
<b class="fc"><i>1753</i>&nbsp;        if (PerformanceTracker.isLoggingEnabled()) {</b>
<b class="nc"><i>1754</i>&nbsp;            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);</b>
<i>1755</i>&nbsp;        }
<b class="fc"><i>1756</i>&nbsp;        mouseHandler = new MouseHandler();</b>
<b class="fc"><i>1757</i>&nbsp;        clickGenerator = new ClickGenerator();</b>
<i>1758</i>&nbsp;
<b class="fc"><i>1759</i>&nbsp;        if (PerformanceTracker.isLoggingEnabled()) {</b>
<b class="nc"><i>1760</i>&nbsp;            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);</b>
<i>1761</i>&nbsp;        }
<b class="fc"><i>1762</i>&nbsp;    }</b>
<i>1763</i>&nbsp;
<i>1764</i>&nbsp;    void preferredSize() {
<b class="fc"><i>1765</i>&nbsp;        final Parent root = getRoot();</b>
<i>1766</i>&nbsp;
<i>1767</i>&nbsp;        // one or the other isn&#39;t initialized, need to perform layout in
<i>1768</i>&nbsp;        // order to ensure we can properly measure the preferred size of the
<i>1769</i>&nbsp;        // scene
<b class="fc"><i>1770</i>&nbsp;        doCSSPass();</b>
<i>1771</i>&nbsp;
<b class="fc"><i>1772</i>&nbsp;        resizeRootToPreferredSize(root);</b>
<b class="fc"><i>1773</i>&nbsp;        doLayoutPass();</b>
<i>1774</i>&nbsp;
<b class="fc"><i>1775</i>&nbsp;        if (widthSetByUser &lt; 0) {</b>
<b class="fc"><i>1776</i>&nbsp;            setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :</b>
<b class="nc"><i>1777</i>&nbsp;                            root.getBoundsInParent().getMaxX());</b>
<i>1778</i>&nbsp;        } else {
<b class="nc"><i>1779</i>&nbsp;            setWidth(widthSetByUser);</b>
<i>1780</i>&nbsp;        }
<i>1781</i>&nbsp;
<b class="fc"><i>1782</i>&nbsp;        if (heightSetByUser &lt; 0) {</b>
<b class="fc"><i>1783</i>&nbsp;            setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :</b>
<b class="nc"><i>1784</i>&nbsp;                            root.getBoundsInParent().getMaxY());</b>
<i>1785</i>&nbsp;        } else {
<b class="nc"><i>1786</i>&nbsp;            setHeight(heightSetByUser);</b>
<i>1787</i>&nbsp;        }
<i>1788</i>&nbsp;
<b class="fc"><i>1789</i>&nbsp;        sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);</b>
<i>1790</i>&nbsp;
<b class="fc"><i>1791</i>&nbsp;        PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);</b>
<b class="fc"><i>1792</i>&nbsp;    }</b>
<i>1793</i>&nbsp;
<i>1794</i>&nbsp;    final void resizeRootToPreferredSize(Parent root) {
<i>1795</i>&nbsp;        final double preferredWidth;
<i>1796</i>&nbsp;        final double preferredHeight;
<i>1797</i>&nbsp;
<b class="fc"><i>1798</i>&nbsp;        final Orientation contentBias = root.getContentBias();</b>
<b class="fc"><i>1799</i>&nbsp;        if (contentBias == null) {</b>
<b class="fc"><i>1800</i>&nbsp;            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);</b>
<b class="fc"><i>1801</i>&nbsp;            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);</b>
<b class="nc"><i>1802</i>&nbsp;        } else if (contentBias == Orientation.HORIZONTAL) {</b>
<i>1803</i>&nbsp;            // height depends on width
<b class="nc"><i>1804</i>&nbsp;            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);</b>
<b class="nc"><i>1805</i>&nbsp;            preferredHeight = getPreferredHeight(root, heightSetByUser,</b>
<i>1806</i>&nbsp;                                                       preferredWidth);
<i>1807</i>&nbsp;        } else /* if (contentBias == Orientation.VERTICAL) */ {
<i>1808</i>&nbsp;            // width depends on height
<b class="nc"><i>1809</i>&nbsp;            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);</b>
<b class="nc"><i>1810</i>&nbsp;            preferredWidth = getPreferredWidth(root, widthSetByUser,</b>
<i>1811</i>&nbsp;                                                     preferredHeight);
<i>1812</i>&nbsp;        }
<i>1813</i>&nbsp;
<b class="fc"><i>1814</i>&nbsp;        root.resize(preferredWidth, preferredHeight);</b>
<b class="fc"><i>1815</i>&nbsp;    }</b>
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;    private static double getPreferredWidth(Parent root,
<i>1818</i>&nbsp;                                            double forcedWidth,
<i>1819</i>&nbsp;                                            double height) {
<b class="fc"><i>1820</i>&nbsp;        if (forcedWidth &gt;= 0) {</b>
<b class="nc"><i>1821</i>&nbsp;            return forcedWidth;</b>
<i>1822</i>&nbsp;        }
<b class="fc"><i>1823</i>&nbsp;        final double normalizedHeight = (height &gt;= 0) ? height : -1;</b>
<b class="fc"><i>1824</i>&nbsp;        return root.boundedSize(root.prefWidth(normalizedHeight),</b>
<b class="fc"><i>1825</i>&nbsp;                                root.minWidth(normalizedHeight),</b>
<b class="fc"><i>1826</i>&nbsp;                                root.maxWidth(normalizedHeight));</b>
<i>1827</i>&nbsp;    }
<i>1828</i>&nbsp;
<i>1829</i>&nbsp;    private static double getPreferredHeight(Parent root,
<i>1830</i>&nbsp;                                             double forcedHeight,
<i>1831</i>&nbsp;                                             double width) {
<b class="fc"><i>1832</i>&nbsp;        if (forcedHeight &gt;= 0) {</b>
<b class="nc"><i>1833</i>&nbsp;            return forcedHeight;</b>
<i>1834</i>&nbsp;        }
<b class="fc"><i>1835</i>&nbsp;        final double normalizedWidth = (width &gt;= 0) ? width : -1;</b>
<b class="fc"><i>1836</i>&nbsp;        return root.boundedSize(root.prefHeight(normalizedWidth),</b>
<b class="fc"><i>1837</i>&nbsp;                                root.minHeight(normalizedWidth),</b>
<b class="fc"><i>1838</i>&nbsp;                                root.maxHeight(normalizedWidth));</b>
<i>1839</i>&nbsp;    }
<i>1840</i>&nbsp;
<i>1841</i>&nbsp;    private PerformanceTracker tracker;
<b class="fc"><i>1842</i>&nbsp;    private static final Object trackerMonitor = new Object();</b>
<i>1843</i>&nbsp;
<i>1844</i>&nbsp;    // mouse events handling
<i>1845</i>&nbsp;    private MouseHandler mouseHandler;
<i>1846</i>&nbsp;    private ClickGenerator clickGenerator;
<i>1847</i>&nbsp;
<i>1848</i>&nbsp;    // gesture events handling
<i>1849</i>&nbsp;    private Point2D cursorScreenPos;
<i>1850</i>&nbsp;    private Point2D cursorScenePos;
<i>1851</i>&nbsp;
<b class="fc"><i>1852</i>&nbsp;    private static class TouchGesture {</b>
<i>1853</i>&nbsp;        WeakReference&lt;EventTarget&gt; target;
<i>1854</i>&nbsp;        Point2D sceneCoords;
<i>1855</i>&nbsp;        Point2D screenCoords;
<i>1856</i>&nbsp;        boolean finished;
<i>1857</i>&nbsp;    }
<i>1858</i>&nbsp;
<b class="fc"><i>1859</i>&nbsp;    private final TouchGesture scrollGesture = new TouchGesture();</b>
<b class="fc"><i>1860</i>&nbsp;    private final TouchGesture zoomGesture = new TouchGesture();</b>
<b class="fc"><i>1861</i>&nbsp;    private final TouchGesture rotateGesture = new TouchGesture();</b>
<b class="fc"><i>1862</i>&nbsp;    private final TouchGesture swipeGesture = new TouchGesture();</b>
<i>1863</i>&nbsp;
<i>1864</i>&nbsp;    // touch events handling
<b class="fc"><i>1865</i>&nbsp;    private TouchMap touchMap = new TouchMap();</b>
<b class="fc"><i>1866</i>&nbsp;    private TouchEvent nextTouchEvent = null;</b>
<b class="fc"><i>1867</i>&nbsp;    private TouchPoint[] touchPoints = null;</b>
<b class="fc"><i>1868</i>&nbsp;    private int touchEventSetId = 0;</b>
<b class="fc"><i>1869</i>&nbsp;    private int touchPointIndex = 0;</b>
<b class="fc"><i>1870</i>&nbsp;    private Map&lt;Integer, EventTarget&gt; touchTargets =</b>
<i>1871</i>&nbsp;            new HashMap&lt;Integer, EventTarget&gt;();
<i>1872</i>&nbsp;
<i>1873</i>&nbsp;    void processMouseEvent(MouseEvent e) {
<b class="fc"><i>1874</i>&nbsp;        mouseHandler.process(e, false);</b>
<b class="fc"><i>1875</i>&nbsp;    }</b>
<i>1876</i>&nbsp;
<i>1877</i>&nbsp;    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
<b class="nc"><i>1878</i>&nbsp;        EventTarget eventTarget = null;</b>
<b class="nc"><i>1879</i>&nbsp;        Scene.inMousePick = true;</b>
<b class="nc"><i>1880</i>&nbsp;        if (isKeyboardTrigger) {</b>
<b class="nc"><i>1881</i>&nbsp;            Node sceneFocusOwner = getFocusOwner();</b>
<i>1882</i>&nbsp;
<i>1883</i>&nbsp;            // for keyboard triggers set coordinates inside focus owner
<b class="nc"><i>1884</i>&nbsp;            final double xOffset = xAbs - x2;</b>
<b class="nc"><i>1885</i>&nbsp;            final double yOffset = yAbs - y2;</b>
<b class="nc"><i>1886</i>&nbsp;            if (sceneFocusOwner != null) {</b>
<b class="nc"><i>1887</i>&nbsp;                final Bounds bounds = sceneFocusOwner.localToScene(</b>
<b class="nc"><i>1888</i>&nbsp;                        sceneFocusOwner.getBoundsInLocal());</b>
<b class="nc"><i>1889</i>&nbsp;                x2 = bounds.getMinX() + bounds.getWidth() / 4;</b>
<b class="nc"><i>1890</i>&nbsp;                y2 = bounds.getMinY() + bounds.getHeight() / 2;</b>
<b class="nc"><i>1891</i>&nbsp;                eventTarget = sceneFocusOwner;</b>
<b class="nc"><i>1892</i>&nbsp;            } else {</b>
<b class="nc"><i>1893</i>&nbsp;                x2 = Scene.this.getWidth() / 4;</b>
<b class="nc"><i>1894</i>&nbsp;                y2 = Scene.this.getWidth() / 2;</b>
<b class="nc"><i>1895</i>&nbsp;                eventTarget = Scene.this;</b>
<i>1896</i>&nbsp;            }
<i>1897</i>&nbsp;
<b class="nc"><i>1898</i>&nbsp;            xAbs = x2 + xOffset;</b>
<b class="nc"><i>1899</i>&nbsp;            yAbs = y2 + yOffset;</b>
<i>1900</i>&nbsp;        }
<i>1901</i>&nbsp;
<b class="nc"><i>1902</i>&nbsp;        final PickResult res = pick(x2, y2);</b>
<i>1903</i>&nbsp;
<b class="nc"><i>1904</i>&nbsp;        if (!isKeyboardTrigger) {</b>
<b class="nc"><i>1905</i>&nbsp;            eventTarget = res.getIntersectedNode();</b>
<b class="nc"><i>1906</i>&nbsp;            if (eventTarget == null) {</b>
<b class="nc"><i>1907</i>&nbsp;                eventTarget = this;</b>
<i>1908</i>&nbsp;            }
<i>1909</i>&nbsp;        }
<i>1910</i>&nbsp;
<b class="nc"><i>1911</i>&nbsp;        if (eventTarget != null) {</b>
<b class="nc"><i>1912</i>&nbsp;            ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,</b>
<i>1913</i>&nbsp;                    x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
<b class="nc"><i>1914</i>&nbsp;            Event.fireEvent(eventTarget, context);</b>
<i>1915</i>&nbsp;        }
<b class="nc"><i>1916</i>&nbsp;        Scene.inMousePick = false;</b>
<b class="nc"><i>1917</i>&nbsp;    }</b>
<i>1918</i>&nbsp;
<i>1919</i>&nbsp;    private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
<b class="nc"><i>1920</i>&nbsp;        EventTarget pickedTarget = null;</b>
<i>1921</i>&nbsp;
<b class="nc"><i>1922</i>&nbsp;        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||</b>
<b class="nc"><i>1923</i>&nbsp;                e.getEventType() == RotateEvent.ROTATION_STARTED ||</b>
<b class="nc"><i>1924</i>&nbsp;                e.getEventType() == ScrollEvent.SCROLL_STARTED) {</b>
<b class="nc"><i>1925</i>&nbsp;            gesture.target = null;</b>
<b class="nc"><i>1926</i>&nbsp;            gesture.finished = false;</b>
<i>1927</i>&nbsp;        }
<i>1928</i>&nbsp;
<b class="nc"><i>1929</i>&nbsp;        if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {</b>
<b class="nc"><i>1930</i>&nbsp;            pickedTarget = gesture.target.get();</b>
<i>1931</i>&nbsp;        } else {
<b class="nc"><i>1932</i>&nbsp;            pickedTarget = e.getPickResult().getIntersectedNode();</b>
<b class="nc"><i>1933</i>&nbsp;            if (pickedTarget == null) {</b>
<b class="nc"><i>1934</i>&nbsp;                pickedTarget = this;</b>
<i>1935</i>&nbsp;            }
<i>1936</i>&nbsp;        }
<i>1937</i>&nbsp;
<b class="nc"><i>1938</i>&nbsp;        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||</b>
<b class="nc"><i>1939</i>&nbsp;                e.getEventType() == RotateEvent.ROTATION_STARTED ||</b>
<b class="nc"><i>1940</i>&nbsp;                e.getEventType() == ScrollEvent.SCROLL_STARTED) {</b>
<b class="nc"><i>1941</i>&nbsp;            gesture.target = new WeakReference&lt;&gt;(pickedTarget);</b>
<i>1942</i>&nbsp;        }
<b class="nc"><i>1943</i>&nbsp;        if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;</b>
<b class="nc"><i>1944</i>&nbsp;                e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;</b>
<b class="nc"><i>1945</i>&nbsp;                e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;</b>
<b class="nc"><i>1946</i>&nbsp;                !e.isInertia()) {</b>
<b class="nc"><i>1947</i>&nbsp;            gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());</b>
<b class="nc"><i>1948</i>&nbsp;            gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());</b>
<i>1949</i>&nbsp;        }
<i>1950</i>&nbsp;
<b class="nc"><i>1951</i>&nbsp;        if (pickedTarget != null) {</b>
<b class="nc"><i>1952</i>&nbsp;            Event.fireEvent(pickedTarget, e);</b>
<i>1953</i>&nbsp;        }
<i>1954</i>&nbsp;
<b class="nc"><i>1955</i>&nbsp;        if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||</b>
<b class="nc"><i>1956</i>&nbsp;                e.getEventType() == RotateEvent.ROTATION_FINISHED ||</b>
<b class="nc"><i>1957</i>&nbsp;                e.getEventType() == ScrollEvent.SCROLL_FINISHED) {</b>
<b class="nc"><i>1958</i>&nbsp;            gesture.finished = true;</b>
<i>1959</i>&nbsp;        }
<b class="nc"><i>1960</i>&nbsp;    }</b>
<i>1961</i>&nbsp;
<i>1962</i>&nbsp;    private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
<b class="nc"><i>1963</i>&nbsp;        inMousePick = true;</b>
<b class="nc"><i>1964</i>&nbsp;        touchEventSetId++;</b>
<i>1965</i>&nbsp;
<b class="nc"><i>1966</i>&nbsp;        List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);</b>
<i>1967</i>&nbsp;
<i>1968</i>&nbsp;        // fire all the events
<b class="nc"><i>1969</i>&nbsp;        for (TouchPoint tp : touchPoints) {</b>
<b class="nc"><i>1970</i>&nbsp;            if (tp.getTarget() != null) {</b>
<b class="nc"><i>1971</i>&nbsp;                EventType&lt;TouchEvent&gt; type = null;</b>
<b class="nc"><i>1972</i>&nbsp;                switch (tp.getState()) {</b>
<i>1973</i>&nbsp;                    case MOVED:
<b class="nc"><i>1974</i>&nbsp;                        type = TouchEvent.TOUCH_MOVED;</b>
<b class="nc"><i>1975</i>&nbsp;                        break;</b>
<i>1976</i>&nbsp;                    case PRESSED:
<b class="nc"><i>1977</i>&nbsp;                        type = TouchEvent.TOUCH_PRESSED;</b>
<b class="nc"><i>1978</i>&nbsp;                        break;</b>
<i>1979</i>&nbsp;                    case RELEASED:
<b class="nc"><i>1980</i>&nbsp;                        type = TouchEvent.TOUCH_RELEASED;</b>
<b class="nc"><i>1981</i>&nbsp;                        break;</b>
<i>1982</i>&nbsp;                    case STATIONARY:
<b class="nc"><i>1983</i>&nbsp;                        type = TouchEvent.TOUCH_STATIONARY;</b>
<i>1984</i>&nbsp;                        break;
<i>1985</i>&nbsp;                }
<i>1986</i>&nbsp;
<b class="nc"><i>1987</i>&nbsp;                for (TouchPoint t : touchPoints) {</b>
<b class="nc"><i>1988</i>&nbsp;                    TouchPointHelper.reset(t);</b>
<i>1989</i>&nbsp;                }
<i>1990</i>&nbsp;
<b class="nc"><i>1991</i>&nbsp;                TouchEvent te = new TouchEvent(type, tp, touchList,</b>
<b class="nc"><i>1992</i>&nbsp;                        touchEventSetId, e.isShiftDown(), e.isControlDown(),</b>
<b class="nc"><i>1993</i>&nbsp;                        e.isAltDown(), e.isMetaDown());</b>
<i>1994</i>&nbsp;
<b class="nc"><i>1995</i>&nbsp;                Event.fireEvent(tp.getTarget(), te);</b>
<i>1996</i>&nbsp;            }
<i>1997</i>&nbsp;        }
<i>1998</i>&nbsp;
<i>1999</i>&nbsp;        // process grabbing
<b class="nc"><i>2000</i>&nbsp;        for (TouchPoint tp : touchPoints) {</b>
<b class="nc"><i>2001</i>&nbsp;            EventTarget grabbed = tp.getGrabbed();</b>
<b class="nc"><i>2002</i>&nbsp;            if (grabbed != null) {</b>
<b class="nc"><i>2003</i>&nbsp;                touchTargets.put(tp.getId(), grabbed);</b>
<i>2004</i>&nbsp;            };
<i>2005</i>&nbsp;
<b class="nc"><i>2006</i>&nbsp;            if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {</b>
<b class="nc"><i>2007</i>&nbsp;                touchTargets.remove(tp.getId());</b>
<i>2008</i>&nbsp;            }
<i>2009</i>&nbsp;        }
<i>2010</i>&nbsp;
<b class="nc"><i>2011</i>&nbsp;        inMousePick = false;</b>
<b class="nc"><i>2012</i>&nbsp;    }</b>
<i>2013</i>&nbsp;
<i>2014</i>&nbsp;    /**
<i>2015</i>&nbsp;     * Note: The only user of this method is in unit test: PickAndContainTest.
<i>2016</i>&nbsp;     */
<i>2017</i>&nbsp;    Node test_pick(double x, double y) {
<b class="nc"><i>2018</i>&nbsp;        inMousePick = true;</b>
<b class="nc"><i>2019</i>&nbsp;        PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,</b>
<i>2020</i>&nbsp;                Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
<b class="nc"><i>2021</i>&nbsp;        inMousePick = false;</b>
<b class="nc"><i>2022</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>2023</i>&nbsp;            return result.getIntersectedNode();</b>
<i>2024</i>&nbsp;        }
<b class="nc"><i>2025</i>&nbsp;        return null;</b>
<i>2026</i>&nbsp;    }
<i>2027</i>&nbsp;
<i>2028</i>&nbsp;    private PickResult pick(final double x, final double y) {
<b class="nc"><i>2029</i>&nbsp;        pick(tmpTargetWrapper, x, y);</b>
<b class="nc"><i>2030</i>&nbsp;        return tmpTargetWrapper.getResult();</b>
<i>2031</i>&nbsp;    }
<i>2032</i>&nbsp;
<i>2033</i>&nbsp;    private boolean isInScene(double x, double y) {
<b class="fc"><i>2034</i>&nbsp;        if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {</b>
<b class="fc"><i>2035</i>&nbsp;            return false;</b>
<i>2036</i>&nbsp;        }
<i>2037</i>&nbsp;
<b class="nc"><i>2038</i>&nbsp;        Window w = getWindow();</b>
<b class="nc"><i>2039</i>&nbsp;        if (w instanceof Stage</b>
<b class="nc"><i>2040</i>&nbsp;                &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT</b>
<b class="nc"><i>2041</i>&nbsp;                &amp;&amp; getFill() == null) {</b>
<b class="nc"><i>2042</i>&nbsp;            return false;</b>
<i>2043</i>&nbsp;        }
<i>2044</i>&nbsp;
<b class="nc"><i>2045</i>&nbsp;        return true;</b>
<i>2046</i>&nbsp;    }
<i>2047</i>&nbsp;
<i>2048</i>&nbsp;    private void pick(TargetWrapper target, final double x, final double y) {
<b class="fc"><i>2049</i>&nbsp;        final PickRay pickRay = getEffectiveCamera().computePickRay(</b>
<i>2050</i>&nbsp;                x, y, null);
<i>2051</i>&nbsp;
<b class="fc"><i>2052</i>&nbsp;        final double mag = pickRay.getDirectionNoClone().length();</b>
<b class="fc"><i>2053</i>&nbsp;        pickRay.getDirectionNoClone().normalize();</b>
<b class="fc"><i>2054</i>&nbsp;        final PickResult res = mouseHandler.pickNode(pickRay);</b>
<b class="fc"><i>2055</i>&nbsp;        if (res != null) {</b>
<b class="fc"><i>2056</i>&nbsp;            target.setNodeResult(res);</b>
<i>2057</i>&nbsp;        } else {
<i>2058</i>&nbsp;            //TODO: is this the intersection with projection plane?
<b class="fc"><i>2059</i>&nbsp;            Vec3d o = pickRay.getOriginNoClone();</b>
<b class="fc"><i>2060</i>&nbsp;            Vec3d d = pickRay.getDirectionNoClone();</b>
<b class="fc"><i>2061</i>&nbsp;            target.setSceneResult(new PickResult(</b>
<i>2062</i>&nbsp;                    null, new Point3D(
<i>2063</i>&nbsp;                    o.x + mag * d.x,
<i>2064</i>&nbsp;                    o.y + mag * d.y,
<i>2065</i>&nbsp;                    o.z + mag * d.z),
<i>2066</i>&nbsp;                    mag),
<b class="fc"><i>2067</i>&nbsp;                    isInScene(x, y) ? this : null);</b>
<i>2068</i>&nbsp;        }
<b class="fc"><i>2069</i>&nbsp;    }</b>
<i>2070</i>&nbsp;
<i>2071</i>&nbsp;    /***************************************************************************
<i>2072</i>&nbsp;     *                                                                         *
<i>2073</i>&nbsp;     * Key Events and Focus Traversal                                          *
<i>2074</i>&nbsp;     *                                                                         *
<i>2075</i>&nbsp;     **************************************************************************/
<i>2076</i>&nbsp;
<i>2077</i>&nbsp;    /*
<i>2078</i>&nbsp;     * We cannot initialize keyHandler in init because some of the triggers
<i>2079</i>&nbsp;     * access it before the init block.
<i>2080</i>&nbsp;     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
<i>2081</i>&nbsp;     * does not compile.
<i>2082</i>&nbsp;     */
<b class="fc"><i>2083</i>&nbsp;    private KeyHandler keyHandler = null;</b>
<i>2084</i>&nbsp;    private KeyHandler getKeyHandler() {
<b class="fc"><i>2085</i>&nbsp;        if (keyHandler == null) {</b>
<b class="fc"><i>2086</i>&nbsp;            keyHandler = new KeyHandler();</b>
<i>2087</i>&nbsp;        }
<b class="fc"><i>2088</i>&nbsp;        return keyHandler;</b>
<i>2089</i>&nbsp;    }
<i>2090</i>&nbsp;    /**
<i>2091</i>&nbsp;     * Set to true if something has happened to the focused node that makes
<i>2092</i>&nbsp;     * it no longer eligible to have the focus.
<i>2093</i>&nbsp;     *
<i>2094</i>&nbsp;     */
<b class="fc"><i>2095</i>&nbsp;    private boolean focusDirty = true;</b>
<i>2096</i>&nbsp;
<i>2097</i>&nbsp;    final void setFocusDirty(boolean value) {
<b class="fc"><i>2098</i>&nbsp;        if (!focusDirty) {</b>
<b class="fc"><i>2099</i>&nbsp;            Toolkit.getToolkit().requestNextPulse();</b>
<i>2100</i>&nbsp;        }
<b class="fc"><i>2101</i>&nbsp;        focusDirty = value;</b>
<b class="fc"><i>2102</i>&nbsp;    }</b>
<i>2103</i>&nbsp;
<i>2104</i>&nbsp;    final boolean isFocusDirty() {
<b class="fc"><i>2105</i>&nbsp;        return focusDirty;</b>
<i>2106</i>&nbsp;    }
<i>2107</i>&nbsp;
<b class="fc"><i>2108</i>&nbsp;    private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);</b>
<i>2109</i>&nbsp;
<i>2110</i>&nbsp;    /**
<i>2111</i>&nbsp;     * Traverses focus from the given node in the given direction.
<i>2112</i>&nbsp;     */
<i>2113</i>&nbsp;    boolean traverse(Node node, Direction dir) {
<b class="fc"><i>2114</i>&nbsp;        if (node.getSubScene() != null) {</b>
<b class="nc"><i>2115</i>&nbsp;            return node.getSubScene().traverse(node, dir);</b>
<i>2116</i>&nbsp;        }
<b class="fc"><i>2117</i>&nbsp;        return traversalEngine.trav(node, dir) != null;</b>
<i>2118</i>&nbsp;    }
<i>2119</i>&nbsp;
<i>2120</i>&nbsp;    /**
<i>2121</i>&nbsp;     * Moves the focus to a reasonable initial location. Called when a scene&#39;s
<i>2122</i>&nbsp;     * focus is dirty and there&#39;s no current owner, or if the owner has been
<i>2123</i>&nbsp;     * removed from the scene.
<i>2124</i>&nbsp;     */
<i>2125</i>&nbsp;    private void focusInitial() {
<b class="fc"><i>2126</i>&nbsp;        traversalEngine.traverseToFirst();</b>
<b class="fc"><i>2127</i>&nbsp;    }</b>
<i>2128</i>&nbsp;
<i>2129</i>&nbsp;    /**
<i>2130</i>&nbsp;     * Moves the focus to a reasonble location &quot;near&quot; the given node.
<i>2131</i>&nbsp;     * Called when the focused node is no longer eligible to have
<i>2132</i>&nbsp;     * the focus because it has become invisible or disabled. This
<i>2133</i>&nbsp;     * function assumes that it is still a member of the same scene.
<i>2134</i>&nbsp;     */
<i>2135</i>&nbsp;    private void focusIneligible(Node node) {
<b class="fc"><i>2136</i>&nbsp;        traverse(node, Direction.NEXT);</b>
<b class="fc"><i>2137</i>&nbsp;    }</b>
<i>2138</i>&nbsp;
<i>2139</i>&nbsp;    public void processKeyEvent(KeyEvent e) {
<b class="fc"><i>2140</i>&nbsp;        if (dndGesture != null) {</b>
<b class="fc"><i>2141</i>&nbsp;            if (!dndGesture.processKey(e)) {</b>
<b class="nc"><i>2142</i>&nbsp;                dndGesture = null;</b>
<i>2143</i>&nbsp;            }
<i>2144</i>&nbsp;        }
<i>2145</i>&nbsp;
<b class="fc"><i>2146</i>&nbsp;        getKeyHandler().process(e);</b>
<b class="fc"><i>2147</i>&nbsp;    }</b>
<i>2148</i>&nbsp;
<i>2149</i>&nbsp;    void requestFocus(Node node) {
<b class="fc"><i>2150</i>&nbsp;        getKeyHandler().requestFocus(node);</b>
<b class="fc"><i>2151</i>&nbsp;    }</b>
<i>2152</i>&nbsp;
<i>2153</i>&nbsp;    private Node oldFocusOwner;
<i>2154</i>&nbsp;
<i>2155</i>&nbsp;    /**
<i>2156</i>&nbsp;      * The scene&#39;s current focus owner node. This node&#39;s &quot;focused&quot;
<i>2157</i>&nbsp;      * variable might be false if this scene has no window, or if the
<i>2158</i>&nbsp;      * window is inactive (window.focused == false).
<i>2159</i>&nbsp;      * @since JavaFX 2.2
<i>2160</i>&nbsp;      */
<b class="fc"><i>2161</i>&nbsp;    private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {</b>
<i>2162</i>&nbsp;
<i>2163</i>&nbsp;        @Override
<i>2164</i>&nbsp;        protected void invalidated() {
<b class="fc"><i>2165</i>&nbsp;            if (oldFocusOwner != null) {</b>
<b class="fc"><i>2166</i>&nbsp;                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);</b>
<i>2167</i>&nbsp;            }
<b class="fc"><i>2168</i>&nbsp;            Node value = get();</b>
<b class="fc"><i>2169</i>&nbsp;            if (value != null) {</b>
<b class="fc"><i>2170</i>&nbsp;                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);</b>
<b class="fc"><i>2171</i>&nbsp;                if (value != oldFocusOwner) {</b>
<b class="fc"><i>2172</i>&nbsp;                    value.getScene().enableInputMethodEvents(</b>
<b class="fc"><i>2173</i>&nbsp;                            value.getInputMethodRequests() != null</b>
<b class="fc"><i>2174</i>&nbsp;                            &amp;&amp; value.getOnInputMethodTextChanged() != null);</b>
<i>2175</i>&nbsp;                }
<i>2176</i>&nbsp;            }
<i>2177</i>&nbsp;            // for the rest of the method we need to update the oldFocusOwner
<i>2178</i>&nbsp;            // and use a local copy of it because the user handlers can cause
<i>2179</i>&nbsp;            // recurrent calls of requestFocus
<b class="fc"><i>2180</i>&nbsp;            Node localOldOwner = oldFocusOwner;</b>
<b class="fc"><i>2181</i>&nbsp;            oldFocusOwner = value;</b>
<b class="fc"><i>2182</i>&nbsp;            if (localOldOwner != null) {</b>
<b class="fc"><i>2183</i>&nbsp;                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();</b>
<i>2184</i>&nbsp;            }
<b class="fc"><i>2185</i>&nbsp;            if (value != null) {</b>
<b class="fc"><i>2186</i>&nbsp;                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();</b>
<i>2187</i>&nbsp;            }
<b class="fc"><i>2188</i>&nbsp;            PlatformLogger logger = Logging.getFocusLogger();</b>
<b class="fc"><i>2189</i>&nbsp;            if (logger.isLoggable(Level.FINE)) {</b>
<b class="nc"><i>2190</i>&nbsp;                if (value == get()) {</b>
<b class="nc"><i>2191</i>&nbsp;                    logger.fine(&quot;Changed focus from &quot;</b>
<i>2192</i>&nbsp;                            + localOldOwner + &quot; to &quot; + value);
<i>2193</i>&nbsp;                } else {
<b class="nc"><i>2194</i>&nbsp;                    logger.fine(&quot;Changing focus from &quot;</b>
<i>2195</i>&nbsp;                            + localOldOwner + &quot; to &quot; + value
<i>2196</i>&nbsp;                            + &quot; canceled by nested requestFocus&quot;);
<i>2197</i>&nbsp;                }
<i>2198</i>&nbsp;            }
<b class="fc"><i>2199</i>&nbsp;            if (accessible != null) {</b>
<b class="nc"><i>2200</i>&nbsp;                accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);</b>
<i>2201</i>&nbsp;            }
<b class="fc"><i>2202</i>&nbsp;        }</b>
<i>2203</i>&nbsp;    };
<i>2204</i>&nbsp;
<i>2205</i>&nbsp;    public final Node getFocusOwner() {
<b class="fc"><i>2206</i>&nbsp;        return focusOwner.get();</b>
<i>2207</i>&nbsp;    }
<i>2208</i>&nbsp;
<i>2209</i>&nbsp;    public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
<b class="fc"><i>2210</i>&nbsp;        return focusOwner.getReadOnlyProperty();</b>
<i>2211</i>&nbsp;    }
<i>2212</i>&nbsp;
<i>2213</i>&nbsp;    // For testing.
<i>2214</i>&nbsp;    void focusCleanup() {
<b class="nc"><i>2215</i>&nbsp;        scenePulseListener.focusCleanup();</b>
<b class="nc"><i>2216</i>&nbsp;    }</b>
<i>2217</i>&nbsp;
<i>2218</i>&nbsp;    private void processInputMethodEvent(InputMethodEvent e) {
<b class="nc"><i>2219</i>&nbsp;        Node node = getFocusOwner();</b>
<b class="nc"><i>2220</i>&nbsp;        if (node != null) {</b>
<b class="nc"><i>2221</i>&nbsp;            node.fireEvent(e);</b>
<i>2222</i>&nbsp;        }
<b class="nc"><i>2223</i>&nbsp;    }</b>
<i>2224</i>&nbsp;
<i>2225</i>&nbsp;    public void enableInputMethodEvents(boolean enable) {
<b class="fc"><i>2226</i>&nbsp;       if (peer != null) {</b>
<b class="fc"><i>2227</i>&nbsp;           peer.enableInputMethodEvents(enable);</b>
<i>2228</i>&nbsp;       }
<b class="fc"><i>2229</i>&nbsp;    }</b>
<i>2230</i>&nbsp;
<i>2231</i>&nbsp;    /**
<i>2232</i>&nbsp;     * Returns true if this scene is quiescent, i.e. it has no activity
<i>2233</i>&nbsp;     * pending on it such as CSS processing or layout requests.
<i>2234</i>&nbsp;     *
<i>2235</i>&nbsp;     * Intended to be used for tests only
<i>2236</i>&nbsp;     *
<i>2237</i>&nbsp;     * @return boolean indicating whether the scene is quiescent
<i>2238</i>&nbsp;     */
<i>2239</i>&nbsp;    boolean isQuiescent() {
<b class="nc"><i>2240</i>&nbsp;        final Parent r = getRoot();</b>
<b class="nc"><i>2241</i>&nbsp;        return !isFocusDirty()</b>
<i>2242</i>&nbsp;               &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
<i>2243</i>&nbsp;                r.layoutFlag == LayoutFlags.CLEAN));
<i>2244</i>&nbsp;    }
<i>2245</i>&nbsp;
<i>2246</i>&nbsp;    /**
<i>2247</i>&nbsp;     * A listener for pulses, used for testing. If non-null, this is called at
<i>2248</i>&nbsp;     * the very end of ScenePulseListener.pulse().
<i>2249</i>&nbsp;     *
<i>2250</i>&nbsp;     * Intended to be used for tests only
<i>2251</i>&nbsp;     */
<b class="fc"><i>2252</i>&nbsp;    Runnable testPulseListener = null;</b>
<i>2253</i>&nbsp;
<i>2254</i>&nbsp;    /**
<i>2255</i>&nbsp;     * Set the specified dirty bit and mark the peer as dirty
<i>2256</i>&nbsp;     */
<i>2257</i>&nbsp;    private void markDirty(DirtyBits dirtyBit) {
<b class="fc"><i>2258</i>&nbsp;        setDirty(dirtyBit);</b>
<b class="fc"><i>2259</i>&nbsp;        if (peer != null) {</b>
<b class="fc"><i>2260</i>&nbsp;            Toolkit.getToolkit().requestNextPulse();</b>
<i>2261</i>&nbsp;        }
<b class="fc"><i>2262</i>&nbsp;    }</b>
<i>2263</i>&nbsp;
<i>2264</i>&nbsp;    /**
<i>2265</i>&nbsp;     * Set the specified dirty bit
<i>2266</i>&nbsp;     */
<i>2267</i>&nbsp;    private void setDirty(DirtyBits dirtyBit) {
<b class="fc"><i>2268</i>&nbsp;        dirtyBits |= dirtyBit.getMask();</b>
<b class="fc"><i>2269</i>&nbsp;    }</b>
<i>2270</i>&nbsp;
<i>2271</i>&nbsp;    /**
<i>2272</i>&nbsp;     * Test the specified dirty bit
<i>2273</i>&nbsp;     */
<i>2274</i>&nbsp;    private boolean isDirty(DirtyBits dirtyBit) {
<b class="fc"><i>2275</i>&nbsp;        return ((dirtyBits &amp; dirtyBit.getMask()) != 0);</b>
<i>2276</i>&nbsp;    }
<i>2277</i>&nbsp;
<i>2278</i>&nbsp;    /**
<i>2279</i>&nbsp;     * Test whether the dirty bits are empty
<i>2280</i>&nbsp;     */
<i>2281</i>&nbsp;    private boolean isDirtyEmpty() {
<b class="fc"><i>2282</i>&nbsp;        return dirtyBits == 0;</b>
<i>2283</i>&nbsp;    }
<i>2284</i>&nbsp;
<i>2285</i>&nbsp;    /**
<i>2286</i>&nbsp;     * Clear all dirty bits
<i>2287</i>&nbsp;     */
<i>2288</i>&nbsp;    private void clearDirty() {
<b class="fc"><i>2289</i>&nbsp;        dirtyBits = 0;</b>
<b class="fc"><i>2290</i>&nbsp;    }</b>
<i>2291</i>&nbsp;
<b class="fc"><i>2292</i>&nbsp;    private enum DirtyBits {</b>
<b class="fc"><i>2293</i>&nbsp;        FILL_DIRTY,</b>
<b class="fc"><i>2294</i>&nbsp;        ROOT_DIRTY,</b>
<b class="fc"><i>2295</i>&nbsp;        CAMERA_DIRTY,</b>
<b class="fc"><i>2296</i>&nbsp;        LIGHTS_DIRTY,</b>
<b class="fc"><i>2297</i>&nbsp;        CURSOR_DIRTY;</b>
<i>2298</i>&nbsp;
<i>2299</i>&nbsp;        private int mask;
<i>2300</i>&nbsp;
<i>2301</i>&nbsp;        private DirtyBits() {
<i>2302</i>&nbsp;            mask = 1 &lt;&lt; ordinal();
<i>2303</i>&nbsp;        }
<i>2304</i>&nbsp;
<b class="fc"><i>2305</i>&nbsp;        public final int getMask() { return mask; }</b>
<i>2306</i>&nbsp;    }
<i>2307</i>&nbsp;
<b class="fc"><i>2308</i>&nbsp;    private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();</b>
<i>2309</i>&nbsp;
<i>2310</i>&nbsp;    // @param light must not be null
<i>2311</i>&nbsp;    final void addLight(LightBase light) {
<b class="nc"><i>2312</i>&nbsp;        if (!lights.contains(light)) {</b>
<b class="nc"><i>2313</i>&nbsp;            lights.add(light);</b>
<b class="nc"><i>2314</i>&nbsp;            markDirty(DirtyBits.LIGHTS_DIRTY);</b>
<i>2315</i>&nbsp;        }
<b class="nc"><i>2316</i>&nbsp;    }</b>
<i>2317</i>&nbsp;
<i>2318</i>&nbsp;    final void removeLight(LightBase light) {
<b class="nc"><i>2319</i>&nbsp;        if (lights.remove(light)) {</b>
<b class="nc"><i>2320</i>&nbsp;            markDirty(DirtyBits.LIGHTS_DIRTY);</b>
<i>2321</i>&nbsp;        }
<b class="nc"><i>2322</i>&nbsp;    }</b>
<i>2323</i>&nbsp;
<i>2324</i>&nbsp;    /**
<i>2325</i>&nbsp;     * PG Light synchronizer.
<i>2326</i>&nbsp;     */
<i>2327</i>&nbsp;    private void syncLights() {
<b class="fc"><i>2328</i>&nbsp;        if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {</b>
<b class="fc"><i>2329</i>&nbsp;            return;</b>
<i>2330</i>&nbsp;        }
<b class="nc"><i>2331</i>&nbsp;        inSynchronizer = true;</b>
<b class="nc"><i>2332</i>&nbsp;        NGLightBase peerLights[] = peer.getLights();</b>
<b class="nc"><i>2333</i>&nbsp;        if (!lights.isEmpty() || (peerLights != null)) {</b>
<b class="nc"><i>2334</i>&nbsp;            if (lights.isEmpty()) {</b>
<b class="nc"><i>2335</i>&nbsp;                peer.setLights(null);</b>
<i>2336</i>&nbsp;            } else {
<b class="nc"><i>2337</i>&nbsp;                if (peerLights == null || peerLights.length &lt; lights.size()) {</b>
<b class="nc"><i>2338</i>&nbsp;                    peerLights = new NGLightBase[lights.size()];</b>
<i>2339</i>&nbsp;                }
<b class="nc"><i>2340</i>&nbsp;                int i = 0;</b>
<b class="nc"><i>2341</i>&nbsp;                for (; i &lt; lights.size(); i++) {</b>
<b class="nc"><i>2342</i>&nbsp;                    peerLights[i] = lights.get(i).getPeer();</b>
<i>2343</i>&nbsp;                }
<i>2344</i>&nbsp;                // Clear the rest of the list
<b class="nc"><i>2345</i>&nbsp;                while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {</b>
<b class="nc"><i>2346</i>&nbsp;                    peerLights[i++] = null;</b>
<i>2347</i>&nbsp;                }
<b class="nc"><i>2348</i>&nbsp;                peer.setLights(peerLights);</b>
<i>2349</i>&nbsp;            }
<i>2350</i>&nbsp;        }
<b class="nc"><i>2351</i>&nbsp;        inSynchronizer = false;</b>
<b class="nc"><i>2352</i>&nbsp;    }</b>
<i>2353</i>&nbsp;
<i>2354</i>&nbsp;    //INNER CLASSES
<i>2355</i>&nbsp;
<i>2356</i>&nbsp;    /*******************************************************************************
<i>2357</i>&nbsp;     *                                                                             *
<i>2358</i>&nbsp;     * Scene Pulse Listener                                                        *
<i>2359</i>&nbsp;     *                                                                             *
<i>2360</i>&nbsp;     ******************************************************************************/
<i>2361</i>&nbsp;
<b class="fc"><i>2362</i>&nbsp;    class ScenePulseListener implements TKPulseListener {</b>
<i>2363</i>&nbsp;
<b class="fc"><i>2364</i>&nbsp;        private boolean firstPulse = true;</b>
<i>2365</i>&nbsp;
<i>2366</i>&nbsp;        /**
<i>2367</i>&nbsp;         * PG synchronizer. Called once per frame from the pulse listener.
<i>2368</i>&nbsp;         * This function calls the synchronizePGNode method on each node in
<i>2369</i>&nbsp;         * the dirty list.
<i>2370</i>&nbsp;         */
<i>2371</i>&nbsp;        private void synchronizeSceneNodes() {
<b class="fc"><i>2372</i>&nbsp;            Toolkit.getToolkit().checkFxUserThread();</b>
<i>2373</i>&nbsp;
<b class="fc"><i>2374</i>&nbsp;            Scene.inSynchronizer = true;</b>
<i>2375</i>&nbsp;
<i>2376</i>&nbsp;            // if dirtyNodes is null then that means this Scene has not yet been
<i>2377</i>&nbsp;            // synchronized, and so we will simply synchronize every node in the
<i>2378</i>&nbsp;            // scene and then create the dirty nodes array list
<b class="fc"><i>2379</i>&nbsp;            if (Scene.this.dirtyNodes == null) {</b>
<i>2380</i>&nbsp;                // must do this recursively
<b class="fc"><i>2381</i>&nbsp;                syncAll(getRoot());</b>
<b class="fc"><i>2382</i>&nbsp;                dirtyNodes = new Node[MIN_DIRTY_CAPACITY];</b>
<i>2383</i>&nbsp;
<i>2384</i>&nbsp;            } else {
<i>2385</i>&nbsp;                // This is not the first time this scene has been synchronized,
<i>2386</i>&nbsp;                // so we will only synchronize those nodes that need it
<b class="fc"><i>2387</i>&nbsp;                for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {</b>
<b class="fc"><i>2388</i>&nbsp;                    Node node = dirtyNodes[i];</b>
<b class="fc"><i>2389</i>&nbsp;                    dirtyNodes[i] = null;</b>
<b class="fc"><i>2390</i>&nbsp;                    if (node.getScene() == Scene.this) {</b>
<b class="fc"><i>2391</i>&nbsp;                            node.syncPeer();</b>
<i>2392</i>&nbsp;                        }
<i>2393</i>&nbsp;                    }
<b class="fc"><i>2394</i>&nbsp;                dirtyNodesSize = 0;</b>
<i>2395</i>&nbsp;            }
<i>2396</i>&nbsp;
<b class="fc"><i>2397</i>&nbsp;            Scene.inSynchronizer = false;</b>
<b class="fc"><i>2398</i>&nbsp;        }</b>
<i>2399</i>&nbsp;
<i>2400</i>&nbsp;        /**
<i>2401</i>&nbsp;         * Recursive function for synchronizing every node in the scenegraph.
<i>2402</i>&nbsp;         * The return value is the number of nodes in the graph.
<i>2403</i>&nbsp;         */
<i>2404</i>&nbsp;        private int syncAll(Node node) {
<b class="fc"><i>2405</i>&nbsp;            node.syncPeer();</b>
<b class="fc"><i>2406</i>&nbsp;            int size = 1;</b>
<b class="fc"><i>2407</i>&nbsp;            if (node instanceof Parent) {</b>
<b class="fc"><i>2408</i>&nbsp;                Parent p = (Parent) node;</b>
<b class="fc"><i>2409</i>&nbsp;                final int childrenCount = p.getChildren().size();</b>
<i>2410</i>&nbsp;
<b class="fc"><i>2411</i>&nbsp;                for (int i = 0; i &lt; childrenCount; i++) {</b>
<b class="fc"><i>2412</i>&nbsp;                    Node n = p.getChildren().get(i);</b>
<b class="fc"><i>2413</i>&nbsp;                    if (n != null) {</b>
<b class="fc"><i>2414</i>&nbsp;                        size += syncAll(n);</b>
<i>2415</i>&nbsp;                    }
<i>2416</i>&nbsp;                }
<b class="fc"><i>2417</i>&nbsp;            } else if (node instanceof SubScene) {</b>
<b class="nc"><i>2418</i>&nbsp;                SubScene subScene = (SubScene)node;</b>
<b class="nc"><i>2419</i>&nbsp;                size += syncAll(subScene.getRoot());</b>
<i>2420</i>&nbsp;            }
<b class="fc"><i>2421</i>&nbsp;            if (node.getClip() != null) {</b>
<b class="fc"><i>2422</i>&nbsp;                size += syncAll(node.getClip());</b>
<i>2423</i>&nbsp;            }
<i>2424</i>&nbsp;
<b class="fc"><i>2425</i>&nbsp;            return size;</b>
<i>2426</i>&nbsp;        }
<i>2427</i>&nbsp;
<i>2428</i>&nbsp;        private void synchronizeSceneProperties() {
<b class="fc"><i>2429</i>&nbsp;            inSynchronizer = true;</b>
<b class="fc"><i>2430</i>&nbsp;            if (isDirty(DirtyBits.ROOT_DIRTY)) {</b>
<b class="fc"><i>2431</i>&nbsp;                peer.setRoot(getRoot().getPeer());</b>
<i>2432</i>&nbsp;            }
<i>2433</i>&nbsp;
<b class="fc"><i>2434</i>&nbsp;            if (isDirty(DirtyBits.FILL_DIRTY)) {</b>
<b class="fc"><i>2435</i>&nbsp;                Toolkit tk = Toolkit.getToolkit();</b>
<b class="fc"><i>2436</i>&nbsp;                peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));</b>
<i>2437</i>&nbsp;            }
<i>2438</i>&nbsp;
<i>2439</i>&nbsp;            // new camera was set on the scene or old camera changed
<b class="fc"><i>2440</i>&nbsp;            final Camera cam = getEffectiveCamera();</b>
<b class="fc"><i>2441</i>&nbsp;            if (isDirty(DirtyBits.CAMERA_DIRTY)) {</b>
<b class="fc"><i>2442</i>&nbsp;                NodeHelper.updatePeer(cam);</b>
<b class="fc"><i>2443</i>&nbsp;                peer.setCamera((NGCamera) cam.getPeer());</b>
<i>2444</i>&nbsp;            }
<i>2445</i>&nbsp;
<b class="fc"><i>2446</i>&nbsp;            if (isDirty(DirtyBits.CURSOR_DIRTY)) {</b>
<b class="fc"><i>2447</i>&nbsp;                mouseHandler.updateCursor(getCursor());</b>
<b class="fc"><i>2448</i>&nbsp;                mouseHandler.updateCursorFrame();</b>
<i>2449</i>&nbsp;            }
<i>2450</i>&nbsp;
<b class="fc"><i>2451</i>&nbsp;            clearDirty();</b>
<b class="fc"><i>2452</i>&nbsp;            inSynchronizer = false;</b>
<b class="fc"><i>2453</i>&nbsp;        }</b>
<i>2454</i>&nbsp;
<i>2455</i>&nbsp;        /**
<i>2456</i>&nbsp;         * The focus is considered dirty if something happened to
<i>2457</i>&nbsp;         * the scene graph that may require the focus to be moved.
<i>2458</i>&nbsp;         * This must handle cases where (a) the focus owner may have
<i>2459</i>&nbsp;         * become ineligible to have the focus, and (b) where the focus
<i>2460</i>&nbsp;         * owner is null and a node may have become traversable and eligible.
<i>2461</i>&nbsp;         */
<i>2462</i>&nbsp;        private void focusCleanup() {
<b class="fc"><i>2463</i>&nbsp;            if (Scene.this.isFocusDirty()) {</b>
<b class="fc"><i>2464</i>&nbsp;                final Node oldOwner = Scene.this.getFocusOwner();</b>
<b class="fc"><i>2465</i>&nbsp;                if (oldOwner == null) {</b>
<b class="fc"><i>2466</i>&nbsp;                    Scene.this.focusInitial();</b>
<b class="fc"><i>2467</i>&nbsp;                } else if (oldOwner.getScene() != Scene.this) {</b>
<b class="nc"><i>2468</i>&nbsp;                    Scene.this.requestFocus(null);</b>
<b class="nc"><i>2469</i>&nbsp;                    Scene.this.focusInitial();</b>
<b class="fc"><i>2470</i>&nbsp;                } else if (!oldOwner.isCanReceiveFocus()) {</b>
<b class="fc"><i>2471</i>&nbsp;                    Scene.this.requestFocus(null);</b>
<b class="fc"><i>2472</i>&nbsp;                    Scene.this.focusIneligible(oldOwner);</b>
<i>2473</i>&nbsp;                }
<b class="fc"><i>2474</i>&nbsp;                Scene.this.setFocusDirty(false);</b>
<i>2475</i>&nbsp;            }
<b class="fc"><i>2476</i>&nbsp;        }</b>
<i>2477</i>&nbsp;
<i>2478</i>&nbsp;        @Override
<i>2479</i>&nbsp;        public void pulse() {
<b class="fc"><i>2480</i>&nbsp;            if (Scene.this.tracker != null) {</b>
<b class="nc"><i>2481</i>&nbsp;                Scene.this.tracker.pulse();</b>
<i>2482</i>&nbsp;            }
<b class="fc"><i>2483</i>&nbsp;            if (firstPulse) {</b>
<b class="fc"><i>2484</i>&nbsp;                PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);</b>
<i>2485</i>&nbsp;            }
<i>2486</i>&nbsp;
<b class="fc"><i>2487</i>&nbsp;            focusCleanup();</b>
<i>2488</i>&nbsp;
<b class="fc"><i>2489</i>&nbsp;            disposeAccessibles();</b>
<i>2490</i>&nbsp;
<i>2491</i>&nbsp;            // run any scene pre pulse listeners immediately _before_ css / layout,
<i>2492</i>&nbsp;            // and before scene synchronization
<b class="fc"><i>2493</i>&nbsp;            if (preLayoutPulseListeners != null) {</b>
<b class="nc"><i>2494</i>&nbsp;                for (Runnable r : preLayoutPulseListeners) {</b>
<b class="nc"><i>2495</i>&nbsp;                    r.run();</b>
<b class="nc"><i>2496</i>&nbsp;                }</b>
<i>2497</i>&nbsp;            }
<i>2498</i>&nbsp;
<b class="fc"><i>2499</i>&nbsp;            if (PULSE_LOGGING_ENABLED) {</b>
<b class="nc"><i>2500</i>&nbsp;                PulseLogger.newPhase(&quot;CSS Pass&quot;);</b>
<i>2501</i>&nbsp;            }
<b class="fc"><i>2502</i>&nbsp;            Scene.this.doCSSPass();</b>
<i>2503</i>&nbsp;
<b class="fc"><i>2504</i>&nbsp;            if (PULSE_LOGGING_ENABLED) {</b>
<b class="nc"><i>2505</i>&nbsp;                PulseLogger.newPhase(&quot;Layout Pass&quot;);</b>
<i>2506</i>&nbsp;            }
<b class="fc"><i>2507</i>&nbsp;            Scene.this.doLayoutPass();</b>
<i>2508</i>&nbsp;
<i>2509</i>&nbsp;            // run any scene post pulse listeners immediately _after_ css / layout,
<i>2510</i>&nbsp;            // and before scene synchronization
<b class="fc"><i>2511</i>&nbsp;            if (postLayoutPulseListeners != null) {</b>
<b class="nc"><i>2512</i>&nbsp;                for (Runnable r : postLayoutPulseListeners) {</b>
<b class="nc"><i>2513</i>&nbsp;                    r.run();</b>
<b class="nc"><i>2514</i>&nbsp;                }</b>
<i>2515</i>&nbsp;            }
<i>2516</i>&nbsp;
<b class="fc"><i>2517</i>&nbsp;            boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();</b>
<b class="fc"><i>2518</i>&nbsp;            if (dirty) {</b>
<b class="fc"><i>2519</i>&nbsp;                if (PULSE_LOGGING_ENABLED) {</b>
<b class="nc"><i>2520</i>&nbsp;                    PulseLogger.newPhase(&quot;Update bounds&quot;);</b>
<i>2521</i>&nbsp;                }
<b class="fc"><i>2522</i>&nbsp;                getRoot().updateBounds();</b>
<b class="fc"><i>2523</i>&nbsp;                if (peer != null) {</b>
<i>2524</i>&nbsp;                    try {
<b class="fc"><i>2525</i>&nbsp;                        if (PULSE_LOGGING_ENABLED) {</b>
<b class="nc"><i>2526</i>&nbsp;                            PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);</b>
<i>2527</i>&nbsp;                        }
<b class="fc"><i>2528</i>&nbsp;                        peer.waitForRenderingToComplete();</b>
<b class="fc"><i>2529</i>&nbsp;                        peer.waitForSynchronization();</b>
<i>2530</i>&nbsp;                        // synchronize scene properties
<b class="fc"><i>2531</i>&nbsp;                        if (PULSE_LOGGING_ENABLED) {</b>
<b class="nc"><i>2532</i>&nbsp;                            PulseLogger.newPhase(&quot;Copy state to render graph&quot;);</b>
<i>2533</i>&nbsp;                        }
<b class="fc"><i>2534</i>&nbsp;                        syncLights();</b>
<b class="fc"><i>2535</i>&nbsp;                        synchronizeSceneProperties();</b>
<i>2536</i>&nbsp;                        // Run the synchronizer
<b class="fc"><i>2537</i>&nbsp;                        synchronizeSceneNodes();</b>
<b class="fc"><i>2538</i>&nbsp;                        Scene.this.mouseHandler.pulse();</b>
<i>2539</i>&nbsp;                        // Tell the scene peer that it needs to repaint
<b class="fc"><i>2540</i>&nbsp;                        peer.markDirty();</b>
<i>2541</i>&nbsp;                    } finally {
<b class="fc"><i>2542</i>&nbsp;                        peer.releaseSynchronization(true);</b>
<b class="fc"><i>2543</i>&nbsp;                    }</b>
<i>2544</i>&nbsp;                } else {
<b class="nc"><i>2545</i>&nbsp;                    if (PULSE_LOGGING_ENABLED) {</b>
<b class="nc"><i>2546</i>&nbsp;                        PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);</b>
<i>2547</i>&nbsp;                    }
<b class="nc"><i>2548</i>&nbsp;                    synchronizeSceneNodes();</b>
<b class="nc"><i>2549</i>&nbsp;                    Scene.this.mouseHandler.pulse();</b>
<i>2550</i>&nbsp;                }
<i>2551</i>&nbsp;
<b class="fc"><i>2552</i>&nbsp;                if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {</b>
<b class="nc"><i>2553</i>&nbsp;                    NodeHelper.markDirty(Scene.this.getRoot(),</b>
<i>2554</i>&nbsp;                            com.sun.javafx.scene.DirtyBits.NODE_CSS);
<i>2555</i>&nbsp;                }
<i>2556</i>&nbsp;            }
<i>2557</i>&nbsp;
<i>2558</i>&nbsp;            // required for image cursor created from animated image
<b class="fc"><i>2559</i>&nbsp;            Scene.this.mouseHandler.updateCursorFrame();</b>
<i>2560</i>&nbsp;
<b class="fc"><i>2561</i>&nbsp;            if (firstPulse) {</b>
<b class="fc"><i>2562</i>&nbsp;                if (PerformanceTracker.isLoggingEnabled()) {</b>
<b class="nc"><i>2563</i>&nbsp;                    PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);</b>
<b class="nc"><i>2564</i>&nbsp;                    if (PrismSettings.perfLogFirstPaintFlush) {</b>
<b class="nc"><i>2565</i>&nbsp;                        PerformanceTracker.outputLog();</b>
<i>2566</i>&nbsp;                    }
<b class="nc"><i>2567</i>&nbsp;                    if (PrismSettings.perfLogFirstPaintExit) {</b>
<b class="nc"><i>2568</i>&nbsp;                        System.exit(0);</b>
<i>2569</i>&nbsp;                    }
<i>2570</i>&nbsp;                }
<b class="fc"><i>2571</i>&nbsp;                firstPulse = false;</b>
<i>2572</i>&nbsp;            }
<i>2573</i>&nbsp;
<b class="fc"><i>2574</i>&nbsp;            if (testPulseListener != null) {</b>
<b class="nc"><i>2575</i>&nbsp;                testPulseListener.run();</b>
<i>2576</i>&nbsp;            }
<b class="fc"><i>2577</i>&nbsp;        }</b>
<i>2578</i>&nbsp;    }
<i>2579</i>&nbsp;
<i>2580</i>&nbsp;    /*******************************************************************************
<i>2581</i>&nbsp;     *                                                                             *
<i>2582</i>&nbsp;     * Scene Peer Listener                                                         *
<i>2583</i>&nbsp;     *                                                                             *
<i>2584</i>&nbsp;     ******************************************************************************/
<i>2585</i>&nbsp;
<b class="fc"><i>2586</i>&nbsp;    class ScenePeerListener implements TKSceneListener {</b>
<i>2587</i>&nbsp;        @Override
<i>2588</i>&nbsp;        public void changedLocation(float x, float y) {
<b class="fc"><i>2589</i>&nbsp;            if (x != Scene.this.getX()) {</b>
<b class="fc"><i>2590</i>&nbsp;                Scene.this.setX(x);</b>
<i>2591</i>&nbsp;            }
<b class="fc"><i>2592</i>&nbsp;            if (y != Scene.this.getY()) {</b>
<b class="fc"><i>2593</i>&nbsp;                Scene.this.setY(y);</b>
<i>2594</i>&nbsp;            }
<b class="fc"><i>2595</i>&nbsp;        }</b>
<i>2596</i>&nbsp;
<i>2597</i>&nbsp;        @Override
<i>2598</i>&nbsp;        public void changedSize(float w, float h) {
<b class="fc"><i>2599</i>&nbsp;            if (w != Scene.this.getWidth()) Scene.this.setWidth(w);</b>
<b class="fc"><i>2600</i>&nbsp;            if (h != Scene.this.getHeight()) Scene.this.setHeight(h);</b>
<b class="fc"><i>2601</i>&nbsp;        }</b>
<i>2602</i>&nbsp;
<i>2603</i>&nbsp;        @Override
<i>2604</i>&nbsp;        public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
<i>2605</i>&nbsp;                               MouseButton button, boolean popupTrigger, boolean synthesized,
<i>2606</i>&nbsp;                               boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
<i>2607</i>&nbsp;                               boolean primaryDown, boolean middleDown, boolean secondaryDown)
<i>2608</i>&nbsp;        {
<b class="fc"><i>2609</i>&nbsp;            MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,</b>
<i>2610</i>&nbsp;                    0, // click count will be adjusted by clickGenerator later anyway
<i>2611</i>&nbsp;                    shiftDown, controlDown, altDown, metaDown,
<i>2612</i>&nbsp;                    primaryDown, middleDown, secondaryDown, synthesized, popupTrigger, false, null);
<b class="fc"><i>2613</i>&nbsp;            processMouseEvent(mouseEvent);</b>
<b class="fc"><i>2614</i>&nbsp;        }</b>
<i>2615</i>&nbsp;
<i>2616</i>&nbsp;
<i>2617</i>&nbsp;        @Override
<i>2618</i>&nbsp;        public void keyEvent(KeyEvent keyEvent)
<i>2619</i>&nbsp;        {
<b class="fc"><i>2620</i>&nbsp;            processKeyEvent(keyEvent);</b>
<b class="fc"><i>2621</i>&nbsp;        }</b>
<i>2622</i>&nbsp;
<i>2623</i>&nbsp;        @Override
<i>2624</i>&nbsp;        public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
<i>2625</i>&nbsp;                                     ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
<i>2626</i>&nbsp;                                     int caretPosition)
<i>2627</i>&nbsp;        {
<b class="nc"><i>2628</i>&nbsp;            InputMethodEvent inputMethodEvent = new InputMethodEvent(</b>
<i>2629</i>&nbsp;               type, composed, committed, caretPosition);
<b class="nc"><i>2630</i>&nbsp;            processInputMethodEvent(inputMethodEvent);</b>
<b class="nc"><i>2631</i>&nbsp;        }</b>
<i>2632</i>&nbsp;
<i>2633</i>&nbsp;        public void menuEvent(double x, double y, double xAbs, double yAbs,
<i>2634</i>&nbsp;                boolean isKeyboardTrigger) {
<b class="nc"><i>2635</i>&nbsp;            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);</b>
<b class="nc"><i>2636</i>&nbsp;        }</b>
<i>2637</i>&nbsp;
<i>2638</i>&nbsp;        @Override
<i>2639</i>&nbsp;        public void scrollEvent(
<i>2640</i>&nbsp;                EventType&lt;ScrollEvent&gt; eventType,
<i>2641</i>&nbsp;                double scrollX, double scrollY,
<i>2642</i>&nbsp;                double totalScrollX, double totalScrollY,
<i>2643</i>&nbsp;                double xMultiplier, double yMultiplier,
<i>2644</i>&nbsp;                int touchCount,
<i>2645</i>&nbsp;                int scrollTextX, int scrollTextY,
<i>2646</i>&nbsp;                int defaultTextX, int defaultTextY,
<i>2647</i>&nbsp;                double x, double y, double screenX, double screenY,
<i>2648</i>&nbsp;                boolean _shiftDown, boolean _controlDown,
<i>2649</i>&nbsp;                boolean _altDown, boolean _metaDown,
<i>2650</i>&nbsp;                boolean _direct, boolean _inertia) {
<i>2651</i>&nbsp;
<b class="nc"><i>2652</i>&nbsp;            ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?</b>
<b class="nc"><i>2653</i>&nbsp;                    ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :</b>
<b class="nc"><i>2654</i>&nbsp;                    ScrollEvent.HorizontalTextScrollUnits.NONE;</b>
<i>2655</i>&nbsp;
<b class="nc"><i>2656</i>&nbsp;            double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;</b>
<i>2657</i>&nbsp;
<b class="nc"><i>2658</i>&nbsp;            ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?</b>
<b class="nc"><i>2659</i>&nbsp;                    ScrollEvent.VerticalTextScrollUnits.LINES :</b>
<b class="nc"><i>2660</i>&nbsp;                    (scrollTextY &lt; 0 ?</b>
<b class="nc"><i>2661</i>&nbsp;                        ScrollEvent.VerticalTextScrollUnits.PAGES :</b>
<b class="nc"><i>2662</i>&nbsp;                        ScrollEvent.VerticalTextScrollUnits.NONE);</b>
<i>2663</i>&nbsp;
<b class="nc"><i>2664</i>&nbsp;            double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;</b>
<i>2665</i>&nbsp;
<b class="nc"><i>2666</i>&nbsp;            xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0</b>
<b class="nc"><i>2667</i>&nbsp;                    ? Math.round(xMultiplier * scrollTextX / defaultTextX)</b>
<b class="nc"><i>2668</i>&nbsp;                    : xMultiplier;</b>
<i>2669</i>&nbsp;
<b class="nc"><i>2670</i>&nbsp;            yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0</b>
<b class="nc"><i>2671</i>&nbsp;                    ? Math.round(yMultiplier * scrollTextY / defaultTextY)</b>
<b class="nc"><i>2672</i>&nbsp;                    : yMultiplier;</b>
<i>2673</i>&nbsp;
<b class="nc"><i>2674</i>&nbsp;            if (eventType == ScrollEvent.SCROLL_FINISHED) {</b>
<b class="nc"><i>2675</i>&nbsp;                x = scrollGesture.sceneCoords.getX();</b>
<b class="nc"><i>2676</i>&nbsp;                y = scrollGesture.sceneCoords.getY();</b>
<b class="nc"><i>2677</i>&nbsp;                screenX = scrollGesture.screenCoords.getX();</b>
<b class="nc"><i>2678</i>&nbsp;                screenY = scrollGesture.screenCoords.getY();</b>
<b class="nc"><i>2679</i>&nbsp;            } else if (Double.isNaN(x) || Double.isNaN(y) ||</b>
<b class="nc"><i>2680</i>&nbsp;                    Double.isNaN(screenX) || Double.isNaN(screenY)) {</b>
<b class="nc"><i>2681</i>&nbsp;                if (cursorScenePos == null || cursorScreenPos == null) {</b>
<b class="nc"><i>2682</i>&nbsp;                    return;</b>
<i>2683</i>&nbsp;                }
<b class="nc"><i>2684</i>&nbsp;                x = cursorScenePos.getX();</b>
<b class="nc"><i>2685</i>&nbsp;                y = cursorScenePos.getY();</b>
<b class="nc"><i>2686</i>&nbsp;                screenX = cursorScreenPos.getX();</b>
<b class="nc"><i>2687</i>&nbsp;                screenY = cursorScreenPos.getY();</b>
<i>2688</i>&nbsp;            }
<i>2689</i>&nbsp;
<b class="nc"><i>2690</i>&nbsp;            inMousePick = true;</b>
<b class="nc"><i>2691</i>&nbsp;            Scene.this.processGestureEvent(new ScrollEvent(</b>
<i>2692</i>&nbsp;                    eventType,
<i>2693</i>&nbsp;                    x, y, screenX, screenY,
<i>2694</i>&nbsp;                    _shiftDown, _controlDown, _altDown, _metaDown,
<i>2695</i>&nbsp;                    _direct, _inertia,
<i>2696</i>&nbsp;                    scrollX * xMultiplier, scrollY * yMultiplier,
<i>2697</i>&nbsp;                    totalScrollX * xMultiplier, totalScrollY * yMultiplier,
<i>2698</i>&nbsp;                    xMultiplier, yMultiplier,
<b class="nc"><i>2699</i>&nbsp;                    xUnits, xText, yUnits, yText, touchCount, pick(x, y)),</b>
<b class="nc"><i>2700</i>&nbsp;                    scrollGesture);</b>
<b class="nc"><i>2701</i>&nbsp;            inMousePick = false;</b>
<b class="nc"><i>2702</i>&nbsp;        }</b>
<i>2703</i>&nbsp;
<i>2704</i>&nbsp;        @Override
<i>2705</i>&nbsp;        public void zoomEvent(
<i>2706</i>&nbsp;                EventType&lt;ZoomEvent&gt; eventType,
<i>2707</i>&nbsp;                double zoomFactor, double totalZoomFactor,
<i>2708</i>&nbsp;                double x, double y, double screenX, double screenY,
<i>2709</i>&nbsp;                boolean _shiftDown, boolean _controlDown,
<i>2710</i>&nbsp;                boolean _altDown, boolean _metaDown,
<i>2711</i>&nbsp;                boolean _direct, boolean _inertia) {
<i>2712</i>&nbsp;
<b class="nc"><i>2713</i>&nbsp;            if (eventType == ZoomEvent.ZOOM_FINISHED) {</b>
<b class="nc"><i>2714</i>&nbsp;                x = zoomGesture.sceneCoords.getX();</b>
<b class="nc"><i>2715</i>&nbsp;                y = zoomGesture.sceneCoords.getY();</b>
<b class="nc"><i>2716</i>&nbsp;                screenX = zoomGesture.screenCoords.getX();</b>
<b class="nc"><i>2717</i>&nbsp;                screenY = zoomGesture.screenCoords.getY();</b>
<b class="nc"><i>2718</i>&nbsp;            } else if (Double.isNaN(x) || Double.isNaN(y) ||</b>
<b class="nc"><i>2719</i>&nbsp;                    Double.isNaN(screenX) || Double.isNaN(screenY)) {</b>
<b class="nc"><i>2720</i>&nbsp;                if (cursorScenePos == null || cursorScreenPos == null) {</b>
<b class="nc"><i>2721</i>&nbsp;                    return;</b>
<i>2722</i>&nbsp;                }
<b class="nc"><i>2723</i>&nbsp;                x = cursorScenePos.getX();</b>
<b class="nc"><i>2724</i>&nbsp;                y = cursorScenePos.getY();</b>
<b class="nc"><i>2725</i>&nbsp;                screenX = cursorScreenPos.getX();</b>
<b class="nc"><i>2726</i>&nbsp;                screenY = cursorScreenPos.getY();</b>
<i>2727</i>&nbsp;            }
<i>2728</i>&nbsp;
<b class="nc"><i>2729</i>&nbsp;            inMousePick = true;</b>
<b class="nc"><i>2730</i>&nbsp;            Scene.this.processGestureEvent(new ZoomEvent(eventType,</b>
<i>2731</i>&nbsp;                    x, y, screenX, screenY,
<i>2732</i>&nbsp;                    _shiftDown, _controlDown, _altDown, _metaDown,
<i>2733</i>&nbsp;                    _direct, _inertia,
<b class="nc"><i>2734</i>&nbsp;                    zoomFactor, totalZoomFactor, pick(x, y)),</b>
<b class="nc"><i>2735</i>&nbsp;                    zoomGesture);</b>
<b class="nc"><i>2736</i>&nbsp;            inMousePick = false;</b>
<b class="nc"><i>2737</i>&nbsp;        }</b>
<i>2738</i>&nbsp;
<i>2739</i>&nbsp;        @Override
<i>2740</i>&nbsp;        public void rotateEvent(
<i>2741</i>&nbsp;                EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
<i>2742</i>&nbsp;                double x, double y, double screenX, double screenY,
<i>2743</i>&nbsp;                boolean _shiftDown, boolean _controlDown,
<i>2744</i>&nbsp;                boolean _altDown, boolean _metaDown,
<i>2745</i>&nbsp;                boolean _direct, boolean _inertia) {
<i>2746</i>&nbsp;
<b class="nc"><i>2747</i>&nbsp;            if (eventType == RotateEvent.ROTATION_FINISHED) {</b>
<b class="nc"><i>2748</i>&nbsp;                x = rotateGesture.sceneCoords.getX();</b>
<b class="nc"><i>2749</i>&nbsp;                y = rotateGesture.sceneCoords.getY();</b>
<b class="nc"><i>2750</i>&nbsp;                screenX = rotateGesture.screenCoords.getX();</b>
<b class="nc"><i>2751</i>&nbsp;                screenY = rotateGesture.screenCoords.getY();</b>
<b class="nc"><i>2752</i>&nbsp;            } else if (Double.isNaN(x) || Double.isNaN(y) ||</b>
<b class="nc"><i>2753</i>&nbsp;                    Double.isNaN(screenX) || Double.isNaN(screenY)) {</b>
<b class="nc"><i>2754</i>&nbsp;                if (cursorScenePos == null || cursorScreenPos == null) {</b>
<b class="nc"><i>2755</i>&nbsp;                    return;</b>
<i>2756</i>&nbsp;                }
<b class="nc"><i>2757</i>&nbsp;                x = cursorScenePos.getX();</b>
<b class="nc"><i>2758</i>&nbsp;                y = cursorScenePos.getY();</b>
<b class="nc"><i>2759</i>&nbsp;                screenX = cursorScreenPos.getX();</b>
<b class="nc"><i>2760</i>&nbsp;                screenY = cursorScreenPos.getY();</b>
<i>2761</i>&nbsp;            }
<i>2762</i>&nbsp;
<b class="nc"><i>2763</i>&nbsp;            inMousePick = true;</b>
<b class="nc"><i>2764</i>&nbsp;            Scene.this.processGestureEvent(new RotateEvent(</b>
<i>2765</i>&nbsp;                    eventType, x, y, screenX, screenY,
<i>2766</i>&nbsp;                    _shiftDown, _controlDown, _altDown, _metaDown,
<b class="nc"><i>2767</i>&nbsp;                    _direct, _inertia, angle, totalAngle, pick(x, y)),</b>
<b class="nc"><i>2768</i>&nbsp;                    rotateGesture);</b>
<b class="nc"><i>2769</i>&nbsp;            inMousePick = false;</b>
<i>2770</i>&nbsp;
<b class="nc"><i>2771</i>&nbsp;        }</b>
<i>2772</i>&nbsp;
<i>2773</i>&nbsp;        @Override
<i>2774</i>&nbsp;        public void swipeEvent(
<i>2775</i>&nbsp;                EventType&lt;SwipeEvent&gt; eventType, int touchCount,
<i>2776</i>&nbsp;                double x, double y, double screenX, double screenY,
<i>2777</i>&nbsp;                boolean _shiftDown, boolean _controlDown,
<i>2778</i>&nbsp;                boolean _altDown, boolean _metaDown, boolean _direct) {
<i>2779</i>&nbsp;
<b class="nc"><i>2780</i>&nbsp;            if (Double.isNaN(x) || Double.isNaN(y) ||</b>
<b class="nc"><i>2781</i>&nbsp;                    Double.isNaN(screenX) || Double.isNaN(screenY)) {</b>
<b class="nc"><i>2782</i>&nbsp;                if (cursorScenePos == null || cursorScreenPos == null) {</b>
<b class="nc"><i>2783</i>&nbsp;                    return;</b>
<i>2784</i>&nbsp;                }
<b class="nc"><i>2785</i>&nbsp;                x = cursorScenePos.getX();</b>
<b class="nc"><i>2786</i>&nbsp;                y = cursorScenePos.getY();</b>
<b class="nc"><i>2787</i>&nbsp;                screenX = cursorScreenPos.getX();</b>
<b class="nc"><i>2788</i>&nbsp;                screenY = cursorScreenPos.getY();</b>
<i>2789</i>&nbsp;            }
<i>2790</i>&nbsp;
<b class="nc"><i>2791</i>&nbsp;            inMousePick = true;</b>
<b class="nc"><i>2792</i>&nbsp;            Scene.this.processGestureEvent(new SwipeEvent(</b>
<i>2793</i>&nbsp;                    eventType, x, y, screenX, screenY,
<i>2794</i>&nbsp;                    _shiftDown, _controlDown, _altDown, _metaDown, _direct,
<b class="nc"><i>2795</i>&nbsp;                    touchCount, pick(x, y)),</b>
<b class="nc"><i>2796</i>&nbsp;                    swipeGesture);</b>
<b class="nc"><i>2797</i>&nbsp;            inMousePick = false;</b>
<b class="nc"><i>2798</i>&nbsp;        }</b>
<i>2799</i>&nbsp;
<i>2800</i>&nbsp;        @Override
<i>2801</i>&nbsp;        public void touchEventBegin(
<i>2802</i>&nbsp;                long time, int touchCount, boolean isDirect,
<i>2803</i>&nbsp;                boolean _shiftDown, boolean _controlDown,
<i>2804</i>&nbsp;                boolean _altDown, boolean _metaDown) {
<i>2805</i>&nbsp;
<b class="nc"><i>2806</i>&nbsp;            if (!isDirect) {</b>
<b class="nc"><i>2807</i>&nbsp;                nextTouchEvent = null;</b>
<b class="nc"><i>2808</i>&nbsp;                return;</b>
<i>2809</i>&nbsp;            }
<b class="nc"><i>2810</i>&nbsp;            nextTouchEvent = new TouchEvent(</b>
<i>2811</i>&nbsp;                    TouchEvent.ANY, null, null, 0,
<i>2812</i>&nbsp;                    _shiftDown, _controlDown, _altDown, _metaDown);
<b class="nc"><i>2813</i>&nbsp;            if (touchPoints == null || touchPoints.length != touchCount) {</b>
<b class="nc"><i>2814</i>&nbsp;                touchPoints = new TouchPoint[touchCount];</b>
<i>2815</i>&nbsp;            }
<b class="nc"><i>2816</i>&nbsp;            touchPointIndex = 0;</b>
<b class="nc"><i>2817</i>&nbsp;        }</b>
<i>2818</i>&nbsp;
<i>2819</i>&nbsp;        @Override
<i>2820</i>&nbsp;        public void touchEventNext(
<i>2821</i>&nbsp;                TouchPoint.State state, long touchId,
<i>2822</i>&nbsp;                double x, double y, double screenX, double screenY) {
<i>2823</i>&nbsp;
<b class="nc"><i>2824</i>&nbsp;            inMousePick = true;</b>
<b class="nc"><i>2825</i>&nbsp;            if (nextTouchEvent == null) {</b>
<i>2826</i>&nbsp;                // ignore indirect touch events
<b class="nc"><i>2827</i>&nbsp;                return;</b>
<i>2828</i>&nbsp;            }
<b class="nc"><i>2829</i>&nbsp;            touchPointIndex++;</b>
<b class="nc"><i>2830</i>&nbsp;            int id = (state == TouchPoint.State.PRESSED</b>
<b class="nc"><i>2831</i>&nbsp;                    ? touchMap.add(touchId) :  touchMap.get(touchId));</b>
<b class="nc"><i>2832</i>&nbsp;            if (state == TouchPoint.State.RELEASED) {</b>
<b class="nc"><i>2833</i>&nbsp;                touchMap.remove(touchId);</b>
<i>2834</i>&nbsp;            }
<b class="nc"><i>2835</i>&nbsp;            int order = touchMap.getOrder(id);</b>
<i>2836</i>&nbsp;
<b class="nc"><i>2837</i>&nbsp;            if (order &gt;= touchPoints.length) {</b>
<b class="nc"><i>2838</i>&nbsp;                throw new RuntimeException(&quot;Too many touch points reported&quot;);</b>
<i>2839</i>&nbsp;            }
<i>2840</i>&nbsp;
<i>2841</i>&nbsp;            // pick target
<b class="nc"><i>2842</i>&nbsp;            boolean isGrabbed = false;</b>
<b class="nc"><i>2843</i>&nbsp;            PickResult pickRes = pick(x, y);</b>
<b class="nc"><i>2844</i>&nbsp;            EventTarget pickedTarget = touchTargets.get(id);</b>
<b class="nc"><i>2845</i>&nbsp;            if (pickedTarget == null) {</b>
<b class="nc"><i>2846</i>&nbsp;                pickedTarget = pickRes.getIntersectedNode();</b>
<b class="nc"><i>2847</i>&nbsp;                if (pickedTarget == null) {</b>
<b class="nc"><i>2848</i>&nbsp;                    pickedTarget = Scene.this;</b>
<i>2849</i>&nbsp;                }
<i>2850</i>&nbsp;            } else {
<b class="nc"><i>2851</i>&nbsp;                isGrabbed = true;</b>
<i>2852</i>&nbsp;            }
<i>2853</i>&nbsp;
<b class="nc"><i>2854</i>&nbsp;            TouchPoint tp = new TouchPoint(id, state,</b>
<i>2855</i>&nbsp;                    x, y, screenX, screenY, pickedTarget, pickRes);
<i>2856</i>&nbsp;
<b class="nc"><i>2857</i>&nbsp;            touchPoints[order] = tp;</b>
<i>2858</i>&nbsp;
<b class="nc"><i>2859</i>&nbsp;            if (isGrabbed) {</b>
<b class="nc"><i>2860</i>&nbsp;                tp.grab(pickedTarget);</b>
<i>2861</i>&nbsp;            }
<b class="nc"><i>2862</i>&nbsp;            if (tp.getState() == TouchPoint.State.PRESSED) {</b>
<b class="nc"><i>2863</i>&nbsp;                tp.grab(pickedTarget);</b>
<b class="nc"><i>2864</i>&nbsp;                touchTargets.put(tp.getId(), pickedTarget);</b>
<b class="nc"><i>2865</i>&nbsp;            } else if (tp.getState() == TouchPoint.State.RELEASED) {</b>
<b class="nc"><i>2866</i>&nbsp;                touchTargets.remove(tp.getId());</b>
<i>2867</i>&nbsp;            }
<b class="nc"><i>2868</i>&nbsp;            inMousePick = false;</b>
<b class="nc"><i>2869</i>&nbsp;        }</b>
<i>2870</i>&nbsp;
<i>2871</i>&nbsp;        @Override
<i>2872</i>&nbsp;        public void touchEventEnd() {
<b class="nc"><i>2873</i>&nbsp;            if (nextTouchEvent == null) {</b>
<i>2874</i>&nbsp;                // ignore indirect touch events
<b class="nc"><i>2875</i>&nbsp;                return;</b>
<i>2876</i>&nbsp;            }
<i>2877</i>&nbsp;
<b class="nc"><i>2878</i>&nbsp;            if (touchPointIndex != touchPoints.length) {</b>
<b class="nc"><i>2879</i>&nbsp;                throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);</b>
<i>2880</i>&nbsp;            }
<i>2881</i>&nbsp;
<b class="nc"><i>2882</i>&nbsp;            Scene.this.processTouchEvent(nextTouchEvent, touchPoints);</b>
<i>2883</i>&nbsp;
<b class="nc"><i>2884</i>&nbsp;            if (touchMap.cleanup()) {</b>
<i>2885</i>&nbsp;                // gesture finished
<b class="nc"><i>2886</i>&nbsp;                touchEventSetId = 0;</b>
<i>2887</i>&nbsp;            }
<b class="nc"><i>2888</i>&nbsp;        }</b>
<i>2889</i>&nbsp;
<i>2890</i>&nbsp;        @Override
<i>2891</i>&nbsp;        public Accessible getSceneAccessible() {
<b class="nc"><i>2892</i>&nbsp;            return getAccessible();</b>
<i>2893</i>&nbsp;        }
<i>2894</i>&nbsp;    }
<i>2895</i>&nbsp;
<b class="fc"><i>2896</i>&nbsp;    private class ScenePeerPaintListener implements TKScenePaintListener {</b>
<i>2897</i>&nbsp;        @Override
<i>2898</i>&nbsp;        public void frameRendered() {
<i>2899</i>&nbsp;            // must use tracker with synchronization since this method is called on render thread
<b class="fc"><i>2900</i>&nbsp;            synchronized (trackerMonitor) {</b>
<b class="fc"><i>2901</i>&nbsp;                if (Scene.this.tracker != null) {</b>
<b class="nc"><i>2902</i>&nbsp;                    Scene.this.tracker.frameRendered();</b>
<i>2903</i>&nbsp;                }
<b class="fc"><i>2904</i>&nbsp;            }</b>
<b class="fc"><i>2905</i>&nbsp;        }</b>
<i>2906</i>&nbsp;    }
<i>2907</i>&nbsp;
<i>2908</i>&nbsp;    /*******************************************************************************
<i>2909</i>&nbsp;     *                                                                             *
<i>2910</i>&nbsp;     * Drag and Drop                                                               *
<i>2911</i>&nbsp;     *                                                                             *
<i>2912</i>&nbsp;     ******************************************************************************/
<i>2913</i>&nbsp;
<b class="fc"><i>2914</i>&nbsp;    class DropTargetListener implements TKDropTargetListener {</b>
<i>2915</i>&nbsp;
<i>2916</i>&nbsp;        /*
<i>2917</i>&nbsp;         * This function is called when an drag operation enters a valid drop target.
<i>2918</i>&nbsp;         * This may be from either an internal or external dnd operation.
<i>2919</i>&nbsp;         */
<i>2920</i>&nbsp;        @Override
<i>2921</i>&nbsp;        public TransferMode dragEnter(double x, double y, double screenX, double screenY,
<i>2922</i>&nbsp;                                      TransferMode transferMode, TKClipboard dragboard)
<i>2923</i>&nbsp;        {
<b class="nc"><i>2924</i>&nbsp;            if (dndGesture == null) {</b>
<b class="nc"><i>2925</i>&nbsp;                dndGesture = new DnDGesture();</b>
<i>2926</i>&nbsp;            }
<b class="nc"><i>2927</i>&nbsp;            Dragboard db = DragboardHelper.createDragboard(dragboard);</b>
<b class="nc"><i>2928</i>&nbsp;            dndGesture.dragboard = db;</b>
<b class="nc"><i>2929</i>&nbsp;            DragEvent dragEvent =</b>
<b class="nc"><i>2930</i>&nbsp;                    new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,</b>
<b class="nc"><i>2931</i>&nbsp;                            transferMode, null, null, pick(x, y));</b>
<b class="nc"><i>2932</i>&nbsp;            return dndGesture.processTargetEnterOver(dragEvent);</b>
<i>2933</i>&nbsp;        }
<i>2934</i>&nbsp;
<i>2935</i>&nbsp;        @Override
<i>2936</i>&nbsp;        public TransferMode dragOver(double x, double y, double screenX, double screenY,
<i>2937</i>&nbsp;                                     TransferMode transferMode)
<i>2938</i>&nbsp;        {
<b class="nc"><i>2939</i>&nbsp;            if (Scene.this.dndGesture == null) {</b>
<b class="nc"><i>2940</i>&nbsp;                System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);</b>
<b class="nc"><i>2941</i>&nbsp;                return null;</b>
<i>2942</i>&nbsp;            } else {
<b class="nc"><i>2943</i>&nbsp;                if (dndGesture.dragboard == null) {</b>
<b class="nc"><i>2944</i>&nbsp;                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);</b>
<i>2945</i>&nbsp;                }
<b class="nc"><i>2946</i>&nbsp;                DragEvent dragEvent =</b>
<b class="nc"><i>2947</i>&nbsp;                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,</b>
<b class="nc"><i>2948</i>&nbsp;                                transferMode, null, null, pick(x, y));</b>
<b class="nc"><i>2949</i>&nbsp;                return dndGesture.processTargetEnterOver(dragEvent);</b>
<i>2950</i>&nbsp;            }
<i>2951</i>&nbsp;        }
<i>2952</i>&nbsp;
<i>2953</i>&nbsp;        @Override
<i>2954</i>&nbsp;        public void dragExit(double x, double y, double screenX, double screenY) {
<b class="nc"><i>2955</i>&nbsp;            if (dndGesture == null) {</b>
<b class="nc"><i>2956</i>&nbsp;                System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);</b>
<i>2957</i>&nbsp;            } else {
<b class="nc"><i>2958</i>&nbsp;                if (dndGesture.dragboard == null) {</b>
<b class="nc"><i>2959</i>&nbsp;                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);</b>
<i>2960</i>&nbsp;                }
<b class="nc"><i>2961</i>&nbsp;                DragEvent dragEvent =</b>
<b class="nc"><i>2962</i>&nbsp;                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,</b>
<b class="nc"><i>2963</i>&nbsp;                                null, null, null, pick(x, y));</b>
<b class="nc"><i>2964</i>&nbsp;                dndGesture.processTargetExit(dragEvent);</b>
<b class="nc"><i>2965</i>&nbsp;                if (dndGesture.source == null) {</b>
<b class="nc"><i>2966</i>&nbsp;                    dndGesture.dragboard = null;</b>
<b class="nc"><i>2967</i>&nbsp;                    dndGesture = null;</b>
<i>2968</i>&nbsp;                }
<i>2969</i>&nbsp;            }
<b class="nc"><i>2970</i>&nbsp;        }</b>
<i>2971</i>&nbsp;
<i>2972</i>&nbsp;
<i>2973</i>&nbsp;        @Override
<i>2974</i>&nbsp;        public TransferMode drop(double x, double y, double screenX, double screenY,
<i>2975</i>&nbsp;                                  TransferMode transferMode)
<i>2976</i>&nbsp;        {
<b class="nc"><i>2977</i>&nbsp;            if (dndGesture == null) {</b>
<b class="nc"><i>2978</i>&nbsp;                System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);</b>
<b class="nc"><i>2979</i>&nbsp;                return null;</b>
<i>2980</i>&nbsp;            } else {
<b class="nc"><i>2981</i>&nbsp;                if (dndGesture.dragboard == null) {</b>
<b class="nc"><i>2982</i>&nbsp;                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);</b>
<i>2983</i>&nbsp;                }
<b class="nc"><i>2984</i>&nbsp;                DragEvent dragEvent =</b>
<b class="nc"><i>2985</i>&nbsp;                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,</b>
<b class="nc"><i>2986</i>&nbsp;                                transferMode, null, null, pick(x, y));</b>
<i>2987</i>&nbsp;                // Data dropped to the app can be accessed without restriction
<b class="nc"><i>2988</i>&nbsp;                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);</b>
<i>2989</i>&nbsp;
<i>2990</i>&nbsp;                TransferMode tm;
<i>2991</i>&nbsp;                try {
<b class="nc"><i>2992</i>&nbsp;                    tm = dndGesture.processTargetDrop(dragEvent);</b>
<i>2993</i>&nbsp;                } finally {
<b class="nc"><i>2994</i>&nbsp;                    DragboardHelper.setDataAccessRestriction(</b>
<b class="nc"><i>2995</i>&nbsp;                            dndGesture.dragboard, true);</b>
<b class="nc"><i>2996</i>&nbsp;                }</b>
<i>2997</i>&nbsp;
<b class="nc"><i>2998</i>&nbsp;                if (dndGesture.source == null) {</b>
<b class="nc"><i>2999</i>&nbsp;                    dndGesture.dragboard = null;</b>
<b class="nc"><i>3000</i>&nbsp;                    dndGesture = null;</b>
<i>3001</i>&nbsp;                }
<b class="nc"><i>3002</i>&nbsp;                return tm;</b>
<i>3003</i>&nbsp;            }
<i>3004</i>&nbsp;        }
<i>3005</i>&nbsp;    }
<i>3006</i>&nbsp;
<i>3007</i>&nbsp;    class DragGestureListener implements TKDragGestureListener {
<i>3008</i>&nbsp;
<i>3009</i>&nbsp;       @Override
<i>3010</i>&nbsp;       public void dragGestureRecognized(double x, double y, double screenX, double screenY,
<i>3011</i>&nbsp;                                         int button, TKClipboard dragboard)
<i>3012</i>&nbsp;       {
<i>3013</i>&nbsp;           Dragboard db = DragboardHelper.createDragboard(dragboard);
<i>3014</i>&nbsp;           dndGesture = new DnDGesture();
<i>3015</i>&nbsp;           dndGesture.dragboard = db;
<i>3016</i>&nbsp;           // TODO: support mouse buttons in DragEvent
<i>3017</i>&nbsp;           DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
<i>3018</i>&nbsp;                   null, null, null, pick(x, y));
<i>3019</i>&nbsp;           dndGesture.processRecognized(dragEvent);
<i>3020</i>&nbsp;           dndGesture = null;
<i>3021</i>&nbsp;        }
<i>3022</i>&nbsp;    }
<i>3023</i>&nbsp;
<i>3024</i>&nbsp;    /**
<i>3025</i>&nbsp;     * A Drag and Drop gesture has a lifespan that lasts from mouse
<i>3026</i>&nbsp;     * PRESSED event to mouse RELEASED event.
<i>3027</i>&nbsp;     */
<b class="fc"><i>3028</i>&nbsp;    class DnDGesture {</b>
<b class="fc"><i>3029</i>&nbsp;        private final double hysteresisSizeX =</b>
<b class="fc"><i>3030</i>&nbsp;                Toolkit.getToolkit().getMultiClickMaxX();</b>
<b class="fc"><i>3031</i>&nbsp;        private final double hysteresisSizeY =</b>
<b class="fc"><i>3032</i>&nbsp;                Toolkit.getToolkit().getMultiClickMaxY();</b>
<i>3033</i>&nbsp;
<b class="fc"><i>3034</i>&nbsp;        private EventTarget source = null;</b>
<b class="fc"><i>3035</i>&nbsp;        private Set&lt;TransferMode&gt; sourceTransferModes = null;</b>
<b class="fc"><i>3036</i>&nbsp;        private TransferMode acceptedTransferMode = null;</b>
<b class="fc"><i>3037</i>&nbsp;        private Dragboard dragboard = null;</b>
<b class="fc"><i>3038</i>&nbsp;        private EventTarget potentialTarget = null;</b>
<b class="fc"><i>3039</i>&nbsp;        private EventTarget target = null;</b>
<b class="fc"><i>3040</i>&nbsp;        private DragDetectedState dragDetected = DragDetectedState.NOT_YET;</b>
<i>3041</i>&nbsp;        private double pressedX;
<i>3042</i>&nbsp;        private double pressedY;
<b class="fc"><i>3043</i>&nbsp;        private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3044</i>&nbsp;        private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3045</i>&nbsp;        private EventTarget fullPDRSource = null;</b>
<i>3046</i>&nbsp;
<i>3047</i>&nbsp;        /**
<i>3048</i>&nbsp;         * Fires event on a given target or on scene if the node is null
<i>3049</i>&nbsp;         */
<i>3050</i>&nbsp;        private void fireEvent(EventTarget target, Event e) {
<b class="fc"><i>3051</i>&nbsp;            if (target != null) {</b>
<b class="fc"><i>3052</i>&nbsp;                Event.fireEvent(target, e);</b>
<i>3053</i>&nbsp;            }
<b class="fc"><i>3054</i>&nbsp;        }</b>
<i>3055</i>&nbsp;
<i>3056</i>&nbsp;        /**
<i>3057</i>&nbsp;         * Called when DRAG_DETECTED event is going to be processed by
<i>3058</i>&nbsp;         * application
<i>3059</i>&nbsp;         */
<i>3060</i>&nbsp;        private void processingDragDetected() {
<b class="fc"><i>3061</i>&nbsp;            dragDetected = DragDetectedState.PROCESSING;</b>
<b class="fc"><i>3062</i>&nbsp;        }</b>
<i>3063</i>&nbsp;
<i>3064</i>&nbsp;        /**
<i>3065</i>&nbsp;         * Called after DRAG_DETECTED event has been processed by application
<i>3066</i>&nbsp;         */
<i>3067</i>&nbsp;        private void dragDetectedProcessed() {
<b class="fc"><i>3068</i>&nbsp;            dragDetected = DragDetectedState.DONE;</b>
<b class="fc"><i>3069</i>&nbsp;            final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));</b>
<b class="fc"><i>3070</i>&nbsp;            if (hasContent) {</b>
<i>3071</i>&nbsp;                /* start DnD */
<b class="nc"><i>3072</i>&nbsp;                Toolkit.getToolkit().startDrag(Scene.this.peer,</b>
<i>3073</i>&nbsp;                                                sourceTransferModes,
<i>3074</i>&nbsp;                                                new DragSourceListener(),
<i>3075</i>&nbsp;                                                dragboard);
<b class="fc"><i>3076</i>&nbsp;            } else if (fullPDRSource != null) {</b>
<i>3077</i>&nbsp;                /* start PDR */
<b class="nc"><i>3078</i>&nbsp;                Scene.this.mouseHandler.enterFullPDR(fullPDRSource);</b>
<i>3079</i>&nbsp;            }
<i>3080</i>&nbsp;
<b class="fc"><i>3081</i>&nbsp;            fullPDRSource = null;</b>
<b class="fc"><i>3082</i>&nbsp;        }</b>
<i>3083</i>&nbsp;
<i>3084</i>&nbsp;        /**
<i>3085</i>&nbsp;         * Sets the default dragDetect value
<i>3086</i>&nbsp;         */
<i>3087</i>&nbsp;        private void processDragDetection(MouseEvent mouseEvent) {
<i>3088</i>&nbsp;
<b class="fc"><i>3089</i>&nbsp;            if (dragDetected != DragDetectedState.NOT_YET) {</b>
<b class="fc"><i>3090</i>&nbsp;                mouseEvent.setDragDetect(false);</b>
<b class="fc"><i>3091</i>&nbsp;                return;</b>
<i>3092</i>&nbsp;            }
<i>3093</i>&nbsp;
<b class="fc"><i>3094</i>&nbsp;            if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {</b>
<b class="fc"><i>3095</i>&nbsp;                pressedX = mouseEvent.getSceneX();</b>
<b class="fc"><i>3096</i>&nbsp;                pressedY = mouseEvent.getSceneY();</b>
<i>3097</i>&nbsp;
<b class="fc"><i>3098</i>&nbsp;                mouseEvent.setDragDetect(false);</b>
<i>3099</i>&nbsp;
<b class="fc"><i>3100</i>&nbsp;            } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {</b>
<i>3101</i>&nbsp;
<b class="fc"><i>3102</i>&nbsp;                double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);</b>
<b class="fc"><i>3103</i>&nbsp;                double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);</b>
<b class="fc"><i>3104</i>&nbsp;                mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||</b>
<i>3105</i>&nbsp;                                         deltaY &gt; hysteresisSizeY);
<i>3106</i>&nbsp;
<i>3107</i>&nbsp;            }
<b class="fc"><i>3108</i>&nbsp;        }</b>
<i>3109</i>&nbsp;
<i>3110</i>&nbsp;        /**
<i>3111</i>&nbsp;         * This function is useful for drag gesture recognition from
<i>3112</i>&nbsp;         * within this Scene (as opposed to in the TK implementation... by the platform)
<i>3113</i>&nbsp;         */
<i>3114</i>&nbsp;        private boolean process(MouseEvent mouseEvent, EventTarget target) {
<b class="fc"><i>3115</i>&nbsp;            boolean continueProcessing = true;</b>
<i>3116</i>&nbsp;            if (!PLATFORM_DRAG_GESTURE_INITIATION) {
<i>3117</i>&nbsp;
<b class="fc"><i>3118</i>&nbsp;                if (dragDetected != DragDetectedState.DONE &amp;&amp;</b>
<b class="fc"><i>3119</i>&nbsp;                        (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||</b>
<b class="fc"><i>3120</i>&nbsp;                        mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;</b>
<b class="fc"><i>3121</i>&nbsp;                        mouseEvent.isDragDetect()) {</b>
<i>3122</i>&nbsp;
<b class="fc"><i>3123</i>&nbsp;                    processingDragDetected();</b>
<i>3124</i>&nbsp;
<b class="fc"><i>3125</i>&nbsp;                    if (target != null) {</b>
<b class="fc"><i>3126</i>&nbsp;                        final MouseEvent detectedEvent = mouseEvent.copyFor(</b>
<b class="fc"><i>3127</i>&nbsp;                                mouseEvent.getSource(), target,</b>
<i>3128</i>&nbsp;                                MouseEvent.DRAG_DETECTED);
<i>3129</i>&nbsp;
<i>3130</i>&nbsp;                        try {
<b class="fc"><i>3131</i>&nbsp;                            fireEvent(target, detectedEvent);</b>
<i>3132</i>&nbsp;                        } finally {
<i>3133</i>&nbsp;                            // Putting data to dragboard finished, restrict access to them
<b class="fc"><i>3134</i>&nbsp;                            if (dragboard != null) {</b>
<b class="nc"><i>3135</i>&nbsp;                                DragboardHelper.setDataAccessRestriction(</b>
<i>3136</i>&nbsp;                                        dragboard, true);
<i>3137</i>&nbsp;                            }
<i>3138</i>&nbsp;                        }
<i>3139</i>&nbsp;                    }
<i>3140</i>&nbsp;
<b class="fc"><i>3141</i>&nbsp;                    dragDetectedProcessed();</b>
<i>3142</i>&nbsp;                }
<i>3143</i>&nbsp;
<b class="fc"><i>3144</i>&nbsp;                if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {</b>
<b class="fc"><i>3145</i>&nbsp;                    continueProcessing = false;</b>
<i>3146</i>&nbsp;                }
<i>3147</i>&nbsp;            }
<b class="fc"><i>3148</i>&nbsp;            return continueProcessing;</b>
<i>3149</i>&nbsp;        }
<i>3150</i>&nbsp;
<i>3151</i>&nbsp;        /*
<i>3152</i>&nbsp;         * Called when a drag source is recognized. This occurs at the very start of
<i>3153</i>&nbsp;         * the publicly visible drag and drop API, as it is responsible for calling
<i>3154</i>&nbsp;         * the Node.onDragSourceRecognized function.
<i>3155</i>&nbsp;         */
<i>3156</i>&nbsp;        private boolean processRecognized(DragEvent de) {
<b class="nc"><i>3157</i>&nbsp;            MouseEvent me = new MouseEvent(</b>
<b class="nc"><i>3158</i>&nbsp;                    MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),</b>
<b class="nc"><i>3159</i>&nbsp;                    de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,</b>
<i>3160</i>&nbsp;                    false, false, false, false, false, true, false, false, false,
<b class="nc"><i>3161</i>&nbsp;                    false, de.getPickResult());</b>
<i>3162</i>&nbsp;
<b class="nc"><i>3163</i>&nbsp;            processingDragDetected();</b>
<i>3164</i>&nbsp;
<b class="nc"><i>3165</i>&nbsp;            final EventTarget target = de.getPickResult().getIntersectedNode();</b>
<i>3166</i>&nbsp;            try {
<b class="nc"><i>3167</i>&nbsp;                fireEvent(target != null ? target : Scene.this, me);</b>
<i>3168</i>&nbsp;            } finally {
<i>3169</i>&nbsp;                // Putting data to dragboard finished, restrict access to them
<b class="nc"><i>3170</i>&nbsp;                if (dragboard != null) {</b>
<b class="nc"><i>3171</i>&nbsp;                    DragboardHelper.setDataAccessRestriction(</b>
<i>3172</i>&nbsp;                            dragboard, true);
<i>3173</i>&nbsp;                }
<i>3174</i>&nbsp;            }
<i>3175</i>&nbsp;
<b class="nc"><i>3176</i>&nbsp;            dragDetectedProcessed();</b>
<i>3177</i>&nbsp;
<b class="nc"><i>3178</i>&nbsp;            final boolean hasContent = dragboard != null</b>
<b class="nc"><i>3179</i>&nbsp;                    &amp;&amp; !dragboard.getContentTypes().isEmpty();</b>
<b class="nc"><i>3180</i>&nbsp;            return hasContent;</b>
<i>3181</i>&nbsp;        }
<i>3182</i>&nbsp;
<i>3183</i>&nbsp;        private void processDropEnd(DragEvent de) {
<b class="nc"><i>3184</i>&nbsp;            if (source == null) {</b>
<b class="nc"><i>3185</i>&nbsp;                System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);</b>
<b class="nc"><i>3186</i>&nbsp;                return;</b>
<i>3187</i>&nbsp;            }
<i>3188</i>&nbsp;
<b class="nc"><i>3189</i>&nbsp;            de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,</b>
<b class="nc"><i>3190</i>&nbsp;                    de.getDragboard(), de.getSceneX(), de.getSceneY(),</b>
<b class="nc"><i>3191</i>&nbsp;                    de.getScreenX(), de.getScreenY(),</b>
<b class="nc"><i>3192</i>&nbsp;                    de.getTransferMode(), source, target, de.getPickResult());</b>
<i>3193</i>&nbsp;
<b class="nc"><i>3194</i>&nbsp;            Event.fireEvent(source, de);</b>
<i>3195</i>&nbsp;
<b class="nc"><i>3196</i>&nbsp;            tmpTargetWrapper.clear();</b>
<b class="nc"><i>3197</i>&nbsp;            handleExitEnter(de, tmpTargetWrapper);</b>
<i>3198</i>&nbsp;
<i>3199</i>&nbsp;            // at this point the drag and drop operation is completely over, so we
<i>3200</i>&nbsp;            // can tell the toolkit that it can clean up if needs be.
<b class="nc"><i>3201</i>&nbsp;            Toolkit.getToolkit().stopDrag(dragboard);</b>
<b class="nc"><i>3202</i>&nbsp;        }</b>
<i>3203</i>&nbsp;
<i>3204</i>&nbsp;        private TransferMode processTargetEnterOver(DragEvent de) {
<b class="nc"><i>3205</i>&nbsp;            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());</b>
<b class="nc"><i>3206</i>&nbsp;            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();</b>
<i>3207</i>&nbsp;
<b class="nc"><i>3208</i>&nbsp;            if (dragboard == null) {</b>
<b class="nc"><i>3209</i>&nbsp;                dragboard = createDragboard(de, false);</b>
<i>3210</i>&nbsp;            }
<i>3211</i>&nbsp;
<b class="nc"><i>3212</i>&nbsp;            de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),</b>
<b class="nc"><i>3213</i>&nbsp;                    dragboard, de.getSceneX(), de.getSceneY(),</b>
<b class="nc"><i>3214</i>&nbsp;                    de.getScreenX(), de.getScreenY(),</b>
<b class="nc"><i>3215</i>&nbsp;                    de.getTransferMode(), source, potentialTarget, de.getPickResult());</b>
<i>3216</i>&nbsp;
<b class="nc"><i>3217</i>&nbsp;            handleExitEnter(de, tmpTargetWrapper);</b>
<i>3218</i>&nbsp;
<b class="nc"><i>3219</i>&nbsp;            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,</b>
<b class="nc"><i>3220</i>&nbsp;                    de.getDragboard(), de.getSceneX(), de.getSceneY(),</b>
<b class="nc"><i>3221</i>&nbsp;                    de.getScreenX(), de.getScreenY(),</b>
<b class="nc"><i>3222</i>&nbsp;                    de.getTransferMode(), source, potentialTarget, de.getPickResult());</b>
<i>3223</i>&nbsp;
<b class="nc"><i>3224</i>&nbsp;            fireEvent(pickedTarget, de);</b>
<i>3225</i>&nbsp;
<b class="nc"><i>3226</i>&nbsp;            Object acceptingObject = de.getAcceptingObject();</b>
<b class="nc"><i>3227</i>&nbsp;            potentialTarget = acceptingObject instanceof EventTarget</b>
<b class="nc"><i>3228</i>&nbsp;                    ? (EventTarget) acceptingObject : null;</b>
<b class="nc"><i>3229</i>&nbsp;            acceptedTransferMode = de.getAcceptedTransferMode();</b>
<b class="nc"><i>3230</i>&nbsp;            return acceptedTransferMode;</b>
<i>3231</i>&nbsp;        }
<i>3232</i>&nbsp;
<i>3233</i>&nbsp;        private void processTargetActionChanged(DragEvent de) {
<i>3234</i>&nbsp;            // Do we want DRAG_TRANSFER_MODE_CHANGED event?
<i>3235</i>&nbsp;//            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
<i>3236</i>&nbsp;//            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
<i>3237</i>&nbsp;//                de = DragEvent.copy(de.getSource(), pickedNode, source,
<i>3238</i>&nbsp;//                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
<i>3239</i>&nbsp;//
<i>3240</i>&nbsp;//                if (dragboard == null) {
<i>3241</i>&nbsp;//                    dragboard = createDragboard(de);
<i>3242</i>&nbsp;//                }
<i>3243</i>&nbsp;//                dragboard = de.getPlatformDragboard();
<i>3244</i>&nbsp;//
<i>3245</i>&nbsp;//                fireEvent(pickedNode, de);
<i>3246</i>&nbsp;//            }
<b class="nc"><i>3247</i>&nbsp;        }</b>
<i>3248</i>&nbsp;
<i>3249</i>&nbsp;        private void processTargetExit(DragEvent de) {
<b class="nc"><i>3250</i>&nbsp;            if (dragboard == null) {</b>
<i>3251</i>&nbsp;                // dragboard should have been created in processTargetEnterOver()
<b class="nc"><i>3252</i>&nbsp;                throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);</b>
<i>3253</i>&nbsp;            }
<i>3254</i>&nbsp;
<b class="nc"><i>3255</i>&nbsp;            if (currentTargets.size() &gt; 0) {</b>
<b class="nc"><i>3256</i>&nbsp;                potentialTarget = null;</b>
<b class="nc"><i>3257</i>&nbsp;                tmpTargetWrapper.clear();</b>
<b class="nc"><i>3258</i>&nbsp;                handleExitEnter(de, tmpTargetWrapper);</b>
<i>3259</i>&nbsp;            }
<b class="nc"><i>3260</i>&nbsp;        }</b>
<i>3261</i>&nbsp;
<i>3262</i>&nbsp;        private TransferMode processTargetDrop(DragEvent de) {
<b class="nc"><i>3263</i>&nbsp;            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());</b>
<b class="nc"><i>3264</i>&nbsp;            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();</b>
<i>3265</i>&nbsp;
<b class="nc"><i>3266</i>&nbsp;            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,</b>
<b class="nc"><i>3267</i>&nbsp;                    de.getDragboard(), de.getSceneX(), de.getSceneY(),</b>
<b class="nc"><i>3268</i>&nbsp;                    de.getScreenX(), de.getScreenY(),</b>
<b class="nc"><i>3269</i>&nbsp;                    acceptedTransferMode, source, potentialTarget, de.getPickResult());</b>
<i>3270</i>&nbsp;
<b class="nc"><i>3271</i>&nbsp;            if (dragboard == null) {</b>
<i>3272</i>&nbsp;                // dragboard should have been created in processTargetEnterOver()
<b class="nc"><i>3273</i>&nbsp;                throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);</b>
<i>3274</i>&nbsp;            }
<i>3275</i>&nbsp;
<b class="nc"><i>3276</i>&nbsp;            handleExitEnter(de, tmpTargetWrapper);</b>
<i>3277</i>&nbsp;
<b class="nc"><i>3278</i>&nbsp;            fireEvent(pickedTarget, de);</b>
<i>3279</i>&nbsp;
<b class="nc"><i>3280</i>&nbsp;            Object acceptingObject = de.getAcceptingObject();</b>
<b class="nc"><i>3281</i>&nbsp;            potentialTarget = acceptingObject instanceof EventTarget</b>
<b class="nc"><i>3282</i>&nbsp;                    ? (EventTarget) acceptingObject : null;</b>
<b class="nc"><i>3283</i>&nbsp;            target = potentialTarget;</b>
<i>3284</i>&nbsp;
<b class="nc"><i>3285</i>&nbsp;            TransferMode result = de.isDropCompleted() ?</b>
<b class="nc"><i>3286</i>&nbsp;                de.getAcceptedTransferMode() : null;</b>
<i>3287</i>&nbsp;
<b class="nc"><i>3288</i>&nbsp;            tmpTargetWrapper.clear();</b>
<b class="nc"><i>3289</i>&nbsp;            handleExitEnter(de, tmpTargetWrapper);</b>
<i>3290</i>&nbsp;
<b class="nc"><i>3291</i>&nbsp;            return result;</b>
<i>3292</i>&nbsp;        }
<i>3293</i>&nbsp;
<i>3294</i>&nbsp;        private void handleExitEnter(DragEvent e, TargetWrapper target) {
<i>3295</i>&nbsp;            EventTarget currentTarget =
<b class="nc"><i>3296</i>&nbsp;                    currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;</b>
<i>3297</i>&nbsp;
<b class="nc"><i>3298</i>&nbsp;            if (target.getEventTarget() != currentTarget) {</b>
<i>3299</i>&nbsp;
<b class="nc"><i>3300</i>&nbsp;                target.fillHierarchy(newTargets);</b>
<i>3301</i>&nbsp;
<b class="nc"><i>3302</i>&nbsp;                int i = currentTargets.size() - 1;</b>
<b class="nc"><i>3303</i>&nbsp;                int j = newTargets.size() - 1;</b>
<i>3304</i>&nbsp;
<b class="nc"><i>3305</i>&nbsp;                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {</b>
<b class="nc"><i>3306</i>&nbsp;                    i--;</b>
<b class="nc"><i>3307</i>&nbsp;                    j--;</b>
<i>3308</i>&nbsp;                }
<i>3309</i>&nbsp;
<b class="nc"><i>3310</i>&nbsp;                for (; i &gt;= 0; i--) {</b>
<b class="nc"><i>3311</i>&nbsp;                    EventTarget t = currentTargets.get(i);</b>
<b class="nc"><i>3312</i>&nbsp;                    if (potentialTarget == t) {</b>
<b class="nc"><i>3313</i>&nbsp;                        potentialTarget = null;</b>
<i>3314</i>&nbsp;                    }
<b class="nc"><i>3315</i>&nbsp;                    e = e.copyFor(e.getSource(), t, source,</b>
<i>3316</i>&nbsp;                            potentialTarget, DragEvent.DRAG_EXITED_TARGET);
<b class="nc"><i>3317</i>&nbsp;                    Event.fireEvent(t, e);</b>
<i>3318</i>&nbsp;                }
<i>3319</i>&nbsp;
<b class="nc"><i>3320</i>&nbsp;                potentialTarget = null;</b>
<b class="nc"><i>3321</i>&nbsp;                for (; j &gt;= 0; j--) {</b>
<b class="nc"><i>3322</i>&nbsp;                    EventTarget t = newTargets.get(j);</b>
<b class="nc"><i>3323</i>&nbsp;                    e = e.copyFor(e.getSource(), t, source,</b>
<i>3324</i>&nbsp;                            potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
<b class="nc"><i>3325</i>&nbsp;                    Object acceptingObject = e.getAcceptingObject();</b>
<b class="nc"><i>3326</i>&nbsp;                    if (acceptingObject instanceof EventTarget) {</b>
<b class="nc"><i>3327</i>&nbsp;                        potentialTarget = (EventTarget) acceptingObject;</b>
<i>3328</i>&nbsp;                    }
<b class="nc"><i>3329</i>&nbsp;                    Event.fireEvent(t, e);</b>
<i>3330</i>&nbsp;                }
<i>3331</i>&nbsp;
<b class="nc"><i>3332</i>&nbsp;                currentTargets.clear();</b>
<b class="nc"><i>3333</i>&nbsp;                currentTargets.addAll(newTargets);</b>
<b class="nc"><i>3334</i>&nbsp;                newTargets.clear();</b>
<i>3335</i>&nbsp;            }
<b class="nc"><i>3336</i>&nbsp;        }</b>
<i>3337</i>&nbsp;
<i>3338</i>&nbsp;//        function getIntendedTransferMode(e:MouseEvent):TransferMode {
<i>3339</i>&nbsp;//            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
<i>3340</i>&nbsp;//        }
<i>3341</i>&nbsp;
<i>3342</i>&nbsp;        /*
<i>3343</i>&nbsp;         * Function that hooks into the key processing code in Scene to handle the
<i>3344</i>&nbsp;         * situation where a drag and drop event is taking place and the user presses
<i>3345</i>&nbsp;         * the escape key to cancel the drag and drop operation.
<i>3346</i>&nbsp;         */
<i>3347</i>&nbsp;        private boolean processKey(KeyEvent e) {
<i>3348</i>&nbsp;            //note: this seems not to be called, the DnD cancelation is provided by platform
<b class="fc"><i>3349</i>&nbsp;            if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {</b>
<i>3350</i>&nbsp;
<i>3351</i>&nbsp;                // cancel drag and drop
<b class="nc"><i>3352</i>&nbsp;                DragEvent de = new DragEvent(</b>
<i>3353</i>&nbsp;                        source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
<i>3354</i>&nbsp;                        null, source, null, null);
<b class="nc"><i>3355</i>&nbsp;                if (source != null) {</b>
<b class="nc"><i>3356</i>&nbsp;                    Event.fireEvent(source, de);</b>
<i>3357</i>&nbsp;                }
<i>3358</i>&nbsp;
<b class="nc"><i>3359</i>&nbsp;                tmpTargetWrapper.clear();</b>
<b class="nc"><i>3360</i>&nbsp;                handleExitEnter(de, tmpTargetWrapper);</b>
<i>3361</i>&nbsp;
<b class="nc"><i>3362</i>&nbsp;                return false;</b>
<i>3363</i>&nbsp;            }
<b class="fc"><i>3364</i>&nbsp;            return true;</b>
<i>3365</i>&nbsp;        }
<i>3366</i>&nbsp;
<i>3367</i>&nbsp;        /*
<i>3368</i>&nbsp;         * This starts the drag gesture running, creating the dragboard used for
<i>3369</i>&nbsp;         * the remainder of this drag and drop operation.
<i>3370</i>&nbsp;         */
<i>3371</i>&nbsp;        private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
<b class="nc"><i>3372</i>&nbsp;            if (dragDetected != DragDetectedState.PROCESSING) {</b>
<b class="nc"><i>3373</i>&nbsp;                throw new IllegalStateException(&quot;Cannot start drag and drop &quot;</b>
<i>3374</i>&nbsp;                        + &quot;outside of DRAG_DETECTED event handler&quot;);
<i>3375</i>&nbsp;            }
<i>3376</i>&nbsp;
<b class="nc"><i>3377</i>&nbsp;            if (t.isEmpty()) {</b>
<b class="nc"><i>3378</i>&nbsp;                dragboard = null;</b>
<b class="nc"><i>3379</i>&nbsp;            } else if (dragboard == null) {</b>
<b class="nc"><i>3380</i>&nbsp;                dragboard = createDragboard(null, true);</b>
<i>3381</i>&nbsp;            }
<i>3382</i>&nbsp;
<i>3383</i>&nbsp;            // The app can see what it puts to dragboard without restriction
<b class="nc"><i>3384</i>&nbsp;            DragboardHelper.setDataAccessRestriction(dragboard, false);</b>
<i>3385</i>&nbsp;
<b class="nc"><i>3386</i>&nbsp;            this.source = source;</b>
<b class="nc"><i>3387</i>&nbsp;            potentialTarget = source;</b>
<b class="nc"><i>3388</i>&nbsp;            sourceTransferModes = t;</b>
<b class="nc"><i>3389</i>&nbsp;            return dragboard;</b>
<i>3390</i>&nbsp;        }
<i>3391</i>&nbsp;
<i>3392</i>&nbsp;        /*
<i>3393</i>&nbsp;         * This starts the full PDR gesture.
<i>3394</i>&nbsp;         */
<i>3395</i>&nbsp;        private void startFullPDR(EventTarget source) {
<b class="nc"><i>3396</i>&nbsp;            fullPDRSource = source;</b>
<b class="nc"><i>3397</i>&nbsp;        }</b>
<i>3398</i>&nbsp;
<i>3399</i>&nbsp;        private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
<b class="nc"><i>3400</i>&nbsp;            Dragboard dragboard = null;</b>
<b class="nc"><i>3401</i>&nbsp;            if (de != null) {</b>
<b class="nc"><i>3402</i>&nbsp;                dragboard = de.getDragboard();</b>
<b class="nc"><i>3403</i>&nbsp;                if (dragboard != null) {</b>
<b class="nc"><i>3404</i>&nbsp;                    return dragboard;</b>
<i>3405</i>&nbsp;                }
<i>3406</i>&nbsp;            }
<b class="nc"><i>3407</i>&nbsp;            TKClipboard dragboardPeer = peer.createDragboard(isDragSource);</b>
<b class="nc"><i>3408</i>&nbsp;            return DragboardHelper.createDragboard(dragboardPeer);</b>
<i>3409</i>&nbsp;        }
<i>3410</i>&nbsp;    }
<i>3411</i>&nbsp;
<i>3412</i>&nbsp;    /**
<i>3413</i>&nbsp;     * State of a drag gesture with regards to DRAG_DETECTED event.
<i>3414</i>&nbsp;     */
<b class="fc"><i>3415</i>&nbsp;    private enum DragDetectedState {</b>
<b class="fc"><i>3416</i>&nbsp;        NOT_YET,</b>
<b class="fc"><i>3417</i>&nbsp;        PROCESSING,</b>
<b class="fc"><i>3418</i>&nbsp;        DONE</b>
<i>3419</i>&nbsp;    }
<i>3420</i>&nbsp;
<i>3421</i>&nbsp;    class DragSourceListener implements TKDragSourceListener {
<i>3422</i>&nbsp;
<i>3423</i>&nbsp;        @Override
<i>3424</i>&nbsp;        public void dragDropEnd(double x, double y, double screenX, double screenY,
<i>3425</i>&nbsp;                                TransferMode transferMode)
<i>3426</i>&nbsp;        {
<i>3427</i>&nbsp;            if (dndGesture != null) {
<i>3428</i>&nbsp;                if (dndGesture.dragboard == null) {
<i>3429</i>&nbsp;                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
<i>3430</i>&nbsp;                }
<i>3431</i>&nbsp;                DragEvent dragEvent =
<i>3432</i>&nbsp;                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
<i>3433</i>&nbsp;                        transferMode, null, null, null);
<i>3434</i>&nbsp;
<i>3435</i>&nbsp;                // DRAG_DONE event is delivered to gesture source, it can access
<i>3436</i>&nbsp;                // its own data without restriction
<i>3437</i>&nbsp;                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
<i>3438</i>&nbsp;                try {
<i>3439</i>&nbsp;                    dndGesture.processDropEnd(dragEvent);
<i>3440</i>&nbsp;                } finally {
<i>3441</i>&nbsp;                    DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
<i>3442</i>&nbsp;                }
<i>3443</i>&nbsp;                dndGesture = null;
<i>3444</i>&nbsp;            }
<i>3445</i>&nbsp;        }
<i>3446</i>&nbsp;    }
<i>3447</i>&nbsp;
<i>3448</i>&nbsp;    /*******************************************************************************
<i>3449</i>&nbsp;     *                                                                             *
<i>3450</i>&nbsp;     * Mouse Event Handling                                                        *
<i>3451</i>&nbsp;     *                                                                             *
<i>3452</i>&nbsp;     ******************************************************************************/
<i>3453</i>&nbsp;
<b class="fc"><i>3454</i>&nbsp;    static class ClickCounter {</b>
<b class="fc"><i>3455</i>&nbsp;        Toolkit toolkit = Toolkit.getToolkit();</b>
<i>3456</i>&nbsp;        private int count;
<i>3457</i>&nbsp;        private boolean out;
<i>3458</i>&nbsp;        private boolean still;
<i>3459</i>&nbsp;        private Timeline timeout;
<i>3460</i>&nbsp;        private double pressedX, pressedY;
<i>3461</i>&nbsp;
<b class="fc"><i>3462</i>&nbsp;        private void inc() { count++; }</b>
<b class="fc"><i>3463</i>&nbsp;        private int get() { return count; }</b>
<b class="fc"><i>3464</i>&nbsp;        private boolean isStill() { return still; }</b>
<i>3465</i>&nbsp;
<i>3466</i>&nbsp;        private void clear() {
<b class="fc"><i>3467</i>&nbsp;            count = 0;</b>
<b class="fc"><i>3468</i>&nbsp;            stopTimeout();</b>
<b class="fc"><i>3469</i>&nbsp;        }</b>
<i>3470</i>&nbsp;
<i>3471</i>&nbsp;        private void out() {
<b class="fc"><i>3472</i>&nbsp;            out = true;</b>
<b class="fc"><i>3473</i>&nbsp;            stopTimeout();</b>
<b class="fc"><i>3474</i>&nbsp;        }</b>
<i>3475</i>&nbsp;
<i>3476</i>&nbsp;        private void applyOut() {
<b class="fc"><i>3477</i>&nbsp;            if (out) clear();</b>
<b class="fc"><i>3478</i>&nbsp;            out = false;</b>
<b class="fc"><i>3479</i>&nbsp;        }</b>
<i>3480</i>&nbsp;
<i>3481</i>&nbsp;        private void moved(double x, double y) {
<b class="fc"><i>3482</i>&nbsp;            if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||</b>
<b class="fc"><i>3483</i>&nbsp;                    Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {</b>
<b class="fc"><i>3484</i>&nbsp;                out();</b>
<b class="fc"><i>3485</i>&nbsp;                still = false;</b>
<i>3486</i>&nbsp;            }
<b class="fc"><i>3487</i>&nbsp;        }</b>
<i>3488</i>&nbsp;
<i>3489</i>&nbsp;        private void start(double x, double y) {
<b class="fc"><i>3490</i>&nbsp;            pressedX = x;</b>
<b class="fc"><i>3491</i>&nbsp;            pressedY = y;</b>
<b class="fc"><i>3492</i>&nbsp;            out = false;</b>
<i>3493</i>&nbsp;
<b class="fc"><i>3494</i>&nbsp;            if (timeout != null) {</b>
<b class="nc"><i>3495</i>&nbsp;                timeout.stop();</b>
<i>3496</i>&nbsp;            }
<b class="fc"><i>3497</i>&nbsp;            timeout = new Timeline();</b>
<b class="fc"><i>3498</i>&nbsp;            timeout.getKeyFrames().add(</b>
<b class="fc"><i>3499</i>&nbsp;                    new KeyFrame(new Duration(toolkit.getMultiClickTime()),</b>
<i>3500</i>&nbsp;                            event -&gt; {
<b class="fc"><i>3501</i>&nbsp;                                out = true;</b>
<b class="fc"><i>3502</i>&nbsp;                                timeout = null;</b>
<b class="fc"><i>3503</i>&nbsp;                            }</b>
<i>3504</i>&nbsp;                    ));
<b class="fc"><i>3505</i>&nbsp;            timeout.play();</b>
<b class="fc"><i>3506</i>&nbsp;            still = true;</b>
<b class="fc"><i>3507</i>&nbsp;        }</b>
<i>3508</i>&nbsp;
<i>3509</i>&nbsp;        private void stopTimeout() {
<b class="fc"><i>3510</i>&nbsp;            if (timeout != null) {</b>
<b class="fc"><i>3511</i>&nbsp;                timeout.stop();</b>
<b class="fc"><i>3512</i>&nbsp;                timeout = null;</b>
<i>3513</i>&nbsp;            }
<b class="fc"><i>3514</i>&nbsp;        }</b>
<i>3515</i>&nbsp;    }
<i>3516</i>&nbsp;
<b class="fc"><i>3517</i>&nbsp;    static class ClickGenerator {</b>
<b class="fc"><i>3518</i>&nbsp;        private ClickCounter lastPress = null;</b>
<i>3519</i>&nbsp;
<b class="fc"><i>3520</i>&nbsp;        private Map&lt;MouseButton, ClickCounter&gt; counters =</b>
<i>3521</i>&nbsp;                new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
<b class="fc"><i>3522</i>&nbsp;        private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3523</i>&nbsp;        private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();</b>
<i>3524</i>&nbsp;
<b class="fc"><i>3525</i>&nbsp;        public ClickGenerator() {</b>
<b class="fc"><i>3526</i>&nbsp;            for (MouseButton mb : MouseButton.values()) {</b>
<b class="fc"><i>3527</i>&nbsp;                if (mb != MouseButton.NONE) {</b>
<b class="fc"><i>3528</i>&nbsp;                    counters.put(mb, new ClickCounter());</b>
<i>3529</i>&nbsp;                }
<i>3530</i>&nbsp;            }
<b class="fc"><i>3531</i>&nbsp;        }</b>
<i>3532</i>&nbsp;
<i>3533</i>&nbsp;        private MouseEvent preProcess(MouseEvent e) {
<b class="fc"><i>3534</i>&nbsp;            for (ClickCounter cc : counters.values()) {</b>
<b class="fc"><i>3535</i>&nbsp;                cc.moved(e.getSceneX(), e.getSceneY());</b>
<b class="fc"><i>3536</i>&nbsp;            }</b>
<i>3537</i>&nbsp;
<b class="fc"><i>3538</i>&nbsp;            ClickCounter cc = counters.get(e.getButton());</b>
<b class="fc"><i>3539</i>&nbsp;            boolean still = lastPress != null ? lastPress.isStill() : false;</b>
<i>3540</i>&nbsp;
<b class="fc"><i>3541</i>&nbsp;            if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {</b>
<i>3542</i>&nbsp;
<b class="fc"><i>3543</i>&nbsp;                if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }</b>
<b class="fc"><i>3544</i>&nbsp;                if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }</b>
<b class="fc"><i>3545</i>&nbsp;                if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }</b>
<i>3546</i>&nbsp;
<b class="fc"><i>3547</i>&nbsp;                cc.applyOut();</b>
<b class="fc"><i>3548</i>&nbsp;                cc.inc();</b>
<b class="fc"><i>3549</i>&nbsp;                cc.start(e.getSceneX(), e.getSceneY());</b>
<b class="fc"><i>3550</i>&nbsp;                lastPress = cc;</b>
<i>3551</i>&nbsp;            }
<i>3552</i>&nbsp;
<b class="fc"><i>3553</i>&nbsp;            return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),</b>
<b class="fc"><i>3554</i>&nbsp;                    e.getScreenX(), e.getScreenY(), e.getButton(),</b>
<b class="fc"><i>3555</i>&nbsp;                    cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,</b>
<b class="fc"><i>3556</i>&nbsp;                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),</b>
<b class="fc"><i>3557</i>&nbsp;                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),</b>
<b class="fc"><i>3558</i>&nbsp;                    e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());</b>
<i>3559</i>&nbsp;        }
<i>3560</i>&nbsp;
<i>3561</i>&nbsp;        private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {
<i>3562</i>&nbsp;
<b class="fc"><i>3563</i>&nbsp;            if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {</b>
<b class="fc"><i>3564</i>&nbsp;                ClickCounter cc = counters.get(e.getButton());</b>
<i>3565</i>&nbsp;
<b class="fc"><i>3566</i>&nbsp;                target.fillHierarchy(pressedTargets);</b>
<b class="fc"><i>3567</i>&nbsp;                pickedTarget.fillHierarchy(releasedTargets);</b>
<b class="fc"><i>3568</i>&nbsp;                int i = pressedTargets.size() - 1;</b>
<b class="fc"><i>3569</i>&nbsp;                int j = releasedTargets.size() - 1;</b>
<i>3570</i>&nbsp;
<b class="fc"><i>3571</i>&nbsp;                EventTarget clickedTarget = null;</b>
<b class="fc"><i>3572</i>&nbsp;                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {</b>
<b class="fc"><i>3573</i>&nbsp;                    clickedTarget = pressedTargets.get(i);</b>
<b class="fc"><i>3574</i>&nbsp;                    i--;</b>
<b class="fc"><i>3575</i>&nbsp;                    j--;</b>
<i>3576</i>&nbsp;                }
<i>3577</i>&nbsp;
<b class="fc"><i>3578</i>&nbsp;                pressedTargets.clear();</b>
<b class="fc"><i>3579</i>&nbsp;                releasedTargets.clear();</b>
<i>3580</i>&nbsp;
<b class="fc"><i>3581</i>&nbsp;                if (clickedTarget != null &amp;&amp; lastPress != null) {</b>
<b class="fc"><i>3582</i>&nbsp;                    MouseEvent click = new MouseEvent(null, clickedTarget,</b>
<b class="fc"><i>3583</i>&nbsp;                            MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),</b>
<b class="fc"><i>3584</i>&nbsp;                            e.getScreenX(), e.getScreenY(), e.getButton(),</b>
<b class="fc"><i>3585</i>&nbsp;                            cc.get(),</b>
<b class="fc"><i>3586</i>&nbsp;                            e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),</b>
<b class="fc"><i>3587</i>&nbsp;                            e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),</b>
<b class="fc"><i>3588</i>&nbsp;                            e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());</b>
<b class="fc"><i>3589</i>&nbsp;                    Event.fireEvent(clickedTarget, click);</b>
<i>3590</i>&nbsp;                }
<i>3591</i>&nbsp;            }
<b class="fc"><i>3592</i>&nbsp;        }</b>
<i>3593</i>&nbsp;    }
<i>3594</i>&nbsp;
<i>3595</i>&nbsp;    /**
<i>3596</i>&nbsp;     * Generates mouse exited event for a node which is going to be removed
<i>3597</i>&nbsp;     * and its children, where appropriate.
<i>3598</i>&nbsp;     * @param removing Node which is going to be removed
<i>3599</i>&nbsp;     */
<i>3600</i>&nbsp;    void generateMouseExited(Node removing) {
<b class="nc"><i>3601</i>&nbsp;        mouseHandler.handleNodeRemoval(removing);</b>
<b class="nc"><i>3602</i>&nbsp;    }</b>
<i>3603</i>&nbsp;
<b class="fc"><i>3604</i>&nbsp;    class MouseHandler {</b>
<b class="fc"><i>3605</i>&nbsp;        private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release</b>
<b class="fc"><i>3606</i>&nbsp;        private boolean pdrInProgress = false;</b>
<b class="fc"><i>3607</i>&nbsp;        private boolean fullPDREntered = false;</b>
<i>3608</i>&nbsp;
<b class="fc"><i>3609</i>&nbsp;        private EventTarget currentEventTarget = null;</b>
<i>3610</i>&nbsp;        private MouseEvent lastEvent;
<b class="fc"><i>3611</i>&nbsp;        private boolean hover = false;</b>
<i>3612</i>&nbsp;
<b class="fc"><i>3613</i>&nbsp;        private boolean primaryButtonDown = false;</b>
<b class="fc"><i>3614</i>&nbsp;        private boolean secondaryButtonDown = false;</b>
<b class="fc"><i>3615</i>&nbsp;        private boolean middleButtonDown = false;</b>
<i>3616</i>&nbsp;
<b class="fc"><i>3617</i>&nbsp;        private EventTarget fullPDRSource = null;</b>
<b class="fc"><i>3618</i>&nbsp;        private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();</b>
<i>3619</i>&nbsp;
<i>3620</i>&nbsp;        /* lists needed for enter/exit events generation */
<b class="fc"><i>3621</i>&nbsp;        private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3622</i>&nbsp;        private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3623</i>&nbsp;        private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();</b>
<i>3624</i>&nbsp;
<b class="fc"><i>3625</i>&nbsp;        private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3626</i>&nbsp;        private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();</b>
<b class="fc"><i>3627</i>&nbsp;        private EventTarget fullPDRCurrentTarget = null;</b>
<i>3628</i>&nbsp;
<i>3629</i>&nbsp;        private Cursor currCursor;
<i>3630</i>&nbsp;        private CursorFrame currCursorFrame;
<b class="fc"><i>3631</i>&nbsp;        private EventQueue queue = new EventQueue();</b>
<i>3632</i>&nbsp;
<b class="fc"><i>3633</i>&nbsp;        private Runnable pickProcess = new Runnable() {</b>
<i>3634</i>&nbsp;
<i>3635</i>&nbsp;            @Override
<i>3636</i>&nbsp;            public void run() {
<i>3637</i>&nbsp;                // Make sure this is run only if the peer is still alive
<i>3638</i>&nbsp;                // and there is an event to deliver
<b class="fc"><i>3639</i>&nbsp;                if (Scene.this.peer != null &amp;&amp; lastEvent != null) {</b>
<b class="fc"><i>3640</i>&nbsp;                    process(lastEvent, true);</b>
<i>3641</i>&nbsp;                }
<b class="fc"><i>3642</i>&nbsp;            }</b>
<i>3643</i>&nbsp;        };
<i>3644</i>&nbsp;
<i>3645</i>&nbsp;        private void pulse() {
<b class="fc"><i>3646</i>&nbsp;            if (hover &amp;&amp; lastEvent != null) {</b>
<i>3647</i>&nbsp;                //Shouldn&#39;t run user code directly. User can call stage.showAndWait() and block the pulse.
<b class="fc"><i>3648</i>&nbsp;                Platform.runLater(pickProcess);</b>
<i>3649</i>&nbsp;            }
<b class="fc"><i>3650</i>&nbsp;        }</b>
<i>3651</i>&nbsp;
<i>3652</i>&nbsp;        private void clearPDREventTargets() {
<b class="fc"><i>3653</i>&nbsp;            pdrInProgress = false;</b>
<b class="fc"><i>3654</i>&nbsp;            currentEventTarget = currentEventTargets.size() &gt; 0</b>
<b class="fc"><i>3655</i>&nbsp;                    ? currentEventTargets.get(0) : null;</b>
<b class="fc"><i>3656</i>&nbsp;            pdrEventTarget.clear();</b>
<b class="fc"><i>3657</i>&nbsp;        }</b>
<i>3658</i>&nbsp;
<i>3659</i>&nbsp;        public void enterFullPDR(EventTarget gestureSource) {
<b class="nc"><i>3660</i>&nbsp;            fullPDREntered = true;</b>
<b class="nc"><i>3661</i>&nbsp;            fullPDRSource = gestureSource;</b>
<b class="nc"><i>3662</i>&nbsp;            fullPDRCurrentTarget = null;</b>
<b class="nc"><i>3663</i>&nbsp;            fullPDRCurrentEventTargets.clear();</b>
<b class="nc"><i>3664</i>&nbsp;        }</b>
<i>3665</i>&nbsp;
<i>3666</i>&nbsp;        public void exitFullPDR(MouseEvent e) {
<b class="fc"><i>3667</i>&nbsp;            if (!fullPDREntered) {</b>
<b class="fc"><i>3668</i>&nbsp;                return;</b>
<i>3669</i>&nbsp;            }
<b class="nc"><i>3670</i>&nbsp;            fullPDREntered = false;</b>
<b class="nc"><i>3671</i>&nbsp;            for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc"><i>3672</i>&nbsp;                EventTarget entered = fullPDRCurrentEventTargets.get(i);</b>
<b class="nc"><i>3673</i>&nbsp;                Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,</b>
<i>3674</i>&nbsp;                        entered, entered,
<i>3675</i>&nbsp;                        MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
<b class="nc"><i>3676</i>&nbsp;                        fullPDRSource, e.getPickResult()));</b>
<i>3677</i>&nbsp;            }
<b class="nc"><i>3678</i>&nbsp;            fullPDRSource = null;</b>
<b class="nc"><i>3679</i>&nbsp;            fullPDRCurrentEventTargets.clear();</b>
<b class="nc"><i>3680</i>&nbsp;            fullPDRCurrentTarget = null;</b>
<b class="nc"><i>3681</i>&nbsp;        }</b>
<i>3682</i>&nbsp;
<i>3683</i>&nbsp;        private void handleNodeRemoval(Node removing) {
<b class="nc"><i>3684</i>&nbsp;            if (lastEvent == null) {</b>
<i>3685</i>&nbsp;                // this can happen only if everything has been exited anyway
<b class="nc"><i>3686</i>&nbsp;                return;</b>
<i>3687</i>&nbsp;            }
<i>3688</i>&nbsp;
<i>3689</i>&nbsp;
<b class="nc"><i>3690</i>&nbsp;            if (currentEventTargets.contains(removing)) {</b>
<b class="nc"><i>3691</i>&nbsp;                int i = 0;</b>
<b class="nc"><i>3692</i>&nbsp;                EventTarget trg = null;</b>
<b class="nc"><i>3693</i>&nbsp;                while(trg != removing) {</b>
<b class="nc"><i>3694</i>&nbsp;                    trg = currentEventTargets.get(i++);</b>
<i>3695</i>&nbsp;
<b class="nc"><i>3696</i>&nbsp;                    queue.postEvent(lastEvent.copyFor(trg, trg,</b>
<i>3697</i>&nbsp;                            MouseEvent.MOUSE_EXITED_TARGET));
<i>3698</i>&nbsp;                }
<b class="nc"><i>3699</i>&nbsp;                currentEventTargets.subList(0, i).clear();</b>
<i>3700</i>&nbsp;            }
<i>3701</i>&nbsp;
<b class="nc"><i>3702</i>&nbsp;            if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {</b>
<b class="nc"><i>3703</i>&nbsp;                int i = 0;</b>
<b class="nc"><i>3704</i>&nbsp;                EventTarget trg = null;</b>
<b class="nc"><i>3705</i>&nbsp;                while (trg != removing) {</b>
<b class="nc"><i>3706</i>&nbsp;                    trg = fullPDRCurrentEventTargets.get(i++);</b>
<i>3707</i>&nbsp;
<b class="nc"><i>3708</i>&nbsp;                    queue.postEvent(</b>
<b class="nc"><i>3709</i>&nbsp;                            MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,</b>
<i>3710</i>&nbsp;                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
<b class="nc"><i>3711</i>&nbsp;                            fullPDRSource, lastEvent.getPickResult()));</b>
<i>3712</i>&nbsp;                }
<i>3713</i>&nbsp;
<b class="nc"><i>3714</i>&nbsp;                fullPDRCurrentEventTargets.subList(0, i).clear();</b>
<i>3715</i>&nbsp;            }
<i>3716</i>&nbsp;
<b class="nc"><i>3717</i>&nbsp;            queue.fire();</b>
<i>3718</i>&nbsp;
<b class="nc"><i>3719</i>&nbsp;            if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {</b>
<b class="nc"><i>3720</i>&nbsp;                int i = 0;</b>
<b class="nc"><i>3721</i>&nbsp;                EventTarget trg = null;</b>
<b class="nc"><i>3722</i>&nbsp;                while (trg != removing) {</b>
<b class="nc"><i>3723</i>&nbsp;                    trg = pdrEventTargets.get(i++);</b>
<i>3724</i>&nbsp;
<i>3725</i>&nbsp;                    // trg.setHover(false) - already taken care of
<i>3726</i>&nbsp;                    // by the code above which sent a mouse exited event
<b class="nc"><i>3727</i>&nbsp;                    ((Node) trg).setPressed(false);</b>
<i>3728</i>&nbsp;                }
<b class="nc"><i>3729</i>&nbsp;                pdrEventTargets.subList(0, i).clear();</b>
<i>3730</i>&nbsp;
<b class="nc"><i>3731</i>&nbsp;                trg = pdrEventTargets.get(0);</b>
<b class="nc"><i>3732</i>&nbsp;                final PickResult res = pdrEventTarget.getResult();</b>
<b class="nc"><i>3733</i>&nbsp;                if (trg instanceof Node) {</b>
<b class="nc"><i>3734</i>&nbsp;                    pdrEventTarget.setNodeResult(new PickResult((Node) trg,</b>
<b class="nc"><i>3735</i>&nbsp;                            res.getIntersectedPoint(), res.getIntersectedDistance()));</b>
<i>3736</i>&nbsp;                } else {
<b class="nc"><i>3737</i>&nbsp;                    pdrEventTarget.setSceneResult(new PickResult(null,</b>
<b class="nc"><i>3738</i>&nbsp;                            res.getIntersectedPoint(), res.getIntersectedDistance()),</b>
<i>3739</i>&nbsp;                            (Scene) trg);
<i>3740</i>&nbsp;                }
<i>3741</i>&nbsp;            }
<b class="nc"><i>3742</i>&nbsp;        }</b>
<i>3743</i>&nbsp;
<i>3744</i>&nbsp;        private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
<b class="fc"><i>3745</i>&nbsp;            if (pickedTarget.getEventTarget() != currentEventTarget ||</b>
<b class="fc"><i>3746</i>&nbsp;                    e.getEventType() == MouseEvent.MOUSE_EXITED) {</b>
<i>3747</i>&nbsp;
<b class="fc"><i>3748</i>&nbsp;                if (e.getEventType() == MouseEvent.MOUSE_EXITED) {</b>
<b class="fc"><i>3749</i>&nbsp;                    newEventTargets.clear();</b>
<i>3750</i>&nbsp;                } else {
<b class="fc"><i>3751</i>&nbsp;                    pickedTarget.fillHierarchy(newEventTargets);</b>
<i>3752</i>&nbsp;                }
<i>3753</i>&nbsp;
<b class="fc"><i>3754</i>&nbsp;                int newTargetsSize = newEventTargets.size();</b>
<b class="fc"><i>3755</i>&nbsp;                int i = currentEventTargets.size() - 1;</b>
<b class="fc"><i>3756</i>&nbsp;                int j = newTargetsSize - 1;</b>
<b class="fc"><i>3757</i>&nbsp;                int k = pdrEventTargets.size() - 1;</b>
<i>3758</i>&nbsp;
<b class="fc"><i>3759</i>&nbsp;                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {</b>
<b class="fc"><i>3760</i>&nbsp;                    i--;</b>
<b class="fc"><i>3761</i>&nbsp;                    j--;</b>
<b class="fc"><i>3762</i>&nbsp;                    k--;</b>
<i>3763</i>&nbsp;                }
<i>3764</i>&nbsp;
<b class="fc"><i>3765</i>&nbsp;                final int memk = k;</b>
<b class="fc"><i>3766</i>&nbsp;                for (; i &gt;= 0; i--, k--) {</b>
<b class="fc"><i>3767</i>&nbsp;                    final EventTarget exitedEventTarget = currentEventTargets.get(i);</b>
<b class="fc"><i>3768</i>&nbsp;                    if (pdrInProgress &amp;&amp;</b>
<b class="fc"><i>3769</i>&nbsp;                            (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {</b>
<b class="nc"><i>3770</i>&nbsp;                         break;</b>
<i>3771</i>&nbsp;                    }
<b class="fc"><i>3772</i>&nbsp;                    queue.postEvent(e.copyFor(</b>
<i>3773</i>&nbsp;                            exitedEventTarget, exitedEventTarget,
<i>3774</i>&nbsp;                            MouseEvent.MOUSE_EXITED_TARGET));
<i>3775</i>&nbsp;                }
<i>3776</i>&nbsp;
<b class="fc"><i>3777</i>&nbsp;                k = memk;</b>
<b class="fc"><i>3778</i>&nbsp;                for (; j &gt;= 0; j--, k--) {</b>
<b class="fc"><i>3779</i>&nbsp;                    final EventTarget enteredEventTarget = newEventTargets.get(j);</b>
<b class="fc"><i>3780</i>&nbsp;                    if (pdrInProgress &amp;&amp;</b>
<b class="nc"><i>3781</i>&nbsp;                            (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {</b>
<b class="nc"><i>3782</i>&nbsp;                        break;</b>
<i>3783</i>&nbsp;                    }
<b class="fc"><i>3784</i>&nbsp;                    queue.postEvent(e.copyFor(</b>
<i>3785</i>&nbsp;                            enteredEventTarget, enteredEventTarget,
<i>3786</i>&nbsp;                            MouseEvent.MOUSE_ENTERED_TARGET));
<i>3787</i>&nbsp;                }
<i>3788</i>&nbsp;
<b class="fc"><i>3789</i>&nbsp;                currentEventTarget = pickedTarget.getEventTarget();</b>
<b class="fc"><i>3790</i>&nbsp;                currentEventTargets.clear();</b>
<b class="fc"><i>3791</i>&nbsp;                for (j++; j &lt; newTargetsSize; j++) {</b>
<b class="fc"><i>3792</i>&nbsp;                    currentEventTargets.add(newEventTargets.get(j));</b>
<i>3793</i>&nbsp;                }
<i>3794</i>&nbsp;            }
<b class="fc"><i>3795</i>&nbsp;            queue.fire();</b>
<b class="fc"><i>3796</i>&nbsp;        }</b>
<i>3797</i>&nbsp;
<i>3798</i>&nbsp;        private void process(MouseEvent e, boolean onPulse) {
<b class="fc"><i>3799</i>&nbsp;            Toolkit.getToolkit().checkFxUserThread();</b>
<b class="fc"><i>3800</i>&nbsp;            Scene.inMousePick = true;</b>
<i>3801</i>&nbsp;
<b class="fc"><i>3802</i>&nbsp;            cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());</b>
<b class="fc"><i>3803</i>&nbsp;            cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());</b>
<i>3804</i>&nbsp;
<b class="fc"><i>3805</i>&nbsp;            boolean gestureStarted = false;</b>
<b class="fc"><i>3806</i>&nbsp;            if (!onPulse) {</b>
<b class="fc"><i>3807</i>&nbsp;                if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {</b>
<b class="fc"><i>3808</i>&nbsp;                    if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {</b>
<i>3809</i>&nbsp;                        //old gesture ended and new one started
<b class="fc"><i>3810</i>&nbsp;                        gestureStarted = true;</b>
<i>3811</i>&nbsp;                        if (!PLATFORM_DRAG_GESTURE_INITIATION) {
<b class="fc"><i>3812</i>&nbsp;                            Scene.this.dndGesture = new DnDGesture();</b>
<i>3813</i>&nbsp;                        }
<b class="fc"><i>3814</i>&nbsp;                        clearPDREventTargets();</b>
<i>3815</i>&nbsp;                    }
<b class="fc"><i>3816</i>&nbsp;                } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {</b>
<i>3817</i>&nbsp;                    // gesture ended
<b class="fc"><i>3818</i>&nbsp;                    clearPDREventTargets();</b>
<b class="fc"><i>3819</i>&nbsp;                } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {</b>
<b class="fc"><i>3820</i>&nbsp;                    hover = true;</b>
<b class="fc"><i>3821</i>&nbsp;                } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {</b>
<b class="fc"><i>3822</i>&nbsp;                    hover = false;</b>
<i>3823</i>&nbsp;                }
<i>3824</i>&nbsp;
<b class="fc"><i>3825</i>&nbsp;                primaryButtonDown = e.isPrimaryButtonDown();</b>
<b class="fc"><i>3826</i>&nbsp;                secondaryButtonDown = e.isSecondaryButtonDown();</b>
<b class="fc"><i>3827</i>&nbsp;                middleButtonDown = e.isMiddleButtonDown();</b>
<i>3828</i>&nbsp;            }
<i>3829</i>&nbsp;
<b class="fc"><i>3830</i>&nbsp;            pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());</b>
<b class="fc"><i>3831</i>&nbsp;            PickResult res = tmpTargetWrapper.getResult();</b>
<b class="fc"><i>3832</i>&nbsp;            if (res != null) {</b>
<b class="fc"><i>3833</i>&nbsp;                e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),</b>
<b class="fc"><i>3834</i>&nbsp;                    e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),</b>
<b class="fc"><i>3835</i>&nbsp;                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),</b>
<b class="fc"><i>3836</i>&nbsp;                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),</b>
<b class="fc"><i>3837</i>&nbsp;                    e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);</b>
<i>3838</i>&nbsp;            }
<i>3839</i>&nbsp;
<b class="fc"><i>3840</i>&nbsp;            if (e.getEventType() == MouseEvent.MOUSE_EXITED) {</b>
<b class="fc"><i>3841</i>&nbsp;                tmpTargetWrapper.clear();</b>
<i>3842</i>&nbsp;            }
<i>3843</i>&nbsp;
<i>3844</i>&nbsp;            TargetWrapper target;
<b class="fc"><i>3845</i>&nbsp;            if (pdrInProgress) {</b>
<b class="fc"><i>3846</i>&nbsp;                target = pdrEventTarget;</b>
<i>3847</i>&nbsp;            } else {
<b class="fc"><i>3848</i>&nbsp;                target = tmpTargetWrapper;</b>
<i>3849</i>&nbsp;            }
<i>3850</i>&nbsp;
<b class="fc"><i>3851</i>&nbsp;            if (gestureStarted) {</b>
<b class="fc"><i>3852</i>&nbsp;                pdrEventTarget.copy(target);</b>
<b class="fc"><i>3853</i>&nbsp;                pdrEventTarget.fillHierarchy(pdrEventTargets);</b>
<i>3854</i>&nbsp;            }
<i>3855</i>&nbsp;
<b class="fc"><i>3856</i>&nbsp;            if (!onPulse) {</b>
<b class="fc"><i>3857</i>&nbsp;                e = clickGenerator.preProcess(e);</b>
<i>3858</i>&nbsp;            }
<i>3859</i>&nbsp;
<i>3860</i>&nbsp;            // enter/exit handling
<b class="fc"><i>3861</i>&nbsp;            handleEnterExit(e, tmpTargetWrapper);</b>
<i>3862</i>&nbsp;
<i>3863</i>&nbsp;            //deliver event to the target node
<b class="fc"><i>3864</i>&nbsp;            if (Scene.this.dndGesture != null) {</b>
<b class="fc"><i>3865</i>&nbsp;                Scene.this.dndGesture.processDragDetection(e);</b>
<i>3866</i>&nbsp;            }
<i>3867</i>&nbsp;
<b class="fc"><i>3868</i>&nbsp;            if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {</b>
<b class="nc"><i>3869</i>&nbsp;                processFullPDR(e, onPulse);</b>
<i>3870</i>&nbsp;            }
<i>3871</i>&nbsp;
<b class="fc"><i>3872</i>&nbsp;            if (target.getEventTarget() != null) {</b>
<b class="fc"><i>3873</i>&nbsp;                if (e.getEventType() != MouseEvent.MOUSE_ENTERED</b>
<b class="fc"><i>3874</i>&nbsp;                        &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED</b>
<i>3875</i>&nbsp;                        &amp;&amp; !onPulse) {
<b class="fc"><i>3876</i>&nbsp;                    Event.fireEvent(target.getEventTarget(), e);</b>
<i>3877</i>&nbsp;                }
<i>3878</i>&nbsp;            }
<i>3879</i>&nbsp;
<b class="fc"><i>3880</i>&nbsp;            if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {</b>
<b class="nc"><i>3881</i>&nbsp;                processFullPDR(e, onPulse);</b>
<i>3882</i>&nbsp;            }
<i>3883</i>&nbsp;
<b class="fc"><i>3884</i>&nbsp;            if (!onPulse) {</b>
<b class="fc"><i>3885</i>&nbsp;                clickGenerator.postProcess(e, target, tmpTargetWrapper);</b>
<i>3886</i>&nbsp;            }
<i>3887</i>&nbsp;
<i>3888</i>&nbsp;            // handle drag and drop
<i>3889</i>&nbsp;
<b class="fc"><i>3890</i>&nbsp;            if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {</b>
<b class="fc"><i>3891</i>&nbsp;                if (Scene.this.dndGesture != null) {</b>
<b class="fc"><i>3892</i>&nbsp;                    if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {</b>
<b class="fc"><i>3893</i>&nbsp;                        dndGesture = null;</b>
<i>3894</i>&nbsp;                    }
<i>3895</i>&nbsp;                }
<i>3896</i>&nbsp;            }
<i>3897</i>&nbsp;
<b class="fc"><i>3898</i>&nbsp;            Cursor cursor = target.getCursor();</b>
<b class="fc"><i>3899</i>&nbsp;            if (e.getEventType() != MouseEvent.MOUSE_EXITED) {</b>
<b class="fc"><i>3900</i>&nbsp;                if (cursor == null &amp;&amp; hover) {</b>
<b class="fc"><i>3901</i>&nbsp;                    cursor = Scene.this.getCursor();</b>
<i>3902</i>&nbsp;                }
<i>3903</i>&nbsp;
<b class="fc"><i>3904</i>&nbsp;                updateCursor(cursor);</b>
<b class="fc"><i>3905</i>&nbsp;                updateCursorFrame();</b>
<i>3906</i>&nbsp;            }
<i>3907</i>&nbsp;
<b class="fc"><i>3908</i>&nbsp;            if (gestureStarted) {</b>
<b class="fc"><i>3909</i>&nbsp;                pdrInProgress = true;</b>
<i>3910</i>&nbsp;            }
<i>3911</i>&nbsp;
<b class="fc"><i>3912</i>&nbsp;            if (pdrInProgress &amp;&amp;</b>
<i>3913</i>&nbsp;                    !(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
<b class="fc"><i>3914</i>&nbsp;                clearPDREventTargets();</b>
<b class="fc"><i>3915</i>&nbsp;                exitFullPDR(e);</b>
<i>3916</i>&nbsp;                // we need to do new picking in case the originally picked node
<i>3917</i>&nbsp;                // was moved or removed by the event handlers
<b class="fc"><i>3918</i>&nbsp;                pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());</b>
<b class="fc"><i>3919</i>&nbsp;                handleEnterExit(e, tmpTargetWrapper);</b>
<i>3920</i>&nbsp;            }
<i>3921</i>&nbsp;
<b class="fc"><i>3922</i>&nbsp;            lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;</b>
<b class="fc"><i>3923</i>&nbsp;            Scene.inMousePick = false;</b>
<b class="fc"><i>3924</i>&nbsp;        }</b>
<i>3925</i>&nbsp;
<i>3926</i>&nbsp;        private void processFullPDR(MouseEvent e, boolean onPulse) {
<i>3927</i>&nbsp;
<b class="nc"><i>3928</i>&nbsp;            pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());</b>
<b class="nc"><i>3929</i>&nbsp;            final PickResult result = fullPDRTmpTargetWrapper.getResult();</b>
<i>3930</i>&nbsp;
<b class="nc"><i>3931</i>&nbsp;            final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();</b>
<i>3932</i>&nbsp;
<i>3933</i>&nbsp;            // enter/exit handling
<b class="nc"><i>3934</i>&nbsp;            if (eventTarget != fullPDRCurrentTarget) {</b>
<i>3935</i>&nbsp;
<b class="nc"><i>3936</i>&nbsp;                fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);</b>
<i>3937</i>&nbsp;
<b class="nc"><i>3938</i>&nbsp;                int newTargetsSize = fullPDRNewEventTargets.size();</b>
<b class="nc"><i>3939</i>&nbsp;                int i = fullPDRCurrentEventTargets.size() - 1;</b>
<b class="nc"><i>3940</i>&nbsp;                int j = newTargetsSize - 1;</b>
<i>3941</i>&nbsp;
<b class="nc"><i>3942</i>&nbsp;                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;</b>
<b class="nc"><i>3943</i>&nbsp;                        fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {</b>
<b class="nc"><i>3944</i>&nbsp;                    i--;</b>
<b class="nc"><i>3945</i>&nbsp;                    j--;</b>
<i>3946</i>&nbsp;                }
<i>3947</i>&nbsp;
<b class="nc"><i>3948</i>&nbsp;                for (; i &gt;= 0; i--) {</b>
<b class="nc"><i>3949</i>&nbsp;                    final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);</b>
<b class="nc"><i>3950</i>&nbsp;                    Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,</b>
<i>3951</i>&nbsp;                            exitedEventTarget, exitedEventTarget,
<i>3952</i>&nbsp;                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
<i>3953</i>&nbsp;                            fullPDRSource, result));
<i>3954</i>&nbsp;                }
<i>3955</i>&nbsp;
<b class="nc"><i>3956</i>&nbsp;                for (; j &gt;= 0; j--) {</b>
<b class="nc"><i>3957</i>&nbsp;                    final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);</b>
<b class="nc"><i>3958</i>&nbsp;                    Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,</b>
<i>3959</i>&nbsp;                            enteredEventTarget, enteredEventTarget,
<i>3960</i>&nbsp;                            MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
<i>3961</i>&nbsp;                            fullPDRSource, result));
<i>3962</i>&nbsp;                }
<i>3963</i>&nbsp;
<b class="nc"><i>3964</i>&nbsp;                fullPDRCurrentTarget = eventTarget;</b>
<b class="nc"><i>3965</i>&nbsp;                fullPDRCurrentEventTargets.clear();</b>
<b class="nc"><i>3966</i>&nbsp;                fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);</b>
<b class="nc"><i>3967</i>&nbsp;                fullPDRNewEventTargets.clear();</b>
<i>3968</i>&nbsp;            }
<i>3969</i>&nbsp;            // done enter/exit handling
<i>3970</i>&nbsp;
<i>3971</i>&nbsp;            // event delivery
<b class="nc"><i>3972</i>&nbsp;            if (eventTarget != null &amp;&amp; !onPulse) {</b>
<b class="nc"><i>3973</i>&nbsp;                if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {</b>
<b class="nc"><i>3974</i>&nbsp;                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,</b>
<i>3975</i>&nbsp;                            eventTarget, eventTarget,
<i>3976</i>&nbsp;                            MouseDragEvent.MOUSE_DRAG_OVER,
<i>3977</i>&nbsp;                            fullPDRSource, result));
<i>3978</i>&nbsp;                }
<b class="nc"><i>3979</i>&nbsp;                if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {</b>
<b class="nc"><i>3980</i>&nbsp;                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,</b>
<i>3981</i>&nbsp;                            eventTarget, eventTarget,
<i>3982</i>&nbsp;                            MouseDragEvent.MOUSE_DRAG_RELEASED,
<i>3983</i>&nbsp;                            fullPDRSource, result));
<i>3984</i>&nbsp;                }
<i>3985</i>&nbsp;            }
<b class="nc"><i>3986</i>&nbsp;        }</b>
<i>3987</i>&nbsp;
<i>3988</i>&nbsp;        private void updateCursor(Cursor newCursor) {
<b class="fc"><i>3989</i>&nbsp;            if (currCursor != newCursor) {</b>
<b class="fc"><i>3990</i>&nbsp;                if (currCursor != null) {</b>
<b class="fc"><i>3991</i>&nbsp;                    currCursor.deactivate();</b>
<i>3992</i>&nbsp;                }
<i>3993</i>&nbsp;
<b class="fc"><i>3994</i>&nbsp;                if (newCursor != null) {</b>
<b class="fc"><i>3995</i>&nbsp;                    newCursor.activate();</b>
<i>3996</i>&nbsp;                }
<i>3997</i>&nbsp;
<b class="fc"><i>3998</i>&nbsp;                currCursor = newCursor;</b>
<i>3999</i>&nbsp;            }
<b class="fc"><i>4000</i>&nbsp;        }</b>
<i>4001</i>&nbsp;
<i>4002</i>&nbsp;        public void updateCursorFrame() {
<i>4003</i>&nbsp;            final CursorFrame newCursorFrame =
<b class="fc"><i>4004</i>&nbsp;                    (currCursor != null)</b>
<b class="fc"><i>4005</i>&nbsp;                           ? currCursor.getCurrentFrame()</b>
<b class="fc"><i>4006</i>&nbsp;                           : Cursor.DEFAULT.getCurrentFrame();</b>
<b class="fc"><i>4007</i>&nbsp;            if (currCursorFrame != newCursorFrame) {</b>
<b class="fc"><i>4008</i>&nbsp;                if (Scene.this.peer != null) {</b>
<b class="fc"><i>4009</i>&nbsp;                    Scene.this.peer.setCursor(newCursorFrame);</b>
<i>4010</i>&nbsp;                }
<i>4011</i>&nbsp;
<b class="fc"><i>4012</i>&nbsp;                currCursorFrame = newCursorFrame;</b>
<i>4013</i>&nbsp;            }
<b class="fc"><i>4014</i>&nbsp;        }</b>
<i>4015</i>&nbsp;
<i>4016</i>&nbsp;        private PickResult pickNode(PickRay pickRay) {
<b class="fc"><i>4017</i>&nbsp;            PickResultChooser r = new PickResultChooser();</b>
<b class="fc"><i>4018</i>&nbsp;            Scene.this.getRoot().pickNode(pickRay, r);</b>
<b class="fc"><i>4019</i>&nbsp;            return r.toPickResult();</b>
<i>4020</i>&nbsp;        }
<i>4021</i>&nbsp;    }
<i>4022</i>&nbsp;
<i>4023</i>&nbsp;    /*******************************************************************************
<i>4024</i>&nbsp;     *                                                                             *
<i>4025</i>&nbsp;     * Key Event Handling                                                          *
<i>4026</i>&nbsp;     *                                                                             *
<i>4027</i>&nbsp;     ******************************************************************************/
<i>4028</i>&nbsp;
<b class="fc"><i>4029</i>&nbsp;    class KeyHandler {</b>
<i>4030</i>&nbsp;        private void setFocusOwner(final Node value) {
<i>4031</i>&nbsp;            // Cancel IM composition if there is one in progress.
<i>4032</i>&nbsp;            // This needs to be done before the focus owner is switched as it
<i>4033</i>&nbsp;            // generates event that needs to be delivered to the old focus owner.
<b class="fc"><i>4034</i>&nbsp;            if (oldFocusOwner != null) {</b>
<b class="fc"><i>4035</i>&nbsp;                final Scene s = oldFocusOwner.getScene();</b>
<b class="fc"><i>4036</i>&nbsp;                if (s != null) {</b>
<b class="fc"><i>4037</i>&nbsp;                    final TKScene peer = s.getPeer();</b>
<b class="fc"><i>4038</i>&nbsp;                    if (peer != null) {</b>
<b class="fc"><i>4039</i>&nbsp;                        peer.finishInputMethodComposition();</b>
<i>4040</i>&nbsp;                    }
<i>4041</i>&nbsp;                }
<i>4042</i>&nbsp;            }
<b class="fc"><i>4043</i>&nbsp;            focusOwner.set(value);</b>
<b class="fc"><i>4044</i>&nbsp;        }</b>
<i>4045</i>&nbsp;
<i>4046</i>&nbsp;        private boolean windowFocused;
<b class="nc"><i>4047</i>&nbsp;        protected boolean isWindowFocused() { return windowFocused; }</b>
<i>4048</i>&nbsp;        protected void setWindowFocused(boolean value) {
<b class="fc"><i>4049</i>&nbsp;            windowFocused = value;</b>
<b class="fc"><i>4050</i>&nbsp;            if (getFocusOwner() != null) {</b>
<b class="fc"><i>4051</i>&nbsp;                getFocusOwner().setFocused(windowFocused);</b>
<i>4052</i>&nbsp;            }
<b class="fc"><i>4053</i>&nbsp;            if (windowFocused) {</b>
<b class="fc"><i>4054</i>&nbsp;                if (accessible != null) {</b>
<b class="nc"><i>4055</i>&nbsp;                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);</b>
<i>4056</i>&nbsp;                }
<i>4057</i>&nbsp;            }
<b class="fc"><i>4058</i>&nbsp;        }</b>
<i>4059</i>&nbsp;
<i>4060</i>&nbsp;        private void windowForSceneChanged(Window oldWindow, Window window) {
<b class="fc"><i>4061</i>&nbsp;            if (oldWindow != null) {</b>
<b class="nc"><i>4062</i>&nbsp;                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);</b>
<i>4063</i>&nbsp;            }
<i>4064</i>&nbsp;
<b class="fc"><i>4065</i>&nbsp;            if (window != null) {</b>
<b class="fc"><i>4066</i>&nbsp;                window.focusedProperty().addListener(sceneWindowFocusedListener);</b>
<b class="fc"><i>4067</i>&nbsp;                setWindowFocused(window.isFocused());</b>
<i>4068</i>&nbsp;            } else {
<b class="nc"><i>4069</i>&nbsp;                setWindowFocused(false);</b>
<i>4070</i>&nbsp;            }
<b class="fc"><i>4071</i>&nbsp;        }</b>
<i>4072</i>&nbsp;
<b class="fc"><i>4073</i>&nbsp;        private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());</b>
<i>4074</i>&nbsp;
<i>4075</i>&nbsp;        private void process(KeyEvent e) {
<b class="fc"><i>4076</i>&nbsp;            final Node sceneFocusOwner = getFocusOwner();</b>
<i>4077</i>&nbsp;            final EventTarget eventTarget =
<b class="fc"><i>4078</i>&nbsp;                    (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner</b>
<b class="nc"><i>4079</i>&nbsp;                                              : Scene.this;</b>
<i>4080</i>&nbsp;
<i>4081</i>&nbsp;            // send the key event to the current focus owner or to scene if
<i>4082</i>&nbsp;            // the focus owner is not set
<b class="fc"><i>4083</i>&nbsp;            Event.fireEvent(eventTarget, e);</b>
<b class="fc"><i>4084</i>&nbsp;        }</b>
<i>4085</i>&nbsp;
<i>4086</i>&nbsp;        private void requestFocus(Node node) {
<b class="fc"><i>4087</i>&nbsp;            if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {</b>
<b class="fc"><i>4088</i>&nbsp;                return;</b>
<i>4089</i>&nbsp;            }
<b class="fc"><i>4090</i>&nbsp;            setFocusOwner(node);</b>
<b class="fc"><i>4091</i>&nbsp;        }</b>
<i>4092</i>&nbsp;    }
<i>4093</i>&nbsp;    /***************************************************************************
<i>4094</i>&nbsp;     *                                                                         *
<i>4095</i>&nbsp;     *                         Event Dispatch                                  *
<i>4096</i>&nbsp;     *                                                                         *
<i>4097</i>&nbsp;     **************************************************************************/
<i>4098</i>&nbsp;    // PENDING_DOC_REVIEW
<i>4099</i>&nbsp;    /**
<i>4100</i>&nbsp;     * Specifies the event dispatcher for this scene. When replacing the value
<i>4101</i>&nbsp;     * with a new {@code EventDispatcher}, the new dispatcher should forward
<i>4102</i>&nbsp;     * events to the replaced dispatcher to keep the scene&#39;s default event
<i>4103</i>&nbsp;     * handling behavior.
<i>4104</i>&nbsp;     */
<i>4105</i>&nbsp;    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
<i>4106</i>&nbsp;
<i>4107</i>&nbsp;    public final void setEventDispatcher(EventDispatcher value) {
<b class="nc"><i>4108</i>&nbsp;        eventDispatcherProperty().set(value);</b>
<b class="nc"><i>4109</i>&nbsp;    }</b>
<i>4110</i>&nbsp;
<i>4111</i>&nbsp;    public final EventDispatcher getEventDispatcher() {
<b class="nc"><i>4112</i>&nbsp;        return eventDispatcherProperty().get();</b>
<i>4113</i>&nbsp;    }
<i>4114</i>&nbsp;
<i>4115</i>&nbsp;    public final ObjectProperty&lt;EventDispatcher&gt;
<i>4116</i>&nbsp;            eventDispatcherProperty() {
<b class="nc"><i>4117</i>&nbsp;        initializeInternalEventDispatcher();</b>
<b class="nc"><i>4118</i>&nbsp;        return eventDispatcher;</b>
<i>4119</i>&nbsp;    }
<i>4120</i>&nbsp;
<i>4121</i>&nbsp;    private SceneEventDispatcher internalEventDispatcher;
<i>4122</i>&nbsp;
<i>4123</i>&nbsp;    // Delegates requests from platform input method to the focused
<i>4124</i>&nbsp;    // node&#39;s one, if any.
<b class="fc"><i>4125</i>&nbsp;    class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {</b>
<i>4126</i>&nbsp;        @Override
<i>4127</i>&nbsp;        public Point2D getTextLocation(int offset) {
<b class="nc"><i>4128</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4129</i>&nbsp;            if (requests != null) {</b>
<b class="nc"><i>4130</i>&nbsp;                return requests.getTextLocation(offset);</b>
<i>4131</i>&nbsp;            } else {
<b class="nc"><i>4132</i>&nbsp;                return new Point2D(0, 0);</b>
<i>4133</i>&nbsp;            }
<i>4134</i>&nbsp;        }
<i>4135</i>&nbsp;
<i>4136</i>&nbsp;        @Override
<i>4137</i>&nbsp;        public int getLocationOffset(int x, int y) {
<b class="nc"><i>4138</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4139</i>&nbsp;            if (requests != null) {</b>
<b class="nc"><i>4140</i>&nbsp;                return requests.getLocationOffset(x, y);</b>
<i>4141</i>&nbsp;            } else {
<b class="nc"><i>4142</i>&nbsp;                return 0;</b>
<i>4143</i>&nbsp;            }
<i>4144</i>&nbsp;        }
<i>4145</i>&nbsp;
<i>4146</i>&nbsp;        @Override
<i>4147</i>&nbsp;        public void cancelLatestCommittedText() {
<b class="nc"><i>4148</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4149</i>&nbsp;            if (requests != null) {</b>
<b class="nc"><i>4150</i>&nbsp;                requests.cancelLatestCommittedText();</b>
<i>4151</i>&nbsp;            }
<b class="nc"><i>4152</i>&nbsp;        }</b>
<i>4153</i>&nbsp;
<i>4154</i>&nbsp;        @Override
<i>4155</i>&nbsp;        public String getSelectedText() {
<b class="nc"><i>4156</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4157</i>&nbsp;            if (requests != null) {</b>
<b class="nc"><i>4158</i>&nbsp;                return requests.getSelectedText();</b>
<i>4159</i>&nbsp;            }
<b class="nc"><i>4160</i>&nbsp;            return null;</b>
<i>4161</i>&nbsp;        }
<i>4162</i>&nbsp;
<i>4163</i>&nbsp;        @Override
<i>4164</i>&nbsp;        public int getInsertPositionOffset() {
<b class="nc"><i>4165</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4166</i>&nbsp;            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {</b>
<b class="nc"><i>4167</i>&nbsp;                return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();</b>
<i>4168</i>&nbsp;            }
<b class="nc"><i>4169</i>&nbsp;            return 0;</b>
<i>4170</i>&nbsp;        }
<i>4171</i>&nbsp;
<i>4172</i>&nbsp;        @Override
<i>4173</i>&nbsp;        public String getCommittedText(int begin, int end) {
<b class="nc"><i>4174</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4175</i>&nbsp;            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {</b>
<b class="nc"><i>4176</i>&nbsp;                return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);</b>
<i>4177</i>&nbsp;            }
<b class="nc"><i>4178</i>&nbsp;            return null;</b>
<i>4179</i>&nbsp;        }
<i>4180</i>&nbsp;
<i>4181</i>&nbsp;        @Override
<i>4182</i>&nbsp;        public int getCommittedTextLength() {
<b class="nc"><i>4183</i>&nbsp;            InputMethodRequests requests = getClientRequests();</b>
<b class="nc"><i>4184</i>&nbsp;            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {</b>
<b class="nc"><i>4185</i>&nbsp;                return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();</b>
<i>4186</i>&nbsp;            }
<b class="nc"><i>4187</i>&nbsp;            return 0;</b>
<i>4188</i>&nbsp;        }
<i>4189</i>&nbsp;
<i>4190</i>&nbsp;        private InputMethodRequests getClientRequests() {
<b class="nc"><i>4191</i>&nbsp;            Node focusOwner = getFocusOwner();</b>
<b class="nc"><i>4192</i>&nbsp;            if (focusOwner != null) {</b>
<b class="nc"><i>4193</i>&nbsp;                return focusOwner.getInputMethodRequests();</b>
<i>4194</i>&nbsp;            }
<b class="nc"><i>4195</i>&nbsp;            return null;</b>
<i>4196</i>&nbsp;        }
<i>4197</i>&nbsp;    }
<i>4198</i>&nbsp;
<i>4199</i>&nbsp;    // PENDING_DOC_REVIEW
<i>4200</i>&nbsp;    /**
<i>4201</i>&nbsp;     * Registers an event handler to this scene. The handler is called when the
<i>4202</i>&nbsp;     * scene receives an {@code Event} of the specified type during the bubbling
<i>4203</i>&nbsp;     * phase of event delivery.
<i>4204</i>&nbsp;     *
<i>4205</i>&nbsp;     * @param &lt;T&gt; the specific event class of the handler
<i>4206</i>&nbsp;     * @param eventType the type of the events to receive by the handler
<i>4207</i>&nbsp;     * @param eventHandler the handler to register
<i>4208</i>&nbsp;     * @throws NullPointerException if the event type or handler is null
<i>4209</i>&nbsp;     */
<i>4210</i>&nbsp;    public final &lt;T extends Event&gt; void addEventHandler(
<i>4211</i>&nbsp;            final EventType&lt;T&gt; eventType,
<i>4212</i>&nbsp;            final EventHandler&lt;? super T&gt; eventHandler) {
<b class="nc"><i>4213</i>&nbsp;        getInternalEventDispatcher().getEventHandlerManager()</b>
<b class="nc"><i>4214</i>&nbsp;                                    .addEventHandler(eventType, eventHandler);</b>
<b class="nc"><i>4215</i>&nbsp;    }</b>
<i>4216</i>&nbsp;
<i>4217</i>&nbsp;    // PENDING_DOC_REVIEW
<i>4218</i>&nbsp;    /**
<i>4219</i>&nbsp;     * Unregisters a previously registered event handler from this scene. One
<i>4220</i>&nbsp;     * handler might have been registered for different event types, so the
<i>4221</i>&nbsp;     * caller needs to specify the particular event type from which to
<i>4222</i>&nbsp;     * unregister the handler.
<i>4223</i>&nbsp;     *
<i>4224</i>&nbsp;     * @param &lt;T&gt; the specific event class of the handler
<i>4225</i>&nbsp;     * @param eventType the event type from which to unregister
<i>4226</i>&nbsp;     * @param eventHandler the handler to unregister
<i>4227</i>&nbsp;     * @throws NullPointerException if the event type or handler is null
<i>4228</i>&nbsp;     */
<i>4229</i>&nbsp;    public final &lt;T extends Event&gt; void removeEventHandler(
<i>4230</i>&nbsp;            final EventType&lt;T&gt; eventType,
<i>4231</i>&nbsp;            final EventHandler&lt;? super T&gt; eventHandler) {
<b class="nc"><i>4232</i>&nbsp;        getInternalEventDispatcher().getEventHandlerManager()</b>
<b class="nc"><i>4233</i>&nbsp;                                    .removeEventHandler(eventType,</b>
<i>4234</i>&nbsp;                                                        eventHandler);
<b class="nc"><i>4235</i>&nbsp;    }</b>
<i>4236</i>&nbsp;
<i>4237</i>&nbsp;    // PENDING_DOC_REVIEW
<i>4238</i>&nbsp;    /**
<i>4239</i>&nbsp;     * Registers an event filter to this scene. The filter is called when the
<i>4240</i>&nbsp;     * scene receives an {@code Event} of the specified type during the
<i>4241</i>&nbsp;     * capturing phase of event delivery.
<i>4242</i>&nbsp;     *
<i>4243</i>&nbsp;     * @param &lt;T&gt; the specific event class of the filter
<i>4244</i>&nbsp;     * @param eventType the type of the events to receive by the filter
<i>4245</i>&nbsp;     * @param eventFilter the filter to register
<i>4246</i>&nbsp;     * @throws NullPointerException if the event type or filter is null
<i>4247</i>&nbsp;     */
<i>4248</i>&nbsp;    public final &lt;T extends Event&gt; void addEventFilter(
<i>4249</i>&nbsp;            final EventType&lt;T&gt; eventType,
<i>4250</i>&nbsp;            final EventHandler&lt;? super T&gt; eventFilter) {
<b class="nc"><i>4251</i>&nbsp;        getInternalEventDispatcher().getEventHandlerManager()</b>
<b class="nc"><i>4252</i>&nbsp;                                    .addEventFilter(eventType, eventFilter);</b>
<b class="nc"><i>4253</i>&nbsp;    }</b>
<i>4254</i>&nbsp;
<i>4255</i>&nbsp;    // PENDING_DOC_REVIEW
<i>4256</i>&nbsp;    /**
<i>4257</i>&nbsp;     * Unregisters a previously registered event filter from this scene. One
<i>4258</i>&nbsp;     * filter might have been registered for different event types, so the
<i>4259</i>&nbsp;     * caller needs to specify the particular event type from which to
<i>4260</i>&nbsp;     * unregister the filter.
<i>4261</i>&nbsp;     *
<i>4262</i>&nbsp;     * @param &lt;T&gt; the specific event class of the filter
<i>4263</i>&nbsp;     * @param eventType the event type from which to unregister
<i>4264</i>&nbsp;     * @param eventFilter the filter to unregister
<i>4265</i>&nbsp;     * @throws NullPointerException if the event type or filter is null
<i>4266</i>&nbsp;     */
<i>4267</i>&nbsp;    public final &lt;T extends Event&gt; void removeEventFilter(
<i>4268</i>&nbsp;            final EventType&lt;T&gt; eventType,
<i>4269</i>&nbsp;            final EventHandler&lt;? super T&gt; eventFilter) {
<b class="nc"><i>4270</i>&nbsp;        getInternalEventDispatcher().getEventHandlerManager()</b>
<b class="nc"><i>4271</i>&nbsp;                                    .removeEventFilter(eventType, eventFilter);</b>
<b class="nc"><i>4272</i>&nbsp;    }</b>
<i>4273</i>&nbsp;
<i>4274</i>&nbsp;    /**
<i>4275</i>&nbsp;     * Sets the handler to use for this event type. There can only be one such
<i>4276</i>&nbsp;     * handler specified at a time. This handler is guaranteed to be called
<i>4277</i>&nbsp;     * first. This is used for registering the user-defined onFoo event
<i>4278</i>&nbsp;     * handlers.
<i>4279</i>&nbsp;     *
<i>4280</i>&nbsp;     * @param &lt;T&gt; the specific event class of the handler
<i>4281</i>&nbsp;     * @param eventType the event type to associate with the given eventHandler
<i>4282</i>&nbsp;     * @param eventHandler the handler to register, or null to unregister
<i>4283</i>&nbsp;     * @throws NullPointerException if the event type is null
<i>4284</i>&nbsp;     */
<i>4285</i>&nbsp;    protected final &lt;T extends Event&gt; void setEventHandler(
<i>4286</i>&nbsp;            final EventType&lt;T&gt; eventType,
<i>4287</i>&nbsp;            final EventHandler&lt;? super T&gt; eventHandler) {
<b class="nc"><i>4288</i>&nbsp;        getInternalEventDispatcher().getEventHandlerManager()</b>
<b class="nc"><i>4289</i>&nbsp;                                    .setEventHandler(eventType, eventHandler);</b>
<b class="nc"><i>4290</i>&nbsp;    }</b>
<i>4291</i>&nbsp;
<i>4292</i>&nbsp;    private SceneEventDispatcher getInternalEventDispatcher() {
<b class="fc"><i>4293</i>&nbsp;        initializeInternalEventDispatcher();</b>
<b class="fc"><i>4294</i>&nbsp;        return internalEventDispatcher;</b>
<i>4295</i>&nbsp;    }
<i>4296</i>&nbsp;
<i>4297</i>&nbsp;    final void initializeInternalEventDispatcher() {
<b class="fc"><i>4298</i>&nbsp;        if (internalEventDispatcher == null) {</b>
<b class="fc"><i>4299</i>&nbsp;            internalEventDispatcher = createInternalEventDispatcher();</b>
<b class="fc"><i>4300</i>&nbsp;            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(</b>
<i>4301</i>&nbsp;                                          this,
<i>4302</i>&nbsp;                                          &quot;eventDispatcher&quot;,
<i>4303</i>&nbsp;                                          internalEventDispatcher);
<i>4304</i>&nbsp;        }
<b class="fc"><i>4305</i>&nbsp;    }</b>
<i>4306</i>&nbsp;
<i>4307</i>&nbsp;    private SceneEventDispatcher createInternalEventDispatcher() {
<b class="fc"><i>4308</i>&nbsp;        return new SceneEventDispatcher(this);</b>
<i>4309</i>&nbsp;    }
<i>4310</i>&nbsp;
<i>4311</i>&nbsp;    /**
<i>4312</i>&nbsp;     * Registers the specified mnemonic.
<i>4313</i>&nbsp;     *
<i>4314</i>&nbsp;     * @param m The mnemonic
<i>4315</i>&nbsp;     */
<i>4316</i>&nbsp;    public void addMnemonic(Mnemonic m) {
<b class="nc"><i>4317</i>&nbsp;        getInternalEventDispatcher().getKeyboardShortcutsHandler()</b>
<b class="nc"><i>4318</i>&nbsp;                                    .addMnemonic(m);</b>
<b class="nc"><i>4319</i>&nbsp;    }</b>
<i>4320</i>&nbsp;
<i>4321</i>&nbsp;
<i>4322</i>&nbsp;    /**
<i>4323</i>&nbsp;     * Unregisters the specified mnemonic.
<i>4324</i>&nbsp;     *
<i>4325</i>&nbsp;     * @param m The mnemonic
<i>4326</i>&nbsp;     */
<i>4327</i>&nbsp;    public void removeMnemonic(Mnemonic m) {
<b class="nc"><i>4328</i>&nbsp;        getInternalEventDispatcher().getKeyboardShortcutsHandler()</b>
<b class="nc"><i>4329</i>&nbsp;                                    .removeMnemonic(m);</b>
<b class="nc"><i>4330</i>&nbsp;    }</b>
<i>4331</i>&nbsp;
<i>4332</i>&nbsp;    final void clearNodeMnemonics(Node node) {
<b class="fc"><i>4333</i>&nbsp;        getInternalEventDispatcher().getKeyboardShortcutsHandler()</b>
<b class="fc"><i>4334</i>&nbsp;                .clearNodeMnemonics(node);</b>
<b class="fc"><i>4335</i>&nbsp;    }</b>
<i>4336</i>&nbsp;
<i>4337</i>&nbsp;
<i>4338</i>&nbsp;    /**
<i>4339</i>&nbsp;     * Gets the list of mnemonics for this {@code Scene}.
<i>4340</i>&nbsp;     *
<i>4341</i>&nbsp;     * @return the list of mnemonics
<i>4342</i>&nbsp;     */
<i>4343</i>&nbsp;    public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
<b class="nc"><i>4344</i>&nbsp;        return getInternalEventDispatcher().getKeyboardShortcutsHandler()</b>
<b class="nc"><i>4345</i>&nbsp;                                           .getMnemonics();</b>
<i>4346</i>&nbsp;    }
<i>4347</i>&nbsp;
<i>4348</i>&nbsp;    /**
<i>4349</i>&nbsp;     * Gets the list of accelerators for this {@code Scene}.
<i>4350</i>&nbsp;     *
<i>4351</i>&nbsp;     * @return the list of accelerators
<i>4352</i>&nbsp;     */
<i>4353</i>&nbsp;    public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
<b class="nc"><i>4354</i>&nbsp;        return getInternalEventDispatcher().getKeyboardShortcutsHandler()</b>
<b class="nc"><i>4355</i>&nbsp;                                           .getAccelerators();</b>
<i>4356</i>&nbsp;    }
<i>4357</i>&nbsp;
<i>4358</i>&nbsp;    // PENDING_DOC_REVIEW
<i>4359</i>&nbsp;    /**
<i>4360</i>&nbsp;     * Construct an event dispatch chain for this scene. The event dispatch
<i>4361</i>&nbsp;     * chain contains all event dispatchers from the stage to this scene.
<i>4362</i>&nbsp;     *
<i>4363</i>&nbsp;     * @param tail the initial chain to build from
<i>4364</i>&nbsp;     * @return the resulting event dispatch chain for this scene
<i>4365</i>&nbsp;     */
<i>4366</i>&nbsp;    @Override
<i>4367</i>&nbsp;    public EventDispatchChain buildEventDispatchChain(
<i>4368</i>&nbsp;            EventDispatchChain tail) {
<b class="fc"><i>4369</i>&nbsp;        if (eventDispatcher != null) {</b>
<b class="fc"><i>4370</i>&nbsp;            final EventDispatcher eventDispatcherValue = eventDispatcher.get();</b>
<b class="fc"><i>4371</i>&nbsp;            if (eventDispatcherValue != null) {</b>
<b class="fc"><i>4372</i>&nbsp;                tail = tail.prepend(eventDispatcherValue);</b>
<i>4373</i>&nbsp;            }
<i>4374</i>&nbsp;        }
<i>4375</i>&nbsp;
<b class="fc"><i>4376</i>&nbsp;        if (getWindow() != null) {</b>
<b class="fc"><i>4377</i>&nbsp;            tail = getWindow().buildEventDispatchChain(tail);</b>
<i>4378</i>&nbsp;        }
<i>4379</i>&nbsp;
<b class="fc"><i>4380</i>&nbsp;        return tail;</b>
<i>4381</i>&nbsp;    }
<i>4382</i>&nbsp;
<i>4383</i>&nbsp;    /***************************************************************************
<i>4384</i>&nbsp;     *                                                                         *
<i>4385</i>&nbsp;     *                             Context Menus                               *
<i>4386</i>&nbsp;     *                                                                         *
<i>4387</i>&nbsp;     **************************************************************************/
<i>4388</i>&nbsp;
<i>4389</i>&nbsp;    /**
<i>4390</i>&nbsp;     * Defines a function to be called when a mouse button has been clicked
<i>4391</i>&nbsp;     * (pressed and released) on this {@code Scene}.
<i>4392</i>&nbsp;     * @since JavaFX 2.1
<i>4393</i>&nbsp;     */
<i>4394</i>&nbsp;
<i>4395</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;
<i>4396</i>&nbsp;
<i>4397</i>&nbsp;    public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
<b class="nc"><i>4398</i>&nbsp;        onContextMenuRequestedProperty().set(value);</b>
<b class="nc"><i>4399</i>&nbsp;    }</b>
<i>4400</i>&nbsp;
<i>4401</i>&nbsp;    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
<b class="nc"><i>4402</i>&nbsp;        return onContextMenuRequested == null ? null : onContextMenuRequested.get();</b>
<i>4403</i>&nbsp;    }
<i>4404</i>&nbsp;
<i>4405</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
<b class="nc"><i>4406</i>&nbsp;        if (onContextMenuRequested == null) {</b>
<b class="nc"><i>4407</i>&nbsp;            onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {</b>
<i>4408</i>&nbsp;
<i>4409</i>&nbsp;                @Override
<i>4410</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4411</i>&nbsp;                    setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());</b>
<b class="nc"><i>4412</i>&nbsp;                }</b>
<i>4413</i>&nbsp;
<i>4414</i>&nbsp;                @Override
<i>4415</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4416</i>&nbsp;                    return Scene.this;</b>
<i>4417</i>&nbsp;                }
<i>4418</i>&nbsp;
<i>4419</i>&nbsp;                @Override
<i>4420</i>&nbsp;                public String getName() {
<b class="nc"><i>4421</i>&nbsp;                    return &quot;onContextMenuRequested&quot;;</b>
<i>4422</i>&nbsp;                }
<i>4423</i>&nbsp;            };
<i>4424</i>&nbsp;        }
<b class="nc"><i>4425</i>&nbsp;        return onContextMenuRequested;</b>
<i>4426</i>&nbsp;    }
<i>4427</i>&nbsp;
<i>4428</i>&nbsp;    /***************************************************************************
<i>4429</i>&nbsp;     *                                                                         *
<i>4430</i>&nbsp;     *                             Mouse Handling                              *
<i>4431</i>&nbsp;     *                                                                         *
<i>4432</i>&nbsp;     **************************************************************************/
<i>4433</i>&nbsp;
<i>4434</i>&nbsp;    /**
<i>4435</i>&nbsp;     * Defines a function to be called when a mouse button has been clicked
<i>4436</i>&nbsp;     * (pressed and released) on this {@code Scene}.
<i>4437</i>&nbsp;     */
<i>4438</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;
<i>4439</i>&nbsp;
<i>4440</i>&nbsp;    public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4441</i>&nbsp;        onMouseClickedProperty().set(value);</b>
<b class="nc"><i>4442</i>&nbsp;    }</b>
<i>4443</i>&nbsp;
<i>4444</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
<b class="nc"><i>4445</i>&nbsp;        return onMouseClicked == null ? null : onMouseClicked.get();</b>
<i>4446</i>&nbsp;    }
<i>4447</i>&nbsp;
<i>4448</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
<b class="nc"><i>4449</i>&nbsp;        if (onMouseClicked == null) {</b>
<b class="nc"><i>4450</i>&nbsp;            onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4451</i>&nbsp;
<i>4452</i>&nbsp;                @Override
<i>4453</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4454</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_CLICKED, get());</b>
<b class="nc"><i>4455</i>&nbsp;                }</b>
<i>4456</i>&nbsp;
<i>4457</i>&nbsp;                @Override
<i>4458</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4459</i>&nbsp;                    return Scene.this;</b>
<i>4460</i>&nbsp;                }
<i>4461</i>&nbsp;
<i>4462</i>&nbsp;                @Override
<i>4463</i>&nbsp;                public String getName() {
<b class="nc"><i>4464</i>&nbsp;                    return &quot;onMouseClicked&quot;;</b>
<i>4465</i>&nbsp;                }
<i>4466</i>&nbsp;            };
<i>4467</i>&nbsp;        }
<b class="nc"><i>4468</i>&nbsp;        return onMouseClicked;</b>
<i>4469</i>&nbsp;    }
<i>4470</i>&nbsp;
<i>4471</i>&nbsp;    /**
<i>4472</i>&nbsp;     * Defines a function to be called when a mouse button is pressed
<i>4473</i>&nbsp;     * on this {@code Scene} and then dragged.
<i>4474</i>&nbsp;     */
<i>4475</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;
<i>4476</i>&nbsp;
<i>4477</i>&nbsp;    public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4478</i>&nbsp;        onMouseDraggedProperty().set(value);</b>
<b class="nc"><i>4479</i>&nbsp;    }</b>
<i>4480</i>&nbsp;
<i>4481</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
<b class="nc"><i>4482</i>&nbsp;        return onMouseDragged == null ? null : onMouseDragged.get();</b>
<i>4483</i>&nbsp;    }
<i>4484</i>&nbsp;
<i>4485</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
<b class="nc"><i>4486</i>&nbsp;        if (onMouseDragged == null) {</b>
<b class="nc"><i>4487</i>&nbsp;            onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4488</i>&nbsp;
<i>4489</i>&nbsp;                @Override
<i>4490</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4491</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_DRAGGED, get());</b>
<b class="nc"><i>4492</i>&nbsp;                }</b>
<i>4493</i>&nbsp;
<i>4494</i>&nbsp;                @Override
<i>4495</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4496</i>&nbsp;                    return Scene.this;</b>
<i>4497</i>&nbsp;                }
<i>4498</i>&nbsp;
<i>4499</i>&nbsp;                @Override
<i>4500</i>&nbsp;                public String getName() {
<b class="nc"><i>4501</i>&nbsp;                    return &quot;onMouseDragged&quot;;</b>
<i>4502</i>&nbsp;                }
<i>4503</i>&nbsp;            };
<i>4504</i>&nbsp;        }
<b class="nc"><i>4505</i>&nbsp;        return onMouseDragged;</b>
<i>4506</i>&nbsp;    }
<i>4507</i>&nbsp;
<i>4508</i>&nbsp;    /**
<i>4509</i>&nbsp;     * Defines a function to be called when the mouse enters this {@code Scene}.
<i>4510</i>&nbsp;     */
<i>4511</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;
<i>4512</i>&nbsp;
<i>4513</i>&nbsp;    public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4514</i>&nbsp;        onMouseEnteredProperty().set(value);</b>
<b class="nc"><i>4515</i>&nbsp;    }</b>
<i>4516</i>&nbsp;
<i>4517</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
<b class="nc"><i>4518</i>&nbsp;        return onMouseEntered == null ? null : onMouseEntered.get();</b>
<i>4519</i>&nbsp;    }
<i>4520</i>&nbsp;
<i>4521</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
<b class="nc"><i>4522</i>&nbsp;        if (onMouseEntered == null) {</b>
<b class="nc"><i>4523</i>&nbsp;            onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4524</i>&nbsp;
<i>4525</i>&nbsp;                @Override
<i>4526</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4527</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_ENTERED, get());</b>
<b class="nc"><i>4528</i>&nbsp;                }</b>
<i>4529</i>&nbsp;
<i>4530</i>&nbsp;                @Override
<i>4531</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4532</i>&nbsp;                    return Scene.this;</b>
<i>4533</i>&nbsp;                }
<i>4534</i>&nbsp;
<i>4535</i>&nbsp;                @Override
<i>4536</i>&nbsp;                public String getName() {
<b class="nc"><i>4537</i>&nbsp;                    return &quot;onMouseEntered&quot;;</b>
<i>4538</i>&nbsp;                }
<i>4539</i>&nbsp;            };
<i>4540</i>&nbsp;        }
<b class="nc"><i>4541</i>&nbsp;        return onMouseEntered;</b>
<i>4542</i>&nbsp;    }
<i>4543</i>&nbsp;
<i>4544</i>&nbsp;    /**
<i>4545</i>&nbsp;     * Defines a function to be called when the mouse exits this {@code Scene}.
<i>4546</i>&nbsp;     */
<i>4547</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;
<i>4548</i>&nbsp;
<i>4549</i>&nbsp;    public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4550</i>&nbsp;        onMouseExitedProperty().set(value);</b>
<b class="nc"><i>4551</i>&nbsp;    }</b>
<i>4552</i>&nbsp;
<i>4553</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
<b class="nc"><i>4554</i>&nbsp;        return onMouseExited == null ? null : onMouseExited.get();</b>
<i>4555</i>&nbsp;    }
<i>4556</i>&nbsp;
<i>4557</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
<b class="nc"><i>4558</i>&nbsp;        if (onMouseExited == null) {</b>
<b class="nc"><i>4559</i>&nbsp;            onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4560</i>&nbsp;
<i>4561</i>&nbsp;                @Override
<i>4562</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4563</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_EXITED, get());</b>
<b class="nc"><i>4564</i>&nbsp;                }</b>
<i>4565</i>&nbsp;
<i>4566</i>&nbsp;                @Override
<i>4567</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4568</i>&nbsp;                    return Scene.this;</b>
<i>4569</i>&nbsp;                }
<i>4570</i>&nbsp;
<i>4571</i>&nbsp;                @Override
<i>4572</i>&nbsp;                public String getName() {
<b class="nc"><i>4573</i>&nbsp;                    return &quot;onMouseExited&quot;;</b>
<i>4574</i>&nbsp;                }
<i>4575</i>&nbsp;            };
<i>4576</i>&nbsp;        }
<b class="nc"><i>4577</i>&nbsp;        return onMouseExited;</b>
<i>4578</i>&nbsp;    }
<i>4579</i>&nbsp;
<i>4580</i>&nbsp;    /**
<i>4581</i>&nbsp;     * Defines a function to be called when mouse cursor moves within
<i>4582</i>&nbsp;     * this {@code Scene} but no buttons have been pushed.
<i>4583</i>&nbsp;     */
<i>4584</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;
<i>4585</i>&nbsp;
<i>4586</i>&nbsp;    public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4587</i>&nbsp;        onMouseMovedProperty().set(value);</b>
<b class="nc"><i>4588</i>&nbsp;    }</b>
<i>4589</i>&nbsp;
<i>4590</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
<b class="nc"><i>4591</i>&nbsp;        return onMouseMoved == null ? null : onMouseMoved.get();</b>
<i>4592</i>&nbsp;    }
<i>4593</i>&nbsp;
<i>4594</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
<b class="nc"><i>4595</i>&nbsp;        if (onMouseMoved == null) {</b>
<b class="nc"><i>4596</i>&nbsp;            onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4597</i>&nbsp;
<i>4598</i>&nbsp;                @Override
<i>4599</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4600</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_MOVED, get());</b>
<b class="nc"><i>4601</i>&nbsp;                }</b>
<i>4602</i>&nbsp;
<i>4603</i>&nbsp;                @Override
<i>4604</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4605</i>&nbsp;                    return Scene.this;</b>
<i>4606</i>&nbsp;                }
<i>4607</i>&nbsp;
<i>4608</i>&nbsp;                @Override
<i>4609</i>&nbsp;                public String getName() {
<b class="nc"><i>4610</i>&nbsp;                    return &quot;onMouseMoved&quot;;</b>
<i>4611</i>&nbsp;                }
<i>4612</i>&nbsp;            };
<i>4613</i>&nbsp;        }
<b class="nc"><i>4614</i>&nbsp;        return onMouseMoved;</b>
<i>4615</i>&nbsp;    }
<i>4616</i>&nbsp;
<i>4617</i>&nbsp;    /**
<i>4618</i>&nbsp;     * Defines a function to be called when a mouse button
<i>4619</i>&nbsp;     * has been pressed on this {@code Scene}.
<i>4620</i>&nbsp;     */
<i>4621</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;
<i>4622</i>&nbsp;
<i>4623</i>&nbsp;    public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4624</i>&nbsp;        onMousePressedProperty().set(value);</b>
<b class="nc"><i>4625</i>&nbsp;    }</b>
<i>4626</i>&nbsp;
<i>4627</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
<b class="nc"><i>4628</i>&nbsp;        return onMousePressed == null ? null : onMousePressed.get();</b>
<i>4629</i>&nbsp;    }
<i>4630</i>&nbsp;
<i>4631</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
<b class="nc"><i>4632</i>&nbsp;        if (onMousePressed == null) {</b>
<b class="nc"><i>4633</i>&nbsp;            onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4634</i>&nbsp;
<i>4635</i>&nbsp;                @Override
<i>4636</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4637</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_PRESSED, get());</b>
<b class="nc"><i>4638</i>&nbsp;                }</b>
<i>4639</i>&nbsp;
<i>4640</i>&nbsp;                @Override
<i>4641</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4642</i>&nbsp;                    return Scene.this;</b>
<i>4643</i>&nbsp;                }
<i>4644</i>&nbsp;
<i>4645</i>&nbsp;                @Override
<i>4646</i>&nbsp;                public String getName() {
<b class="nc"><i>4647</i>&nbsp;                    return &quot;onMousePressed&quot;;</b>
<i>4648</i>&nbsp;                }
<i>4649</i>&nbsp;            };
<i>4650</i>&nbsp;        }
<b class="nc"><i>4651</i>&nbsp;        return onMousePressed;</b>
<i>4652</i>&nbsp;    }
<i>4653</i>&nbsp;
<i>4654</i>&nbsp;    /**
<i>4655</i>&nbsp;     * Defines a function to be called when a mouse button
<i>4656</i>&nbsp;     * has been released on this {@code Scene}.
<i>4657</i>&nbsp;     */
<i>4658</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;
<i>4659</i>&nbsp;
<i>4660</i>&nbsp;    public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4661</i>&nbsp;        onMouseReleasedProperty().set(value);</b>
<b class="nc"><i>4662</i>&nbsp;    }</b>
<i>4663</i>&nbsp;
<i>4664</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
<b class="nc"><i>4665</i>&nbsp;        return onMouseReleased == null ? null : onMouseReleased.get();</b>
<i>4666</i>&nbsp;    }
<i>4667</i>&nbsp;
<i>4668</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
<b class="nc"><i>4669</i>&nbsp;        if (onMouseReleased == null) {</b>
<b class="nc"><i>4670</i>&nbsp;            onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4671</i>&nbsp;
<i>4672</i>&nbsp;                @Override
<i>4673</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4674</i>&nbsp;                    setEventHandler(MouseEvent.MOUSE_RELEASED, get());</b>
<b class="nc"><i>4675</i>&nbsp;                }</b>
<i>4676</i>&nbsp;
<i>4677</i>&nbsp;                @Override
<i>4678</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4679</i>&nbsp;                    return Scene.this;</b>
<i>4680</i>&nbsp;                }
<i>4681</i>&nbsp;
<i>4682</i>&nbsp;                @Override
<i>4683</i>&nbsp;                public String getName() {
<b class="nc"><i>4684</i>&nbsp;                    return &quot;onMouseReleased&quot;;</b>
<i>4685</i>&nbsp;                }
<i>4686</i>&nbsp;            };
<i>4687</i>&nbsp;        }
<b class="nc"><i>4688</i>&nbsp;        return onMouseReleased;</b>
<i>4689</i>&nbsp;    }
<i>4690</i>&nbsp;
<i>4691</i>&nbsp;    /**
<i>4692</i>&nbsp;     * Defines a function to be called when drag gesture has been
<i>4693</i>&nbsp;     * detected. This is the right place to start drag and drop operation.
<i>4694</i>&nbsp;     */
<i>4695</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;
<i>4696</i>&nbsp;
<i>4697</i>&nbsp;    public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
<b class="nc"><i>4698</i>&nbsp;        onDragDetectedProperty().set(value);</b>
<b class="nc"><i>4699</i>&nbsp;    }</b>
<i>4700</i>&nbsp;
<i>4701</i>&nbsp;    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
<b class="nc"><i>4702</i>&nbsp;        return onDragDetected == null ? null : onDragDetected.get();</b>
<i>4703</i>&nbsp;    }
<i>4704</i>&nbsp;
<i>4705</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
<b class="nc"><i>4706</i>&nbsp;        if (onDragDetected == null) {</b>
<b class="nc"><i>4707</i>&nbsp;            onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {</b>
<i>4708</i>&nbsp;
<i>4709</i>&nbsp;                @Override
<i>4710</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4711</i>&nbsp;                    setEventHandler(MouseEvent.DRAG_DETECTED, get());</b>
<b class="nc"><i>4712</i>&nbsp;                }</b>
<i>4713</i>&nbsp;
<i>4714</i>&nbsp;                @Override
<i>4715</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4716</i>&nbsp;                    return Scene.this;</b>
<i>4717</i>&nbsp;                }
<i>4718</i>&nbsp;
<i>4719</i>&nbsp;                @Override
<i>4720</i>&nbsp;                public String getName() {
<b class="nc"><i>4721</i>&nbsp;                    return &quot;onDragDetected&quot;;</b>
<i>4722</i>&nbsp;                }
<i>4723</i>&nbsp;            };
<i>4724</i>&nbsp;        }
<b class="nc"><i>4725</i>&nbsp;        return onDragDetected;</b>
<i>4726</i>&nbsp;    }
<i>4727</i>&nbsp;
<i>4728</i>&nbsp;    /**
<i>4729</i>&nbsp;     * Defines a function to be called when a full press-drag-release gesture
<i>4730</i>&nbsp;     * progresses within this {@code Scene}.
<i>4731</i>&nbsp;     * @since JavaFX 2.1
<i>4732</i>&nbsp;     */
<i>4733</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;
<i>4734</i>&nbsp;
<i>4735</i>&nbsp;    public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
<b class="nc"><i>4736</i>&nbsp;        onMouseDragOverProperty().set(value);</b>
<b class="nc"><i>4737</i>&nbsp;    }</b>
<i>4738</i>&nbsp;
<i>4739</i>&nbsp;    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
<b class="nc"><i>4740</i>&nbsp;        return onMouseDragOver == null ? null : onMouseDragOver.get();</b>
<i>4741</i>&nbsp;    }
<i>4742</i>&nbsp;
<i>4743</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
<b class="nc"><i>4744</i>&nbsp;        if (onMouseDragOver == null) {</b>
<b class="nc"><i>4745</i>&nbsp;            onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {</b>
<i>4746</i>&nbsp;
<i>4747</i>&nbsp;                @Override
<i>4748</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4749</i>&nbsp;                    setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());</b>
<b class="nc"><i>4750</i>&nbsp;                }</b>
<i>4751</i>&nbsp;
<i>4752</i>&nbsp;                @Override
<i>4753</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4754</i>&nbsp;                    return Scene.this;</b>
<i>4755</i>&nbsp;                }
<i>4756</i>&nbsp;
<i>4757</i>&nbsp;                @Override
<i>4758</i>&nbsp;                public String getName() {
<b class="nc"><i>4759</i>&nbsp;                    return &quot;onMouseDragOver&quot;;</b>
<i>4760</i>&nbsp;                }
<i>4761</i>&nbsp;            };
<i>4762</i>&nbsp;        }
<b class="nc"><i>4763</i>&nbsp;        return onMouseDragOver;</b>
<i>4764</i>&nbsp;    }
<i>4765</i>&nbsp;
<i>4766</i>&nbsp;    /**
<i>4767</i>&nbsp;     * Defines a function to be called when a full press-drag-release gesture
<i>4768</i>&nbsp;     * ends within this {@code Scene}.
<i>4769</i>&nbsp;     * @since JavaFX 2.1
<i>4770</i>&nbsp;     */
<i>4771</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;
<i>4772</i>&nbsp;
<i>4773</i>&nbsp;    public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
<b class="nc"><i>4774</i>&nbsp;        onMouseDragReleasedProperty().set(value);</b>
<b class="nc"><i>4775</i>&nbsp;    }</b>
<i>4776</i>&nbsp;
<i>4777</i>&nbsp;    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
<b class="nc"><i>4778</i>&nbsp;        return onMouseDragReleased == null ? null : onMouseDragReleased.get();</b>
<i>4779</i>&nbsp;    }
<i>4780</i>&nbsp;
<i>4781</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
<b class="nc"><i>4782</i>&nbsp;        if (onMouseDragReleased == null) {</b>
<b class="nc"><i>4783</i>&nbsp;            onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {</b>
<i>4784</i>&nbsp;
<i>4785</i>&nbsp;                @Override
<i>4786</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4787</i>&nbsp;                    setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());</b>
<b class="nc"><i>4788</i>&nbsp;                }</b>
<i>4789</i>&nbsp;
<i>4790</i>&nbsp;                @Override
<i>4791</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4792</i>&nbsp;                    return Scene.this;</b>
<i>4793</i>&nbsp;                }
<i>4794</i>&nbsp;
<i>4795</i>&nbsp;                @Override
<i>4796</i>&nbsp;                public String getName() {
<b class="nc"><i>4797</i>&nbsp;                    return &quot;onMouseDragReleased&quot;;</b>
<i>4798</i>&nbsp;                }
<i>4799</i>&nbsp;            };
<i>4800</i>&nbsp;        }
<b class="nc"><i>4801</i>&nbsp;        return onMouseDragReleased;</b>
<i>4802</i>&nbsp;    }
<i>4803</i>&nbsp;
<i>4804</i>&nbsp;    /**
<i>4805</i>&nbsp;     * Defines a function to be called when a full press-drag-release gesture
<i>4806</i>&nbsp;     * enters this {@code Scene}.
<i>4807</i>&nbsp;     * @since JavaFX 2.1
<i>4808</i>&nbsp;     */
<i>4809</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;
<i>4810</i>&nbsp;
<i>4811</i>&nbsp;    public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
<b class="nc"><i>4812</i>&nbsp;        onMouseDragEnteredProperty().set(value);</b>
<b class="nc"><i>4813</i>&nbsp;    }</b>
<i>4814</i>&nbsp;
<i>4815</i>&nbsp;    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
<b class="nc"><i>4816</i>&nbsp;        return onMouseDragEntered == null ? null : onMouseDragEntered.get();</b>
<i>4817</i>&nbsp;    }
<i>4818</i>&nbsp;
<i>4819</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
<b class="nc"><i>4820</i>&nbsp;        if (onMouseDragEntered == null) {</b>
<b class="nc"><i>4821</i>&nbsp;            onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {</b>
<i>4822</i>&nbsp;
<i>4823</i>&nbsp;                @Override
<i>4824</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4825</i>&nbsp;                    setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());</b>
<b class="nc"><i>4826</i>&nbsp;                }</b>
<i>4827</i>&nbsp;
<i>4828</i>&nbsp;                @Override
<i>4829</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4830</i>&nbsp;                    return Scene.this;</b>
<i>4831</i>&nbsp;                }
<i>4832</i>&nbsp;
<i>4833</i>&nbsp;                @Override
<i>4834</i>&nbsp;                public String getName() {
<b class="nc"><i>4835</i>&nbsp;                    return &quot;onMouseDragEntered&quot;;</b>
<i>4836</i>&nbsp;                }
<i>4837</i>&nbsp;            };
<i>4838</i>&nbsp;        }
<b class="nc"><i>4839</i>&nbsp;        return onMouseDragEntered;</b>
<i>4840</i>&nbsp;    }
<i>4841</i>&nbsp;
<i>4842</i>&nbsp;    /**
<i>4843</i>&nbsp;     * Defines a function to be called when a full press-drag-release gesture
<i>4844</i>&nbsp;     * exits this {@code Scene}.
<i>4845</i>&nbsp;     * @since JavaFX 2.1
<i>4846</i>&nbsp;     */
<i>4847</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;
<i>4848</i>&nbsp;
<i>4849</i>&nbsp;    public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
<b class="nc"><i>4850</i>&nbsp;        onMouseDragExitedProperty().set(value);</b>
<b class="nc"><i>4851</i>&nbsp;    }</b>
<i>4852</i>&nbsp;
<i>4853</i>&nbsp;    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
<b class="nc"><i>4854</i>&nbsp;        return onMouseDragExited == null ? null : onMouseDragExited.get();</b>
<i>4855</i>&nbsp;    }
<i>4856</i>&nbsp;
<i>4857</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
<b class="nc"><i>4858</i>&nbsp;        if (onMouseDragExited == null) {</b>
<b class="nc"><i>4859</i>&nbsp;            onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {</b>
<i>4860</i>&nbsp;
<i>4861</i>&nbsp;                @Override
<i>4862</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4863</i>&nbsp;                    setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());</b>
<b class="nc"><i>4864</i>&nbsp;                }</b>
<i>4865</i>&nbsp;
<i>4866</i>&nbsp;                @Override
<i>4867</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4868</i>&nbsp;                    return Scene.this;</b>
<i>4869</i>&nbsp;                }
<i>4870</i>&nbsp;
<i>4871</i>&nbsp;                @Override
<i>4872</i>&nbsp;                public String getName() {
<b class="nc"><i>4873</i>&nbsp;                    return &quot;onMouseDragExited&quot;;</b>
<i>4874</i>&nbsp;                }
<i>4875</i>&nbsp;            };
<i>4876</i>&nbsp;        }
<b class="nc"><i>4877</i>&nbsp;        return onMouseDragExited;</b>
<i>4878</i>&nbsp;    }
<i>4879</i>&nbsp;
<i>4880</i>&nbsp;
<i>4881</i>&nbsp;    /***************************************************************************
<i>4882</i>&nbsp;     *                                                                         *
<i>4883</i>&nbsp;     *                           Gestures Handling                             *
<i>4884</i>&nbsp;     *                                                                         *
<i>4885</i>&nbsp;     **************************************************************************/
<i>4886</i>&nbsp;
<i>4887</i>&nbsp;    /**
<i>4888</i>&nbsp;     * Defines a function to be called when a scrolling gesture is detected.
<i>4889</i>&nbsp;     * @since JavaFX 2.2
<i>4890</i>&nbsp;     */
<i>4891</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;
<i>4892</i>&nbsp;
<i>4893</i>&nbsp;    public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
<b class="nc"><i>4894</i>&nbsp;        onScrollStartedProperty().set(value);</b>
<b class="nc"><i>4895</i>&nbsp;    }</b>
<i>4896</i>&nbsp;
<i>4897</i>&nbsp;    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
<b class="nc"><i>4898</i>&nbsp;        return onScrollStarted == null ? null : onScrollStarted.get();</b>
<i>4899</i>&nbsp;    }
<i>4900</i>&nbsp;
<i>4901</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
<b class="nc"><i>4902</i>&nbsp;        if (onScrollStarted == null) {</b>
<b class="nc"><i>4903</i>&nbsp;            onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {</b>
<i>4904</i>&nbsp;
<i>4905</i>&nbsp;                @Override
<i>4906</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4907</i>&nbsp;                    setEventHandler(ScrollEvent.SCROLL_STARTED, get());</b>
<b class="nc"><i>4908</i>&nbsp;                }</b>
<i>4909</i>&nbsp;
<i>4910</i>&nbsp;                @Override
<i>4911</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4912</i>&nbsp;                    return Scene.this;</b>
<i>4913</i>&nbsp;                }
<i>4914</i>&nbsp;
<i>4915</i>&nbsp;                @Override
<i>4916</i>&nbsp;                public String getName() {
<b class="nc"><i>4917</i>&nbsp;                    return &quot;onScrollStarted&quot;;</b>
<i>4918</i>&nbsp;                }
<i>4919</i>&nbsp;            };
<i>4920</i>&nbsp;        }
<b class="nc"><i>4921</i>&nbsp;        return onScrollStarted;</b>
<i>4922</i>&nbsp;    }
<i>4923</i>&nbsp;
<i>4924</i>&nbsp;    /**
<i>4925</i>&nbsp;     * Defines a function to be called when user performs a scrolling action.
<i>4926</i>&nbsp;     */
<i>4927</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;
<i>4928</i>&nbsp;
<i>4929</i>&nbsp;    public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
<b class="nc"><i>4930</i>&nbsp;        onScrollProperty().set(value);</b>
<b class="nc"><i>4931</i>&nbsp;    }</b>
<i>4932</i>&nbsp;
<i>4933</i>&nbsp;    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
<b class="nc"><i>4934</i>&nbsp;        return onScroll == null ? null : onScroll.get();</b>
<i>4935</i>&nbsp;    }
<i>4936</i>&nbsp;
<i>4937</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
<b class="nc"><i>4938</i>&nbsp;        if (onScroll == null) {</b>
<b class="nc"><i>4939</i>&nbsp;            onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {</b>
<i>4940</i>&nbsp;
<i>4941</i>&nbsp;                @Override
<i>4942</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4943</i>&nbsp;                    setEventHandler(ScrollEvent.SCROLL, get());</b>
<b class="nc"><i>4944</i>&nbsp;                }</b>
<i>4945</i>&nbsp;
<i>4946</i>&nbsp;                @Override
<i>4947</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4948</i>&nbsp;                    return Scene.this;</b>
<i>4949</i>&nbsp;                }
<i>4950</i>&nbsp;
<i>4951</i>&nbsp;                @Override
<i>4952</i>&nbsp;                public String getName() {
<b class="nc"><i>4953</i>&nbsp;                    return &quot;onScroll&quot;;</b>
<i>4954</i>&nbsp;                }
<i>4955</i>&nbsp;            };
<i>4956</i>&nbsp;        }
<b class="nc"><i>4957</i>&nbsp;        return onScroll;</b>
<i>4958</i>&nbsp;    }
<i>4959</i>&nbsp;
<i>4960</i>&nbsp;    /**
<i>4961</i>&nbsp;     * Defines a function to be called when a scrolling gesture ends.
<i>4962</i>&nbsp;     * @since JavaFX 2.2
<i>4963</i>&nbsp;     */
<i>4964</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;
<i>4965</i>&nbsp;
<i>4966</i>&nbsp;    public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
<b class="nc"><i>4967</i>&nbsp;        onScrollFinishedProperty().set(value);</b>
<b class="nc"><i>4968</i>&nbsp;    }</b>
<i>4969</i>&nbsp;
<i>4970</i>&nbsp;    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
<b class="nc"><i>4971</i>&nbsp;        return onScrollFinished == null ? null : onScrollFinished.get();</b>
<i>4972</i>&nbsp;    }
<i>4973</i>&nbsp;
<i>4974</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
<b class="nc"><i>4975</i>&nbsp;        if (onScrollFinished == null) {</b>
<b class="nc"><i>4976</i>&nbsp;            onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {</b>
<i>4977</i>&nbsp;
<i>4978</i>&nbsp;                @Override
<i>4979</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>4980</i>&nbsp;                    setEventHandler(ScrollEvent.SCROLL_FINISHED, get());</b>
<b class="nc"><i>4981</i>&nbsp;                }</b>
<i>4982</i>&nbsp;
<i>4983</i>&nbsp;                @Override
<i>4984</i>&nbsp;                public Object getBean() {
<b class="nc"><i>4985</i>&nbsp;                    return Scene.this;</b>
<i>4986</i>&nbsp;                }
<i>4987</i>&nbsp;
<i>4988</i>&nbsp;                @Override
<i>4989</i>&nbsp;                public String getName() {
<b class="nc"><i>4990</i>&nbsp;                    return &quot;onScrollFinished&quot;;</b>
<i>4991</i>&nbsp;                }
<i>4992</i>&nbsp;            };
<i>4993</i>&nbsp;        }
<b class="nc"><i>4994</i>&nbsp;        return onScrollFinished;</b>
<i>4995</i>&nbsp;    }
<i>4996</i>&nbsp;
<i>4997</i>&nbsp;    /**
<i>4998</i>&nbsp;     * Defines a function to be called when a rotating gesture is detected.
<i>4999</i>&nbsp;     * @since JavaFX 2.2
<i>5000</i>&nbsp;     */
<i>5001</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;
<i>5002</i>&nbsp;
<i>5003</i>&nbsp;    public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
<b class="nc"><i>5004</i>&nbsp;        onRotationStartedProperty().set(value);</b>
<b class="nc"><i>5005</i>&nbsp;    }</b>
<i>5006</i>&nbsp;
<i>5007</i>&nbsp;    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
<b class="nc"><i>5008</i>&nbsp;        return onRotationStarted == null ? null : onRotationStarted.get();</b>
<i>5009</i>&nbsp;    }
<i>5010</i>&nbsp;
<i>5011</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
<b class="nc"><i>5012</i>&nbsp;        if (onRotationStarted == null) {</b>
<b class="nc"><i>5013</i>&nbsp;            onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {</b>
<i>5014</i>&nbsp;
<i>5015</i>&nbsp;                @Override
<i>5016</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5017</i>&nbsp;                    setEventHandler(RotateEvent.ROTATION_STARTED, get());</b>
<b class="nc"><i>5018</i>&nbsp;                }</b>
<i>5019</i>&nbsp;
<i>5020</i>&nbsp;                @Override
<i>5021</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5022</i>&nbsp;                    return Scene.this;</b>
<i>5023</i>&nbsp;                }
<i>5024</i>&nbsp;
<i>5025</i>&nbsp;                @Override
<i>5026</i>&nbsp;                public String getName() {
<b class="nc"><i>5027</i>&nbsp;                    return &quot;onRotationStarted&quot;;</b>
<i>5028</i>&nbsp;                }
<i>5029</i>&nbsp;            };
<i>5030</i>&nbsp;        }
<b class="nc"><i>5031</i>&nbsp;        return onRotationStarted;</b>
<i>5032</i>&nbsp;    }
<i>5033</i>&nbsp;
<i>5034</i>&nbsp;    /**
<i>5035</i>&nbsp;     * Defines a function to be called when user performs a rotating action.
<i>5036</i>&nbsp;     * @since JavaFX 2.2
<i>5037</i>&nbsp;     */
<i>5038</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;
<i>5039</i>&nbsp;
<i>5040</i>&nbsp;    public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
<b class="nc"><i>5041</i>&nbsp;        onRotateProperty().set(value);</b>
<b class="nc"><i>5042</i>&nbsp;    }</b>
<i>5043</i>&nbsp;
<i>5044</i>&nbsp;    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
<b class="nc"><i>5045</i>&nbsp;        return onRotate == null ? null : onRotate.get();</b>
<i>5046</i>&nbsp;    }
<i>5047</i>&nbsp;
<i>5048</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
<b class="nc"><i>5049</i>&nbsp;        if (onRotate == null) {</b>
<b class="nc"><i>5050</i>&nbsp;            onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {</b>
<i>5051</i>&nbsp;
<i>5052</i>&nbsp;                @Override
<i>5053</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5054</i>&nbsp;                    setEventHandler(RotateEvent.ROTATE, get());</b>
<b class="nc"><i>5055</i>&nbsp;                }</b>
<i>5056</i>&nbsp;
<i>5057</i>&nbsp;                @Override
<i>5058</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5059</i>&nbsp;                    return Scene.this;</b>
<i>5060</i>&nbsp;                }
<i>5061</i>&nbsp;
<i>5062</i>&nbsp;                @Override
<i>5063</i>&nbsp;                public String getName() {
<b class="nc"><i>5064</i>&nbsp;                    return &quot;onRotate&quot;;</b>
<i>5065</i>&nbsp;                }
<i>5066</i>&nbsp;            };
<i>5067</i>&nbsp;        }
<b class="nc"><i>5068</i>&nbsp;        return onRotate;</b>
<i>5069</i>&nbsp;    }
<i>5070</i>&nbsp;
<i>5071</i>&nbsp;    /**
<i>5072</i>&nbsp;     * Defines a function to be called when a rotating gesture ends.
<i>5073</i>&nbsp;     * @since JavaFX 2.2
<i>5074</i>&nbsp;     */
<i>5075</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;
<i>5076</i>&nbsp;
<i>5077</i>&nbsp;    public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
<b class="nc"><i>5078</i>&nbsp;        onRotationFinishedProperty().set(value);</b>
<b class="nc"><i>5079</i>&nbsp;    }</b>
<i>5080</i>&nbsp;
<i>5081</i>&nbsp;    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
<b class="nc"><i>5082</i>&nbsp;        return onRotationFinished == null ? null : onRotationFinished.get();</b>
<i>5083</i>&nbsp;    }
<i>5084</i>&nbsp;
<i>5085</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
<b class="nc"><i>5086</i>&nbsp;        if (onRotationFinished == null) {</b>
<b class="nc"><i>5087</i>&nbsp;            onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {</b>
<i>5088</i>&nbsp;
<i>5089</i>&nbsp;                @Override
<i>5090</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5091</i>&nbsp;                    setEventHandler(RotateEvent.ROTATION_FINISHED, get());</b>
<b class="nc"><i>5092</i>&nbsp;                }</b>
<i>5093</i>&nbsp;
<i>5094</i>&nbsp;                @Override
<i>5095</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5096</i>&nbsp;                    return Scene.this;</b>
<i>5097</i>&nbsp;                }
<i>5098</i>&nbsp;
<i>5099</i>&nbsp;                @Override
<i>5100</i>&nbsp;                public String getName() {
<b class="nc"><i>5101</i>&nbsp;                    return &quot;onRotationFinished&quot;;</b>
<i>5102</i>&nbsp;                }
<i>5103</i>&nbsp;            };
<i>5104</i>&nbsp;        }
<b class="nc"><i>5105</i>&nbsp;        return onRotationFinished;</b>
<i>5106</i>&nbsp;    }
<i>5107</i>&nbsp;
<i>5108</i>&nbsp;    /**
<i>5109</i>&nbsp;     * Defines a function to be called when a zooming gesture is detected.
<i>5110</i>&nbsp;     * @since JavaFX 2.2
<i>5111</i>&nbsp;     */
<i>5112</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;
<i>5113</i>&nbsp;
<i>5114</i>&nbsp;    public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
<b class="nc"><i>5115</i>&nbsp;        onZoomStartedProperty().set(value);</b>
<b class="nc"><i>5116</i>&nbsp;    }</b>
<i>5117</i>&nbsp;
<i>5118</i>&nbsp;    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
<b class="nc"><i>5119</i>&nbsp;        return onZoomStarted == null ? null : onZoomStarted.get();</b>
<i>5120</i>&nbsp;    }
<i>5121</i>&nbsp;
<i>5122</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
<b class="nc"><i>5123</i>&nbsp;        if (onZoomStarted == null) {</b>
<b class="nc"><i>5124</i>&nbsp;            onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {</b>
<i>5125</i>&nbsp;
<i>5126</i>&nbsp;                @Override
<i>5127</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5128</i>&nbsp;                    setEventHandler(ZoomEvent.ZOOM_STARTED, get());</b>
<b class="nc"><i>5129</i>&nbsp;                }</b>
<i>5130</i>&nbsp;
<i>5131</i>&nbsp;                @Override
<i>5132</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5133</i>&nbsp;                    return Scene.this;</b>
<i>5134</i>&nbsp;                }
<i>5135</i>&nbsp;
<i>5136</i>&nbsp;                @Override
<i>5137</i>&nbsp;                public String getName() {
<b class="nc"><i>5138</i>&nbsp;                    return &quot;onZoomStarted&quot;;</b>
<i>5139</i>&nbsp;                }
<i>5140</i>&nbsp;            };
<i>5141</i>&nbsp;        }
<b class="nc"><i>5142</i>&nbsp;        return onZoomStarted;</b>
<i>5143</i>&nbsp;    }
<i>5144</i>&nbsp;
<i>5145</i>&nbsp;    /**
<i>5146</i>&nbsp;     * Defines a function to be called when user performs a zooming action.
<i>5147</i>&nbsp;     * @since JavaFX 2.2
<i>5148</i>&nbsp;     */
<i>5149</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;
<i>5150</i>&nbsp;
<i>5151</i>&nbsp;    public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
<b class="nc"><i>5152</i>&nbsp;        onZoomProperty().set(value);</b>
<b class="nc"><i>5153</i>&nbsp;    }</b>
<i>5154</i>&nbsp;
<i>5155</i>&nbsp;    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
<b class="nc"><i>5156</i>&nbsp;        return onZoom == null ? null : onZoom.get();</b>
<i>5157</i>&nbsp;    }
<i>5158</i>&nbsp;
<i>5159</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
<b class="nc"><i>5160</i>&nbsp;        if (onZoom == null) {</b>
<b class="nc"><i>5161</i>&nbsp;            onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {</b>
<i>5162</i>&nbsp;
<i>5163</i>&nbsp;                @Override
<i>5164</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5165</i>&nbsp;                    setEventHandler(ZoomEvent.ZOOM, get());</b>
<b class="nc"><i>5166</i>&nbsp;                }</b>
<i>5167</i>&nbsp;
<i>5168</i>&nbsp;                @Override
<i>5169</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5170</i>&nbsp;                    return Scene.this;</b>
<i>5171</i>&nbsp;                }
<i>5172</i>&nbsp;
<i>5173</i>&nbsp;                @Override
<i>5174</i>&nbsp;                public String getName() {
<b class="nc"><i>5175</i>&nbsp;                    return &quot;onZoom&quot;;</b>
<i>5176</i>&nbsp;                }
<i>5177</i>&nbsp;            };
<i>5178</i>&nbsp;        }
<b class="nc"><i>5179</i>&nbsp;        return onZoom;</b>
<i>5180</i>&nbsp;    }
<i>5181</i>&nbsp;
<i>5182</i>&nbsp;    /**
<i>5183</i>&nbsp;     * Defines a function to be called when a zooming gesture ends.
<i>5184</i>&nbsp;     * @since JavaFX 2.2
<i>5185</i>&nbsp;     */
<i>5186</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;
<i>5187</i>&nbsp;
<i>5188</i>&nbsp;    public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
<b class="nc"><i>5189</i>&nbsp;        onZoomFinishedProperty().set(value);</b>
<b class="nc"><i>5190</i>&nbsp;    }</b>
<i>5191</i>&nbsp;
<i>5192</i>&nbsp;    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
<b class="nc"><i>5193</i>&nbsp;        return onZoomFinished == null ? null : onZoomFinished.get();</b>
<i>5194</i>&nbsp;    }
<i>5195</i>&nbsp;
<i>5196</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
<b class="nc"><i>5197</i>&nbsp;        if (onZoomFinished == null) {</b>
<b class="nc"><i>5198</i>&nbsp;            onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {</b>
<i>5199</i>&nbsp;
<i>5200</i>&nbsp;                @Override
<i>5201</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5202</i>&nbsp;                    setEventHandler(ZoomEvent.ZOOM_FINISHED, get());</b>
<b class="nc"><i>5203</i>&nbsp;                }</b>
<i>5204</i>&nbsp;
<i>5205</i>&nbsp;                @Override
<i>5206</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5207</i>&nbsp;                    return Scene.this;</b>
<i>5208</i>&nbsp;                }
<i>5209</i>&nbsp;
<i>5210</i>&nbsp;                @Override
<i>5211</i>&nbsp;                public String getName() {
<b class="nc"><i>5212</i>&nbsp;                    return &quot;onZoomFinished&quot;;</b>
<i>5213</i>&nbsp;                }
<i>5214</i>&nbsp;            };
<i>5215</i>&nbsp;        }
<b class="nc"><i>5216</i>&nbsp;        return onZoomFinished;</b>
<i>5217</i>&nbsp;    }
<i>5218</i>&nbsp;
<i>5219</i>&nbsp;    /**
<i>5220</i>&nbsp;     * Defines a function to be called when an upward swipe gesture
<i>5221</i>&nbsp;     * happens in this scene.
<i>5222</i>&nbsp;     * @since JavaFX 2.2
<i>5223</i>&nbsp;     */
<i>5224</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;
<i>5225</i>&nbsp;
<i>5226</i>&nbsp;    public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
<b class="nc"><i>5227</i>&nbsp;        onSwipeUpProperty().set(value);</b>
<b class="nc"><i>5228</i>&nbsp;    }</b>
<i>5229</i>&nbsp;
<i>5230</i>&nbsp;    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
<b class="nc"><i>5231</i>&nbsp;        return onSwipeUp == null ? null : onSwipeUp.get();</b>
<i>5232</i>&nbsp;    }
<i>5233</i>&nbsp;
<i>5234</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
<b class="nc"><i>5235</i>&nbsp;        if (onSwipeUp == null) {</b>
<b class="nc"><i>5236</i>&nbsp;            onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {</b>
<i>5237</i>&nbsp;
<i>5238</i>&nbsp;                @Override
<i>5239</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5240</i>&nbsp;                    setEventHandler(SwipeEvent.SWIPE_UP, get());</b>
<b class="nc"><i>5241</i>&nbsp;                }</b>
<i>5242</i>&nbsp;
<i>5243</i>&nbsp;                @Override
<i>5244</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5245</i>&nbsp;                    return Scene.this;</b>
<i>5246</i>&nbsp;                }
<i>5247</i>&nbsp;
<i>5248</i>&nbsp;                @Override
<i>5249</i>&nbsp;                public String getName() {
<b class="nc"><i>5250</i>&nbsp;                    return &quot;onSwipeUp&quot;;</b>
<i>5251</i>&nbsp;                }
<i>5252</i>&nbsp;            };
<i>5253</i>&nbsp;        }
<b class="nc"><i>5254</i>&nbsp;        return onSwipeUp;</b>
<i>5255</i>&nbsp;    }
<i>5256</i>&nbsp;
<i>5257</i>&nbsp;    /**
<i>5258</i>&nbsp;     * Defines a function to be called when an downward swipe gesture
<i>5259</i>&nbsp;     * happens in this scene.
<i>5260</i>&nbsp;     * @since JavaFX 2.2
<i>5261</i>&nbsp;     */
<i>5262</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;
<i>5263</i>&nbsp;
<i>5264</i>&nbsp;    public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
<b class="nc"><i>5265</i>&nbsp;        onSwipeDownProperty().set(value);</b>
<b class="nc"><i>5266</i>&nbsp;    }</b>
<i>5267</i>&nbsp;
<i>5268</i>&nbsp;    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
<b class="nc"><i>5269</i>&nbsp;        return onSwipeDown == null ? null : onSwipeDown.get();</b>
<i>5270</i>&nbsp;    }
<i>5271</i>&nbsp;
<i>5272</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
<b class="nc"><i>5273</i>&nbsp;        if (onSwipeDown == null) {</b>
<b class="nc"><i>5274</i>&nbsp;            onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {</b>
<i>5275</i>&nbsp;
<i>5276</i>&nbsp;                @Override
<i>5277</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5278</i>&nbsp;                    setEventHandler(SwipeEvent.SWIPE_DOWN, get());</b>
<b class="nc"><i>5279</i>&nbsp;                }</b>
<i>5280</i>&nbsp;
<i>5281</i>&nbsp;                @Override
<i>5282</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5283</i>&nbsp;                    return Scene.this;</b>
<i>5284</i>&nbsp;                }
<i>5285</i>&nbsp;
<i>5286</i>&nbsp;                @Override
<i>5287</i>&nbsp;                public String getName() {
<b class="nc"><i>5288</i>&nbsp;                    return &quot;onSwipeDown&quot;;</b>
<i>5289</i>&nbsp;                }
<i>5290</i>&nbsp;            };
<i>5291</i>&nbsp;        }
<b class="nc"><i>5292</i>&nbsp;        return onSwipeDown;</b>
<i>5293</i>&nbsp;    }
<i>5294</i>&nbsp;
<i>5295</i>&nbsp;    /**
<i>5296</i>&nbsp;     * Defines a function to be called when an leftward swipe gesture
<i>5297</i>&nbsp;     * happens in this scene.
<i>5298</i>&nbsp;     * @since JavaFX 2.2
<i>5299</i>&nbsp;     */
<i>5300</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;
<i>5301</i>&nbsp;
<i>5302</i>&nbsp;    public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
<b class="nc"><i>5303</i>&nbsp;        onSwipeLeftProperty().set(value);</b>
<b class="nc"><i>5304</i>&nbsp;    }</b>
<i>5305</i>&nbsp;
<i>5306</i>&nbsp;    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
<b class="nc"><i>5307</i>&nbsp;        return onSwipeLeft == null ? null : onSwipeLeft.get();</b>
<i>5308</i>&nbsp;    }
<i>5309</i>&nbsp;
<i>5310</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
<b class="nc"><i>5311</i>&nbsp;        if (onSwipeLeft == null) {</b>
<b class="nc"><i>5312</i>&nbsp;            onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {</b>
<i>5313</i>&nbsp;
<i>5314</i>&nbsp;                @Override
<i>5315</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5316</i>&nbsp;                    setEventHandler(SwipeEvent.SWIPE_LEFT, get());</b>
<b class="nc"><i>5317</i>&nbsp;                }</b>
<i>5318</i>&nbsp;
<i>5319</i>&nbsp;                @Override
<i>5320</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5321</i>&nbsp;                    return Scene.this;</b>
<i>5322</i>&nbsp;                }
<i>5323</i>&nbsp;
<i>5324</i>&nbsp;                @Override
<i>5325</i>&nbsp;                public String getName() {
<b class="nc"><i>5326</i>&nbsp;                    return &quot;onSwipeLeft&quot;;</b>
<i>5327</i>&nbsp;                }
<i>5328</i>&nbsp;            };
<i>5329</i>&nbsp;        }
<b class="nc"><i>5330</i>&nbsp;        return onSwipeLeft;</b>
<i>5331</i>&nbsp;    }
<i>5332</i>&nbsp;
<i>5333</i>&nbsp;    /**
<i>5334</i>&nbsp;     * Defines a function to be called when an rightward swipe gesture
<i>5335</i>&nbsp;     * happens in this scene.
<i>5336</i>&nbsp;     * @since JavaFX 2.2
<i>5337</i>&nbsp;     */
<i>5338</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;
<i>5339</i>&nbsp;
<i>5340</i>&nbsp;    public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
<b class="nc"><i>5341</i>&nbsp;        onSwipeRightProperty().set(value);</b>
<b class="nc"><i>5342</i>&nbsp;    }</b>
<i>5343</i>&nbsp;
<i>5344</i>&nbsp;    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
<b class="nc"><i>5345</i>&nbsp;        return onSwipeRight == null ? null : onSwipeRight.get();</b>
<i>5346</i>&nbsp;    }
<i>5347</i>&nbsp;
<i>5348</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
<b class="nc"><i>5349</i>&nbsp;        if (onSwipeRight == null) {</b>
<b class="nc"><i>5350</i>&nbsp;            onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {</b>
<i>5351</i>&nbsp;
<i>5352</i>&nbsp;                @Override
<i>5353</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5354</i>&nbsp;                    setEventHandler(SwipeEvent.SWIPE_RIGHT, get());</b>
<b class="nc"><i>5355</i>&nbsp;                }</b>
<i>5356</i>&nbsp;
<i>5357</i>&nbsp;                @Override
<i>5358</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5359</i>&nbsp;                    return Scene.this;</b>
<i>5360</i>&nbsp;                }
<i>5361</i>&nbsp;
<i>5362</i>&nbsp;                @Override
<i>5363</i>&nbsp;                public String getName() {
<b class="nc"><i>5364</i>&nbsp;                    return &quot;onSwipeRight&quot;;</b>
<i>5365</i>&nbsp;                }
<i>5366</i>&nbsp;            };
<i>5367</i>&nbsp;        }
<b class="nc"><i>5368</i>&nbsp;        return onSwipeRight;</b>
<i>5369</i>&nbsp;    }
<i>5370</i>&nbsp;
<i>5371</i>&nbsp;    /***************************************************************************
<i>5372</i>&nbsp;     *                                                                         *
<i>5373</i>&nbsp;     *                            Touch Handling                               *
<i>5374</i>&nbsp;     *                                                                         *
<i>5375</i>&nbsp;     **************************************************************************/
<i>5376</i>&nbsp;
<i>5377</i>&nbsp;    /**
<i>5378</i>&nbsp;     * Defines a function to be called when a new touch point is pressed.
<i>5379</i>&nbsp;     * @since JavaFX 2.2
<i>5380</i>&nbsp;     */
<i>5381</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;
<i>5382</i>&nbsp;
<i>5383</i>&nbsp;    public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
<b class="nc"><i>5384</i>&nbsp;        onTouchPressedProperty().set(value);</b>
<b class="nc"><i>5385</i>&nbsp;    }</b>
<i>5386</i>&nbsp;
<i>5387</i>&nbsp;    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
<b class="nc"><i>5388</i>&nbsp;        return onTouchPressed == null ? null : onTouchPressed.get();</b>
<i>5389</i>&nbsp;    }
<i>5390</i>&nbsp;
<i>5391</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
<b class="nc"><i>5392</i>&nbsp;        if (onTouchPressed == null) {</b>
<b class="nc"><i>5393</i>&nbsp;            onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {</b>
<i>5394</i>&nbsp;
<i>5395</i>&nbsp;                @Override
<i>5396</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5397</i>&nbsp;                    setEventHandler(TouchEvent.TOUCH_PRESSED, get());</b>
<b class="nc"><i>5398</i>&nbsp;                }</b>
<i>5399</i>&nbsp;
<i>5400</i>&nbsp;                @Override
<i>5401</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5402</i>&nbsp;                    return Scene.this;</b>
<i>5403</i>&nbsp;                }
<i>5404</i>&nbsp;
<i>5405</i>&nbsp;                @Override
<i>5406</i>&nbsp;                public String getName() {
<b class="nc"><i>5407</i>&nbsp;                    return &quot;onTouchPressed&quot;;</b>
<i>5408</i>&nbsp;                }
<i>5409</i>&nbsp;            };
<i>5410</i>&nbsp;        }
<b class="nc"><i>5411</i>&nbsp;        return onTouchPressed;</b>
<i>5412</i>&nbsp;    }
<i>5413</i>&nbsp;
<i>5414</i>&nbsp;    /**
<i>5415</i>&nbsp;     * Defines a function to be called when a touch point is moved.
<i>5416</i>&nbsp;     * @since JavaFX 2.2
<i>5417</i>&nbsp;     */
<i>5418</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;
<i>5419</i>&nbsp;
<i>5420</i>&nbsp;    public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
<b class="nc"><i>5421</i>&nbsp;        onTouchMovedProperty().set(value);</b>
<b class="nc"><i>5422</i>&nbsp;    }</b>
<i>5423</i>&nbsp;
<i>5424</i>&nbsp;    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
<b class="nc"><i>5425</i>&nbsp;        return onTouchMoved == null ? null : onTouchMoved.get();</b>
<i>5426</i>&nbsp;    }
<i>5427</i>&nbsp;
<i>5428</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
<b class="nc"><i>5429</i>&nbsp;        if (onTouchMoved == null) {</b>
<b class="nc"><i>5430</i>&nbsp;            onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {</b>
<i>5431</i>&nbsp;
<i>5432</i>&nbsp;                @Override
<i>5433</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5434</i>&nbsp;                    setEventHandler(TouchEvent.TOUCH_MOVED, get());</b>
<b class="nc"><i>5435</i>&nbsp;                }</b>
<i>5436</i>&nbsp;
<i>5437</i>&nbsp;                @Override
<i>5438</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5439</i>&nbsp;                    return Scene.this;</b>
<i>5440</i>&nbsp;                }
<i>5441</i>&nbsp;
<i>5442</i>&nbsp;                @Override
<i>5443</i>&nbsp;                public String getName() {
<b class="nc"><i>5444</i>&nbsp;                    return &quot;onTouchMoved&quot;;</b>
<i>5445</i>&nbsp;                }
<i>5446</i>&nbsp;            };
<i>5447</i>&nbsp;        }
<b class="nc"><i>5448</i>&nbsp;        return onTouchMoved;</b>
<i>5449</i>&nbsp;    }
<i>5450</i>&nbsp;
<i>5451</i>&nbsp;    /**
<i>5452</i>&nbsp;     * Defines a function to be called when a new touch point is pressed.
<i>5453</i>&nbsp;     * @since JavaFX 2.2
<i>5454</i>&nbsp;     */
<i>5455</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;
<i>5456</i>&nbsp;
<i>5457</i>&nbsp;    public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
<b class="nc"><i>5458</i>&nbsp;        onTouchReleasedProperty().set(value);</b>
<b class="nc"><i>5459</i>&nbsp;    }</b>
<i>5460</i>&nbsp;
<i>5461</i>&nbsp;    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
<b class="nc"><i>5462</i>&nbsp;        return onTouchReleased == null ? null : onTouchReleased.get();</b>
<i>5463</i>&nbsp;    }
<i>5464</i>&nbsp;
<i>5465</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
<b class="nc"><i>5466</i>&nbsp;        if (onTouchReleased == null) {</b>
<b class="nc"><i>5467</i>&nbsp;            onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {</b>
<i>5468</i>&nbsp;
<i>5469</i>&nbsp;                @Override
<i>5470</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5471</i>&nbsp;                    setEventHandler(TouchEvent.TOUCH_RELEASED, get());</b>
<b class="nc"><i>5472</i>&nbsp;                }</b>
<i>5473</i>&nbsp;
<i>5474</i>&nbsp;                @Override
<i>5475</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5476</i>&nbsp;                    return Scene.this;</b>
<i>5477</i>&nbsp;                }
<i>5478</i>&nbsp;
<i>5479</i>&nbsp;                @Override
<i>5480</i>&nbsp;                public String getName() {
<b class="nc"><i>5481</i>&nbsp;                    return &quot;onTouchReleased&quot;;</b>
<i>5482</i>&nbsp;                }
<i>5483</i>&nbsp;            };
<i>5484</i>&nbsp;        }
<b class="nc"><i>5485</i>&nbsp;        return onTouchReleased;</b>
<i>5486</i>&nbsp;    }
<i>5487</i>&nbsp;
<i>5488</i>&nbsp;    /**
<i>5489</i>&nbsp;     * Defines a function to be called when a touch point stays pressed and
<i>5490</i>&nbsp;     * still.
<i>5491</i>&nbsp;     * @since JavaFX 2.2
<i>5492</i>&nbsp;     */
<i>5493</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;
<i>5494</i>&nbsp;
<i>5495</i>&nbsp;    public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
<b class="nc"><i>5496</i>&nbsp;        onTouchStationaryProperty().set(value);</b>
<b class="nc"><i>5497</i>&nbsp;    }</b>
<i>5498</i>&nbsp;
<i>5499</i>&nbsp;    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
<b class="nc"><i>5500</i>&nbsp;        return onTouchStationary == null ? null : onTouchStationary.get();</b>
<i>5501</i>&nbsp;    }
<i>5502</i>&nbsp;
<i>5503</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
<b class="nc"><i>5504</i>&nbsp;        if (onTouchStationary == null) {</b>
<b class="nc"><i>5505</i>&nbsp;            onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {</b>
<i>5506</i>&nbsp;
<i>5507</i>&nbsp;                @Override
<i>5508</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5509</i>&nbsp;                    setEventHandler(TouchEvent.TOUCH_STATIONARY, get());</b>
<b class="nc"><i>5510</i>&nbsp;                }</b>
<i>5511</i>&nbsp;
<i>5512</i>&nbsp;                @Override
<i>5513</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5514</i>&nbsp;                    return Scene.this;</b>
<i>5515</i>&nbsp;                }
<i>5516</i>&nbsp;
<i>5517</i>&nbsp;                @Override
<i>5518</i>&nbsp;                public String getName() {
<b class="nc"><i>5519</i>&nbsp;                    return &quot;onTouchStationary&quot;;</b>
<i>5520</i>&nbsp;                }
<i>5521</i>&nbsp;            };
<i>5522</i>&nbsp;        }
<b class="nc"><i>5523</i>&nbsp;        return onTouchStationary;</b>
<i>5524</i>&nbsp;    }
<i>5525</i>&nbsp;
<i>5526</i>&nbsp;    /*
<i>5527</i>&nbsp;     * This class provides reordering and ID mapping of particular touch points.
<i>5528</i>&nbsp;     * Platform may report arbitrary touch point IDs and they may be reused
<i>5529</i>&nbsp;     * during one gesture. This class keeps track of it and provides
<i>5530</i>&nbsp;     * sequentially sorted IDs, unique in scope of a gesture.
<i>5531</i>&nbsp;     *
<i>5532</i>&nbsp;     * Some platforms report always small numbers, these take fast paths through
<i>5533</i>&nbsp;     * the algorithm, directly indexing an array. Bigger numbers take a slow
<i>5534</i>&nbsp;     * path using a hash map.
<i>5535</i>&nbsp;     *
<i>5536</i>&nbsp;     * The algorithm performance was measured and it doesn&#39;t impose
<i>5537</i>&nbsp;     * any significant slowdown on the event delivery.
<i>5538</i>&nbsp;     */
<b class="fc"><i>5539</i>&nbsp;    private static class TouchMap {</b>
<i>5540</i>&nbsp;        private static final int FAST_THRESHOLD = 10;
<b class="fc"><i>5541</i>&nbsp;        int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};</b>
<b class="fc"><i>5542</i>&nbsp;        Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();</b>
<b class="fc"><i>5543</i>&nbsp;        List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();</b>
<b class="fc"><i>5544</i>&nbsp;        List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);</b>
<b class="fc"><i>5545</i>&nbsp;        int counter = 0;</b>
<b class="fc"><i>5546</i>&nbsp;        int active = 0;</b>
<i>5547</i>&nbsp;
<i>5548</i>&nbsp;        public int add(long id) {
<b class="nc"><i>5549</i>&nbsp;            counter++;</b>
<b class="nc"><i>5550</i>&nbsp;            active++;</b>
<b class="nc"><i>5551</i>&nbsp;            if (id &lt; FAST_THRESHOLD) {</b>
<b class="nc"><i>5552</i>&nbsp;                fastMap[(int) id] = counter;</b>
<i>5553</i>&nbsp;            } else {
<b class="nc"><i>5554</i>&nbsp;                slowMap.put(id, counter);</b>
<i>5555</i>&nbsp;            }
<b class="nc"><i>5556</i>&nbsp;            order.add(counter);</b>
<b class="nc"><i>5557</i>&nbsp;            return counter;</b>
<i>5558</i>&nbsp;        }
<i>5559</i>&nbsp;
<i>5560</i>&nbsp;        public void remove(long id) {
<i>5561</i>&nbsp;            // book the removal - it needs to be done after all touch points
<i>5562</i>&nbsp;            // of an event are processed - see cleanup()
<b class="nc"><i>5563</i>&nbsp;            removed.add(id);</b>
<b class="nc"><i>5564</i>&nbsp;        }</b>
<i>5565</i>&nbsp;
<i>5566</i>&nbsp;        public int get(long id) {
<b class="nc"><i>5567</i>&nbsp;            if (id &lt; FAST_THRESHOLD) {</b>
<b class="nc"><i>5568</i>&nbsp;                int result = fastMap[(int) id];</b>
<b class="nc"><i>5569</i>&nbsp;                if (result == 0) {</b>
<b class="nc"><i>5570</i>&nbsp;                    throw new RuntimeException(&quot;Platform reported wrong &quot;</b>
<i>5571</i>&nbsp;                            + &quot;touch point ID&quot;);
<i>5572</i>&nbsp;                }
<b class="nc"><i>5573</i>&nbsp;                return result;</b>
<i>5574</i>&nbsp;            } else {
<i>5575</i>&nbsp;                try {
<b class="nc"><i>5576</i>&nbsp;                    return slowMap.get(id);</b>
<b class="nc"><i>5577</i>&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc"><i>5578</i>&nbsp;                    throw new RuntimeException(&quot;Platform reported wrong &quot;</b>
<i>5579</i>&nbsp;                            + &quot;touch point ID&quot;);
<i>5580</i>&nbsp;                }
<i>5581</i>&nbsp;            }
<i>5582</i>&nbsp;        }
<i>5583</i>&nbsp;
<i>5584</i>&nbsp;        public int getOrder(int id) {
<b class="nc"><i>5585</i>&nbsp;            return order.indexOf(id);</b>
<i>5586</i>&nbsp;        }
<i>5587</i>&nbsp;
<i>5588</i>&nbsp;        // returns true if gesture finished (no finger is touched)
<i>5589</i>&nbsp;        public boolean cleanup() {
<b class="nc"><i>5590</i>&nbsp;            for (long id : removed) {</b>
<b class="nc"><i>5591</i>&nbsp;                active--;</b>
<b class="nc"><i>5592</i>&nbsp;                order.remove(Integer.valueOf(get(id)));</b>
<b class="nc"><i>5593</i>&nbsp;                if (id &lt; FAST_THRESHOLD) {</b>
<b class="nc"><i>5594</i>&nbsp;                    fastMap[(int) id] = 0;</b>
<i>5595</i>&nbsp;                } else {
<b class="nc"><i>5596</i>&nbsp;                    slowMap.remove(id);</b>
<i>5597</i>&nbsp;                }
<b class="nc"><i>5598</i>&nbsp;                if (active == 0) {</b>
<i>5599</i>&nbsp;                    // gesture finished
<b class="nc"><i>5600</i>&nbsp;                    counter = 0;</b>
<i>5601</i>&nbsp;                }
<b class="nc"><i>5602</i>&nbsp;            }</b>
<b class="nc"><i>5603</i>&nbsp;            removed.clear();</b>
<b class="nc"><i>5604</i>&nbsp;            return active == 0;</b>
<i>5605</i>&nbsp;        }
<i>5606</i>&nbsp;    }
<i>5607</i>&nbsp;
<i>5608</i>&nbsp;
<i>5609</i>&nbsp;    /***************************************************************************
<i>5610</i>&nbsp;     *                                                                         *
<i>5611</i>&nbsp;     *                         Drag and Drop Handling                          *
<i>5612</i>&nbsp;     *                                                                         *
<i>5613</i>&nbsp;     **************************************************************************/
<i>5614</i>&nbsp;
<i>5615</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;
<i>5616</i>&nbsp;
<i>5617</i>&nbsp;    public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
<b class="nc"><i>5618</i>&nbsp;        onDragEnteredProperty().set(value);</b>
<b class="nc"><i>5619</i>&nbsp;    }</b>
<i>5620</i>&nbsp;
<i>5621</i>&nbsp;    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
<b class="nc"><i>5622</i>&nbsp;        return onDragEntered == null ? null : onDragEntered.get();</b>
<i>5623</i>&nbsp;    }
<i>5624</i>&nbsp;
<i>5625</i>&nbsp;    /**
<i>5626</i>&nbsp;     * Defines a function to be called when drag gesture
<i>5627</i>&nbsp;     * enters this {@code Scene}.
<i>5628</i>&nbsp;     * @return function to be called when drag gesture enters this scene
<i>5629</i>&nbsp;     */
<i>5630</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
<b class="nc"><i>5631</i>&nbsp;        if (onDragEntered == null) {</b>
<b class="nc"><i>5632</i>&nbsp;            onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {</b>
<i>5633</i>&nbsp;
<i>5634</i>&nbsp;                @Override
<i>5635</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5636</i>&nbsp;                    setEventHandler(DragEvent.DRAG_ENTERED, get());</b>
<b class="nc"><i>5637</i>&nbsp;                }</b>
<i>5638</i>&nbsp;
<i>5639</i>&nbsp;                @Override
<i>5640</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5641</i>&nbsp;                    return Scene.this;</b>
<i>5642</i>&nbsp;                }
<i>5643</i>&nbsp;
<i>5644</i>&nbsp;                @Override
<i>5645</i>&nbsp;                public String getName() {
<b class="nc"><i>5646</i>&nbsp;                    return &quot;onDragEntered&quot;;</b>
<i>5647</i>&nbsp;                }
<i>5648</i>&nbsp;            };
<i>5649</i>&nbsp;        }
<b class="nc"><i>5650</i>&nbsp;        return onDragEntered;</b>
<i>5651</i>&nbsp;    }
<i>5652</i>&nbsp;
<i>5653</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;
<i>5654</i>&nbsp;
<i>5655</i>&nbsp;    public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
<b class="nc"><i>5656</i>&nbsp;        onDragExitedProperty().set(value);</b>
<b class="nc"><i>5657</i>&nbsp;    }</b>
<i>5658</i>&nbsp;
<i>5659</i>&nbsp;    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
<b class="nc"><i>5660</i>&nbsp;        return onDragExited == null ? null : onDragExited.get();</b>
<i>5661</i>&nbsp;    }
<i>5662</i>&nbsp;
<i>5663</i>&nbsp;    /**
<i>5664</i>&nbsp;     * Defines a function to be called when drag gesture
<i>5665</i>&nbsp;     * exits this {@code Scene}.
<i>5666</i>&nbsp;     * @return the function to be called when drag gesture exits this scene
<i>5667</i>&nbsp;     */
<i>5668</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
<b class="nc"><i>5669</i>&nbsp;        if (onDragExited == null) {</b>
<b class="nc"><i>5670</i>&nbsp;            onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {</b>
<i>5671</i>&nbsp;
<i>5672</i>&nbsp;                @Override
<i>5673</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5674</i>&nbsp;                    setEventHandler(DragEvent.DRAG_EXITED, get());</b>
<b class="nc"><i>5675</i>&nbsp;                }</b>
<i>5676</i>&nbsp;
<i>5677</i>&nbsp;                @Override
<i>5678</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5679</i>&nbsp;                    return Scene.this;</b>
<i>5680</i>&nbsp;                }
<i>5681</i>&nbsp;
<i>5682</i>&nbsp;                @Override
<i>5683</i>&nbsp;                public String getName() {
<b class="nc"><i>5684</i>&nbsp;                    return &quot;onDragExited&quot;;</b>
<i>5685</i>&nbsp;                }
<i>5686</i>&nbsp;            };
<i>5687</i>&nbsp;        }
<b class="nc"><i>5688</i>&nbsp;        return onDragExited;</b>
<i>5689</i>&nbsp;    }
<i>5690</i>&nbsp;
<i>5691</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;
<i>5692</i>&nbsp;
<i>5693</i>&nbsp;    public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
<b class="nc"><i>5694</i>&nbsp;        onDragOverProperty().set(value);</b>
<b class="nc"><i>5695</i>&nbsp;    }</b>
<i>5696</i>&nbsp;
<i>5697</i>&nbsp;    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
<b class="nc"><i>5698</i>&nbsp;        return onDragOver == null ? null : onDragOver.get();</b>
<i>5699</i>&nbsp;    }
<i>5700</i>&nbsp;
<i>5701</i>&nbsp;    /**
<i>5702</i>&nbsp;     * Defines a function to be called when drag gesture progresses
<i>5703</i>&nbsp;     * within this {@code Scene}.
<i>5704</i>&nbsp;     * @return the function to be called when drag gesture progresses within
<i>5705</i>&nbsp;     * this scene
<i>5706</i>&nbsp;     */
<i>5707</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
<b class="nc"><i>5708</i>&nbsp;        if (onDragOver == null) {</b>
<b class="nc"><i>5709</i>&nbsp;            onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {</b>
<i>5710</i>&nbsp;
<i>5711</i>&nbsp;                @Override
<i>5712</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5713</i>&nbsp;                    setEventHandler(DragEvent.DRAG_OVER, get());</b>
<b class="nc"><i>5714</i>&nbsp;                }</b>
<i>5715</i>&nbsp;
<i>5716</i>&nbsp;                @Override
<i>5717</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5718</i>&nbsp;                    return Scene.this;</b>
<i>5719</i>&nbsp;                }
<i>5720</i>&nbsp;
<i>5721</i>&nbsp;                @Override
<i>5722</i>&nbsp;                public String getName() {
<b class="nc"><i>5723</i>&nbsp;                    return &quot;onDragOver&quot;;</b>
<i>5724</i>&nbsp;                }
<i>5725</i>&nbsp;            };
<i>5726</i>&nbsp;        }
<b class="nc"><i>5727</i>&nbsp;        return onDragOver;</b>
<i>5728</i>&nbsp;    }
<i>5729</i>&nbsp;
<i>5730</i>&nbsp;    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
<i>5731</i>&nbsp;//    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
<i>5732</i>&nbsp;//
<i>5733</i>&nbsp;//    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
<i>5734</i>&nbsp;//        onDragTransferModeChangedProperty().set(value);
<i>5735</i>&nbsp;//    }
<i>5736</i>&nbsp;//
<i>5737</i>&nbsp;//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
<i>5738</i>&nbsp;//        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
<i>5739</i>&nbsp;//    }
<i>5740</i>&nbsp;//
<i>5741</i>&nbsp;//    /**
<i>5742</i>&nbsp;//     * Defines a function to be called this {@code Scene} if it is a potential
<i>5743</i>&nbsp;//     * drag-and-drop target when the user takes action to change the intended
<i>5744</i>&nbsp;//     * {@code TransferMode}.
<i>5745</i>&nbsp;//     * The user can change the intended {@link TransferMode} by holding down
<i>5746</i>&nbsp;//     * or releasing key modifiers.
<i>5747</i>&nbsp;//     */
<i>5748</i>&nbsp;//    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
<i>5749</i>&nbsp;//        if (onDragTransferModeChanged == null) {
<i>5750</i>&nbsp;//            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
<i>5751</i>&nbsp;//
<i>5752</i>&nbsp;//                @Override
<i>5753</i>&nbsp;//                protected void invalidated() {
<i>5754</i>&nbsp;//                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
<i>5755</i>&nbsp;//                }
<i>5756</i>&nbsp;//            };
<i>5757</i>&nbsp;//        }
<i>5758</i>&nbsp;//        return onDragTransferModeChanged;
<i>5759</i>&nbsp;//    }
<i>5760</i>&nbsp;
<i>5761</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;
<i>5762</i>&nbsp;
<i>5763</i>&nbsp;    public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
<b class="nc"><i>5764</i>&nbsp;        onDragDroppedProperty().set(value);</b>
<b class="nc"><i>5765</i>&nbsp;    }</b>
<i>5766</i>&nbsp;
<i>5767</i>&nbsp;    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
<b class="nc"><i>5768</i>&nbsp;        return onDragDropped == null ? null : onDragDropped.get();</b>
<i>5769</i>&nbsp;    }
<i>5770</i>&nbsp;
<i>5771</i>&nbsp;    /**
<i>5772</i>&nbsp;     * Defines a function to be called when the mouse button is released
<i>5773</i>&nbsp;     * on this {@code Scene} during drag and drop gesture. Transfer of data from
<i>5774</i>&nbsp;     * the {@link DragEvent}&#39;s {@link DragEvent#dragboard dragboard} should
<i>5775</i>&nbsp;     * happen in this function.
<i>5776</i>&nbsp;     * @return the function to be called when the mouse button is released on
<i>5777</i>&nbsp;     * this scene during drag and drop gesture
<i>5778</i>&nbsp;     */
<i>5779</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
<b class="nc"><i>5780</i>&nbsp;        if (onDragDropped == null) {</b>
<b class="nc"><i>5781</i>&nbsp;            onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {</b>
<i>5782</i>&nbsp;
<i>5783</i>&nbsp;                @Override
<i>5784</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5785</i>&nbsp;                    setEventHandler(DragEvent.DRAG_DROPPED, get());</b>
<b class="nc"><i>5786</i>&nbsp;                }</b>
<i>5787</i>&nbsp;
<i>5788</i>&nbsp;                @Override
<i>5789</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5790</i>&nbsp;                    return Scene.this;</b>
<i>5791</i>&nbsp;                }
<i>5792</i>&nbsp;
<i>5793</i>&nbsp;                @Override
<i>5794</i>&nbsp;                public String getName() {
<b class="nc"><i>5795</i>&nbsp;                    return &quot;onDragDropped&quot;;</b>
<i>5796</i>&nbsp;                }
<i>5797</i>&nbsp;            };
<i>5798</i>&nbsp;        }
<b class="nc"><i>5799</i>&nbsp;        return onDragDropped;</b>
<i>5800</i>&nbsp;    }
<i>5801</i>&nbsp;
<i>5802</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;
<i>5803</i>&nbsp;
<i>5804</i>&nbsp;    public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
<b class="nc"><i>5805</i>&nbsp;        onDragDoneProperty().set(value);</b>
<b class="nc"><i>5806</i>&nbsp;    }</b>
<i>5807</i>&nbsp;
<i>5808</i>&nbsp;    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
<b class="nc"><i>5809</i>&nbsp;        return onDragDone == null ? null : onDragDone.get();</b>
<i>5810</i>&nbsp;    }
<i>5811</i>&nbsp;
<i>5812</i>&nbsp;    /**
<i>5813</i>&nbsp;     * Defines a function to be called when this {@code Scene} is a
<i>5814</i>&nbsp;     * drag and drop gesture source after its data has
<i>5815</i>&nbsp;     * been dropped on a drop target. The {@code transferMode} of the
<i>5816</i>&nbsp;     * event shows what just happened at the drop target.
<i>5817</i>&nbsp;     * If {@code transferMode} has the value {@code MOVE}, then the source can
<i>5818</i>&nbsp;     * clear out its data. Clearing the source&#39;s data gives the appropriate
<i>5819</i>&nbsp;     * appearance to a user that the data has been moved by the drag and drop
<i>5820</i>&nbsp;     * gesture. A {@code transferMode} that has the value {@code NONE}
<i>5821</i>&nbsp;     * indicates that no data was transferred during the drag and drop gesture.
<i>5822</i>&nbsp;     * Positional data for the {@code DragEvent} is invalid.  Valid positional
<i>5823</i>&nbsp;     * data for the {@code DragEvent} is presented in the {@link onDragDropped}
<i>5824</i>&nbsp;     * event handler.
<i>5825</i>&nbsp;     * @return the function to be called when this scene is a drag and drop
<i>5826</i>&nbsp;     * gesture source after its data has been dropped on a drop target
<i>5827</i>&nbsp;     */
<i>5828</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
<b class="nc"><i>5829</i>&nbsp;        if (onDragDone == null) {</b>
<b class="nc"><i>5830</i>&nbsp;            onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {</b>
<i>5831</i>&nbsp;
<i>5832</i>&nbsp;                @Override
<i>5833</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5834</i>&nbsp;                    setEventHandler(DragEvent.DRAG_DONE, get());</b>
<b class="nc"><i>5835</i>&nbsp;                }</b>
<i>5836</i>&nbsp;
<i>5837</i>&nbsp;                @Override
<i>5838</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5839</i>&nbsp;                    return Scene.this;</b>
<i>5840</i>&nbsp;                }
<i>5841</i>&nbsp;
<i>5842</i>&nbsp;                @Override
<i>5843</i>&nbsp;                public String getName() {
<b class="nc"><i>5844</i>&nbsp;                    return &quot;onDragDone&quot;;</b>
<i>5845</i>&nbsp;                }
<i>5846</i>&nbsp;            };
<i>5847</i>&nbsp;        }
<b class="nc"><i>5848</i>&nbsp;        return onDragDone;</b>
<i>5849</i>&nbsp;    }
<i>5850</i>&nbsp;
<i>5851</i>&nbsp;    /**
<i>5852</i>&nbsp;     * Confirms a potential drag and drop gesture that is recognized over this
<i>5853</i>&nbsp;     * {@code Scene}.
<i>5854</i>&nbsp;     * Can be called only from a DRAG_DETECTED event handler. The returned
<i>5855</i>&nbsp;     * {@link Dragboard} is used to transfer data during
<i>5856</i>&nbsp;     * the drag and drop gesture. Placing this {@code Scene}&#39;s data on the
<i>5857</i>&nbsp;     * {@link Dragboard} also identifies this {@code Scene} as the source of
<i>5858</i>&nbsp;     * the drag and drop gesture.
<i>5859</i>&nbsp;     * More detail about drag and drop gestures is described in the overivew
<i>5860</i>&nbsp;     * of {@link DragEvent}.
<i>5861</i>&nbsp;     *
<i>5862</i>&nbsp;     * @see DragEvent
<i>5863</i>&nbsp;     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
<i>5864</i>&nbsp;     * @return A {@code Dragboard} to place this {@code Scene}&#39;s data on
<i>5865</i>&nbsp;     * @throws IllegalStateException if drag and drop cannot be started at this
<i>5866</i>&nbsp;     * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling).
<i>5867</i>&nbsp;     */
<i>5868</i>&nbsp;    public Dragboard startDragAndDrop(TransferMode... transferModes) {
<b class="nc"><i>5869</i>&nbsp;        return startDragAndDrop(this, transferModes);</b>
<i>5870</i>&nbsp;    }
<i>5871</i>&nbsp;
<i>5872</i>&nbsp;    /**
<i>5873</i>&nbsp;     * Starts a full press-drag-release gesture with this scene as gesture
<i>5874</i>&nbsp;     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
<i>5875</i>&nbsp;     * event handler. More detail about dragging gestures can be found
<i>5876</i>&nbsp;     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
<i>5877</i>&nbsp;     *
<i>5878</i>&nbsp;     * @see MouseEvent
<i>5879</i>&nbsp;     * @see MouseDragEvent
<i>5880</i>&nbsp;     * @throws IllegalStateException if the full press-drag-release gesture
<i>5881</i>&nbsp;     * cannot be started at this moment (it&#39;s called outside of
<i>5882</i>&nbsp;     * {@code DRAG_DETECTED} event handling).
<i>5883</i>&nbsp;     * @since JavaFX 2.1
<i>5884</i>&nbsp;     */
<i>5885</i>&nbsp;    public void startFullDrag() {
<b class="nc"><i>5886</i>&nbsp;        startFullDrag(this);</b>
<b class="nc"><i>5887</i>&nbsp;    }</b>
<i>5888</i>&nbsp;
<i>5889</i>&nbsp;
<i>5890</i>&nbsp;    Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
<b class="nc"><i>5891</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<b class="nc"><i>5892</i>&nbsp;        if (dndGesture == null ||</b>
<b class="nc"><i>5893</i>&nbsp;            (dndGesture.dragDetected != DragDetectedState.PROCESSING))</b>
<i>5894</i>&nbsp;        {
<b class="nc"><i>5895</i>&nbsp;            throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +</b>
<i>5896</i>&nbsp;                    &quot;outside of DRAG_DETECTED event handler&quot;);
<i>5897</i>&nbsp;        }
<i>5898</i>&nbsp;
<b class="nc"><i>5899</i>&nbsp;        Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);</b>
<b class="nc"><i>5900</i>&nbsp;        for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {</b>
<b class="nc"><i>5901</i>&nbsp;            set.add(tm);</b>
<b class="nc"><i>5902</i>&nbsp;        }</b>
<b class="nc"><i>5903</i>&nbsp;        return dndGesture.startDrag(source, set);</b>
<i>5904</i>&nbsp;    }
<i>5905</i>&nbsp;
<i>5906</i>&nbsp;    void startFullDrag(EventTarget source) {
<b class="nc"><i>5907</i>&nbsp;        Toolkit.getToolkit().checkFxUserThread();</b>
<b class="nc"><i>5908</i>&nbsp;        if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {</b>
<b class="nc"><i>5909</i>&nbsp;            throw new IllegalStateException(&quot;Cannot start full drag &quot; +</b>
<i>5910</i>&nbsp;                    &quot;outside of DRAG_DETECTED event handler&quot;);
<i>5911</i>&nbsp;        }
<i>5912</i>&nbsp;
<b class="nc"><i>5913</i>&nbsp;        if (dndGesture != null) {</b>
<b class="nc"><i>5914</i>&nbsp;            dndGesture.startFullPDR(source);</b>
<b class="nc"><i>5915</i>&nbsp;            return;</b>
<i>5916</i>&nbsp;        }
<i>5917</i>&nbsp;
<b class="nc"><i>5918</i>&nbsp;        throw new IllegalStateException(&quot;Cannot start full drag when &quot;</b>
<i>5919</i>&nbsp;                + &quot;mouse button is not pressed&quot;);
<i>5920</i>&nbsp;    }
<i>5921</i>&nbsp;
<i>5922</i>&nbsp;    /***************************************************************************
<i>5923</i>&nbsp;     *                                                                         *
<i>5924</i>&nbsp;     *                           Keyboard Handling                             *
<i>5925</i>&nbsp;     *                                                                         *
<i>5926</i>&nbsp;     **************************************************************************/
<i>5927</i>&nbsp;
<i>5928</i>&nbsp;    /**
<i>5929</i>&nbsp;     * Defines a function to be called when some {@code Node} of this
<i>5930</i>&nbsp;     * {@code Scene} has input focus and a key has been pressed. The function
<i>5931</i>&nbsp;     * is called only if the event hasn&#39;t been already consumed during its
<i>5932</i>&nbsp;     * capturing or bubbling phase.
<i>5933</i>&nbsp;     */
<i>5934</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;
<i>5935</i>&nbsp;
<i>5936</i>&nbsp;    public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
<b class="nc"><i>5937</i>&nbsp;        onKeyPressedProperty().set(value);</b>
<b class="nc"><i>5938</i>&nbsp;    }</b>
<i>5939</i>&nbsp;
<i>5940</i>&nbsp;    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
<b class="nc"><i>5941</i>&nbsp;        return onKeyPressed == null ? null : onKeyPressed.get();</b>
<i>5942</i>&nbsp;    }
<i>5943</i>&nbsp;
<i>5944</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
<b class="nc"><i>5945</i>&nbsp;        if (onKeyPressed == null) {</b>
<b class="nc"><i>5946</i>&nbsp;            onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {</b>
<i>5947</i>&nbsp;
<i>5948</i>&nbsp;                @Override
<i>5949</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5950</i>&nbsp;                    setEventHandler(KeyEvent.KEY_PRESSED, get());</b>
<b class="nc"><i>5951</i>&nbsp;                }</b>
<i>5952</i>&nbsp;
<i>5953</i>&nbsp;                @Override
<i>5954</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5955</i>&nbsp;                    return Scene.this;</b>
<i>5956</i>&nbsp;                }
<i>5957</i>&nbsp;
<i>5958</i>&nbsp;                @Override
<i>5959</i>&nbsp;                public String getName() {
<b class="nc"><i>5960</i>&nbsp;                    return &quot;onKeyPressed&quot;;</b>
<i>5961</i>&nbsp;                }
<i>5962</i>&nbsp;            };
<i>5963</i>&nbsp;        }
<b class="nc"><i>5964</i>&nbsp;        return onKeyPressed;</b>
<i>5965</i>&nbsp;    }
<i>5966</i>&nbsp;
<i>5967</i>&nbsp;    /**
<i>5968</i>&nbsp;     * Defines a function to be called when some {@code Node} of this
<i>5969</i>&nbsp;     * {@code Scene} has input focus and a key has been released. The function
<i>5970</i>&nbsp;     * is called only if the event hasn&#39;t been already consumed during its
<i>5971</i>&nbsp;     * capturing or bubbling phase.
<i>5972</i>&nbsp;     */
<i>5973</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;
<i>5974</i>&nbsp;
<i>5975</i>&nbsp;    public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
<b class="nc"><i>5976</i>&nbsp;        onKeyReleasedProperty().set(value);</b>
<b class="nc"><i>5977</i>&nbsp;    }</b>
<i>5978</i>&nbsp;
<i>5979</i>&nbsp;    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
<b class="nc"><i>5980</i>&nbsp;        return onKeyReleased == null ? null : onKeyReleased.get();</b>
<i>5981</i>&nbsp;    }
<i>5982</i>&nbsp;
<i>5983</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
<b class="nc"><i>5984</i>&nbsp;        if (onKeyReleased == null) {</b>
<b class="nc"><i>5985</i>&nbsp;            onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {</b>
<i>5986</i>&nbsp;
<i>5987</i>&nbsp;                @Override
<i>5988</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>5989</i>&nbsp;                    setEventHandler(KeyEvent.KEY_RELEASED, get());</b>
<b class="nc"><i>5990</i>&nbsp;                }</b>
<i>5991</i>&nbsp;
<i>5992</i>&nbsp;                @Override
<i>5993</i>&nbsp;                public Object getBean() {
<b class="nc"><i>5994</i>&nbsp;                    return Scene.this;</b>
<i>5995</i>&nbsp;                }
<i>5996</i>&nbsp;
<i>5997</i>&nbsp;                @Override
<i>5998</i>&nbsp;                public String getName() {
<b class="nc"><i>5999</i>&nbsp;                    return &quot;onKeyReleased&quot;;</b>
<i>6000</i>&nbsp;                }
<i>6001</i>&nbsp;            };
<i>6002</i>&nbsp;        }
<b class="nc"><i>6003</i>&nbsp;        return onKeyReleased;</b>
<i>6004</i>&nbsp;    }
<i>6005</i>&nbsp;
<i>6006</i>&nbsp;    /**
<i>6007</i>&nbsp;     * Defines a function to be called when some {@code Node} of this
<i>6008</i>&nbsp;     * {@code Scene} has input focus and a key has been typed. The function
<i>6009</i>&nbsp;     * is called only if the event hasn&#39;t been already consumed during its
<i>6010</i>&nbsp;     * capturing or bubbling phase.
<i>6011</i>&nbsp;     */
<i>6012</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;
<i>6013</i>&nbsp;
<i>6014</i>&nbsp;    public final void setOnKeyTyped(
<i>6015</i>&nbsp;            EventHandler&lt;? super KeyEvent&gt; value) {
<b class="nc"><i>6016</i>&nbsp;        onKeyTypedProperty().set( value);</b>
<i>6017</i>&nbsp;
<b class="nc"><i>6018</i>&nbsp;    }</b>
<i>6019</i>&nbsp;
<i>6020</i>&nbsp;    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
<i>6021</i>&nbsp;            ) {
<b class="nc"><i>6022</i>&nbsp;        return onKeyTyped == null ? null : onKeyTyped.get();</b>
<i>6023</i>&nbsp;    }
<i>6024</i>&nbsp;
<i>6025</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
<i>6026</i>&nbsp;    ) {
<b class="nc"><i>6027</i>&nbsp;        if (onKeyTyped == null) {</b>
<b class="nc"><i>6028</i>&nbsp;            onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {</b>
<i>6029</i>&nbsp;
<i>6030</i>&nbsp;                @Override
<i>6031</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>6032</i>&nbsp;                    setEventHandler(KeyEvent.KEY_TYPED, get());</b>
<b class="nc"><i>6033</i>&nbsp;                }</b>
<i>6034</i>&nbsp;
<i>6035</i>&nbsp;                @Override
<i>6036</i>&nbsp;                public Object getBean() {
<b class="nc"><i>6037</i>&nbsp;                    return Scene.this;</b>
<i>6038</i>&nbsp;                }
<i>6039</i>&nbsp;
<i>6040</i>&nbsp;                @Override
<i>6041</i>&nbsp;                public String getName() {
<b class="nc"><i>6042</i>&nbsp;                    return &quot;onKeyTyped&quot;;</b>
<i>6043</i>&nbsp;                }
<i>6044</i>&nbsp;            };
<i>6045</i>&nbsp;        }
<b class="nc"><i>6046</i>&nbsp;        return onKeyTyped;</b>
<i>6047</i>&nbsp;    }
<i>6048</i>&nbsp;
<i>6049</i>&nbsp;    /***************************************************************************
<i>6050</i>&nbsp;     *                                                                         *
<i>6051</i>&nbsp;     *                           Input Method Handling                         *
<i>6052</i>&nbsp;     *                                                                         *
<i>6053</i>&nbsp;     **************************************************************************/
<i>6054</i>&nbsp;
<i>6055</i>&nbsp;    /**
<i>6056</i>&nbsp;     * Defines a function to be called when this {@code Node}
<i>6057</i>&nbsp;     * has input focus and the input method text has changed.  If this
<i>6058</i>&nbsp;     * function is not defined in this {@code Node}, then it
<i>6059</i>&nbsp;     * receives the result string of the input method composition as a
<i>6060</i>&nbsp;     * series of {@code onKeyTyped} function calls.
<i>6061</i>&nbsp;     * &lt;p&gt;
<i>6062</i>&nbsp;     * When the {@code Node} loses the input focus, the JavaFX runtime
<i>6063</i>&nbsp;     * automatically commits the existing composed text if any.
<i>6064</i>&nbsp;     */
<i>6065</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;
<i>6066</i>&nbsp;
<i>6067</i>&nbsp;    public final void setOnInputMethodTextChanged(
<i>6068</i>&nbsp;            EventHandler&lt;? super InputMethodEvent&gt; value) {
<b class="nc"><i>6069</i>&nbsp;        onInputMethodTextChangedProperty().set( value);</b>
<b class="nc"><i>6070</i>&nbsp;    }</b>
<i>6071</i>&nbsp;
<i>6072</i>&nbsp;    public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
<b class="nc"><i>6073</i>&nbsp;        return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();</b>
<i>6074</i>&nbsp;    }
<i>6075</i>&nbsp;
<i>6076</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
<b class="nc"><i>6077</i>&nbsp;        if (onInputMethodTextChanged == null) {</b>
<b class="nc"><i>6078</i>&nbsp;            onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {</b>
<i>6079</i>&nbsp;
<i>6080</i>&nbsp;                @Override
<i>6081</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>6082</i>&nbsp;                    setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());</b>
<b class="nc"><i>6083</i>&nbsp;                }</b>
<i>6084</i>&nbsp;
<i>6085</i>&nbsp;                @Override
<i>6086</i>&nbsp;                public Object getBean() {
<b class="nc"><i>6087</i>&nbsp;                    return Scene.this;</b>
<i>6088</i>&nbsp;                }
<i>6089</i>&nbsp;
<i>6090</i>&nbsp;                @Override
<i>6091</i>&nbsp;                public String getName() {
<b class="nc"><i>6092</i>&nbsp;                    return &quot;onInputMethodTextChanged&quot;;</b>
<i>6093</i>&nbsp;                }
<i>6094</i>&nbsp;            };
<i>6095</i>&nbsp;        }
<b class="nc"><i>6096</i>&nbsp;        return onInputMethodTextChanged;</b>
<i>6097</i>&nbsp;    }
<i>6098</i>&nbsp;
<i>6099</i>&nbsp;    /*
<i>6100</i>&nbsp;     * This class represents a picked target - either node, or scne, or null.
<i>6101</i>&nbsp;     * It provides functionality needed for the targets and covers the fact
<i>6102</i>&nbsp;     * that they are different kinds of animals.
<i>6103</i>&nbsp;     */
<b class="fc"><i>6104</i>&nbsp;    private static class TargetWrapper {</b>
<i>6105</i>&nbsp;        private Scene scene;
<i>6106</i>&nbsp;        private Node node;
<i>6107</i>&nbsp;        private PickResult result;
<i>6108</i>&nbsp;
<i>6109</i>&nbsp;        /**
<i>6110</i>&nbsp;         * Fills the list with the target and all its parents (including scene)
<i>6111</i>&nbsp;         */
<i>6112</i>&nbsp;        public void fillHierarchy(final List&lt;EventTarget&gt; list) {
<b class="fc"><i>6113</i>&nbsp;            list.clear();</b>
<b class="fc"><i>6114</i>&nbsp;            Node n = node;</b>
<b class="fc"><i>6115</i>&nbsp;            while(n != null) {</b>
<b class="fc"><i>6116</i>&nbsp;                list.add(n);</b>
<b class="fc"><i>6117</i>&nbsp;                final Parent p = n.getParent();</b>
<b class="fc"><i>6118</i>&nbsp;                n = p != null ? p : n.getSubScene();</b>
<b class="fc"><i>6119</i>&nbsp;            }</b>
<i>6120</i>&nbsp;
<b class="fc"><i>6121</i>&nbsp;            if (scene != null) {</b>
<b class="fc"><i>6122</i>&nbsp;                list.add(scene);</b>
<i>6123</i>&nbsp;            }
<b class="fc"><i>6124</i>&nbsp;        }</b>
<i>6125</i>&nbsp;
<i>6126</i>&nbsp;        public EventTarget getEventTarget() {
<b class="fc"><i>6127</i>&nbsp;            return node != null ? node : scene;</b>
<i>6128</i>&nbsp;        }
<i>6129</i>&nbsp;
<i>6130</i>&nbsp;        public Cursor getCursor() {
<b class="fc"><i>6131</i>&nbsp;            Cursor cursor = null;</b>
<b class="fc"><i>6132</i>&nbsp;            if (node != null) {</b>
<b class="fc"><i>6133</i>&nbsp;                cursor = node.getCursor();</b>
<b class="fc"><i>6134</i>&nbsp;                Node n = node.getParent();</b>
<b class="fc"><i>6135</i>&nbsp;                while (cursor == null &amp;&amp; n != null) {</b>
<b class="fc"><i>6136</i>&nbsp;                    cursor = n.getCursor();</b>
<i>6137</i>&nbsp;
<b class="fc"><i>6138</i>&nbsp;                    final Parent p = n.getParent();</b>
<b class="fc"><i>6139</i>&nbsp;                    n = p != null ? p : n.getSubScene();</b>
<b class="fc"><i>6140</i>&nbsp;                }</b>
<i>6141</i>&nbsp;            }
<b class="fc"><i>6142</i>&nbsp;            return cursor;</b>
<i>6143</i>&nbsp;        }
<i>6144</i>&nbsp;
<i>6145</i>&nbsp;        public void clear() {
<b class="fc"><i>6146</i>&nbsp;            set(null, null);</b>
<b class="fc"><i>6147</i>&nbsp;            result = null;</b>
<b class="fc"><i>6148</i>&nbsp;        }</b>
<i>6149</i>&nbsp;
<i>6150</i>&nbsp;        public void setNodeResult(PickResult result) {
<b class="fc"><i>6151</i>&nbsp;            if (result != null) {</b>
<b class="fc"><i>6152</i>&nbsp;                this.result = result;</b>
<b class="fc"><i>6153</i>&nbsp;                final Node n = result.getIntersectedNode();</b>
<b class="fc"><i>6154</i>&nbsp;                set(n, n.getScene());</b>
<i>6155</i>&nbsp;            }
<b class="fc"><i>6156</i>&nbsp;        }</b>
<i>6157</i>&nbsp;
<i>6158</i>&nbsp;        // Pass null scene if the mouse is outside of the window content
<i>6159</i>&nbsp;        public void setSceneResult(PickResult result, Scene scene) {
<b class="fc"><i>6160</i>&nbsp;            if (result != null) {</b>
<b class="fc"><i>6161</i>&nbsp;                this.result = result;</b>
<b class="fc"><i>6162</i>&nbsp;                set(null, scene);</b>
<i>6163</i>&nbsp;            }
<b class="fc"><i>6164</i>&nbsp;        }</b>
<i>6165</i>&nbsp;
<i>6166</i>&nbsp;        public PickResult getResult() {
<b class="fc"><i>6167</i>&nbsp;            return result;</b>
<i>6168</i>&nbsp;        }
<i>6169</i>&nbsp;
<i>6170</i>&nbsp;        public void copy(TargetWrapper tw) {
<b class="fc"><i>6171</i>&nbsp;            node = tw.node;</b>
<b class="fc"><i>6172</i>&nbsp;            scene = tw.scene;</b>
<b class="fc"><i>6173</i>&nbsp;            result = tw.result;</b>
<b class="fc"><i>6174</i>&nbsp;        }</b>
<i>6175</i>&nbsp;
<i>6176</i>&nbsp;        private void set(Node n, Scene s) {
<b class="fc"><i>6177</i>&nbsp;            node = n;</b>
<b class="fc"><i>6178</i>&nbsp;            scene = s;</b>
<b class="fc"><i>6179</i>&nbsp;        }</b>
<i>6180</i>&nbsp;    }
<i>6181</i>&nbsp;
<i>6182</i>&nbsp;    /*************************************************************************
<i>6183</i>&nbsp;    *                                                                        *
<i>6184</i>&nbsp;    *                                                                        *
<i>6185</i>&nbsp;    *                                                                        *
<i>6186</i>&nbsp;    *************************************************************************/
<i>6187</i>&nbsp;
<b class="fc"><i>6188</i>&nbsp;    private static final Object USER_DATA_KEY = new Object();</b>
<i>6189</i>&nbsp;    // A map containing a set of properties for this scene
<i>6190</i>&nbsp;    private ObservableMap&lt;Object, Object&gt; properties;
<i>6191</i>&nbsp;
<i>6192</i>&nbsp;    /**
<i>6193</i>&nbsp;      * Returns an observable map of properties on this node for use primarily
<i>6194</i>&nbsp;      * by application developers.
<i>6195</i>&nbsp;      *
<i>6196</i>&nbsp;      * @return an observable map of properties on this node for use primarily
<i>6197</i>&nbsp;      * by application developers
<i>6198</i>&nbsp;      *
<i>6199</i>&nbsp;      * @since JavaFX 8u40
<i>6200</i>&nbsp;      */
<i>6201</i>&nbsp;     public final ObservableMap&lt;Object, Object&gt; getProperties() {
<b class="nc"><i>6202</i>&nbsp;        if (properties == null) {</b>
<b class="nc"><i>6203</i>&nbsp;            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());</b>
<i>6204</i>&nbsp;        }
<b class="nc"><i>6205</i>&nbsp;        return properties;</b>
<i>6206</i>&nbsp;    }
<i>6207</i>&nbsp;
<i>6208</i>&nbsp;    /**
<i>6209</i>&nbsp;     * Tests if Scene has properties.
<i>6210</i>&nbsp;     * @return true if node has properties.
<i>6211</i>&nbsp;     *
<i>6212</i>&nbsp;     * @since JavaFX 8u40
<i>6213</i>&nbsp;     */
<i>6214</i>&nbsp;     public boolean hasProperties() {
<b class="nc"><i>6215</i>&nbsp;        return properties != null &amp;&amp; !properties.isEmpty();</b>
<i>6216</i>&nbsp;    }
<i>6217</i>&nbsp;
<i>6218</i>&nbsp;    /**
<i>6219</i>&nbsp;     * Convenience method for setting a single Object property that can be
<i>6220</i>&nbsp;     * retrieved at a later date. This is functionally equivalent to calling
<i>6221</i>&nbsp;     * the getProperties().put(Object key, Object value) method. This can later
<i>6222</i>&nbsp;     * be retrieved by calling {@link Scene#getUserData()}.
<i>6223</i>&nbsp;     *
<i>6224</i>&nbsp;     * @param value The value to be stored - this can later be retrieved by calling
<i>6225</i>&nbsp;     *          {@link Scene#getUserData()}.
<i>6226</i>&nbsp;     *
<i>6227</i>&nbsp;     * @since JavaFX 8u40
<i>6228</i>&nbsp;     */
<i>6229</i>&nbsp;    public void setUserData(Object value) {
<b class="nc"><i>6230</i>&nbsp;        getProperties().put(USER_DATA_KEY, value);</b>
<b class="nc"><i>6231</i>&nbsp;    }</b>
<i>6232</i>&nbsp;
<i>6233</i>&nbsp;    /**
<i>6234</i>&nbsp;     * Returns a previously set Object property, or null if no such property
<i>6235</i>&nbsp;     * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
<i>6236</i>&nbsp;     *
<i>6237</i>&nbsp;     * @return The Object that was previously set, or null if no property
<i>6238</i>&nbsp;     *          has been set or if null was set.
<i>6239</i>&nbsp;     *
<i>6240</i>&nbsp;     * @since JavaFX 8u40
<i>6241</i>&nbsp;     */
<i>6242</i>&nbsp;    public Object getUserData() {
<b class="nc"><i>6243</i>&nbsp;        return getProperties().get(USER_DATA_KEY);</b>
<i>6244</i>&nbsp;    }
<i>6245</i>&nbsp;
<i>6246</i>&nbsp;    /***************************************************************************
<i>6247</i>&nbsp;     *                                                                         *
<i>6248</i>&nbsp;     *                       Component Orientation Properties                  *
<i>6249</i>&nbsp;     *                                                                         *
<i>6250</i>&nbsp;     **************************************************************************/
<i>6251</i>&nbsp;
<b class="fc"><i>6252</i>&nbsp;    private static final NodeOrientation defaultNodeOrientation =</b>
<b class="fc"><i>6253</i>&nbsp;        AccessController.doPrivileged(</b>
<b class="fc"><i>6254</i>&nbsp;                (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;</b>
<i>6255</i>&nbsp;
<i>6256</i>&nbsp;
<i>6257</i>&nbsp;
<i>6258</i>&nbsp;    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
<i>6259</i>&nbsp;    private EffectiveOrientationProperty effectiveNodeOrientationProperty;
<i>6260</i>&nbsp;
<i>6261</i>&nbsp;    private NodeOrientation effectiveNodeOrientation;
<i>6262</i>&nbsp;
<i>6263</i>&nbsp;    public final void setNodeOrientation(NodeOrientation orientation) {
<b class="fc"><i>6264</i>&nbsp;        nodeOrientationProperty().set(orientation);</b>
<b class="fc"><i>6265</i>&nbsp;    }</b>
<i>6266</i>&nbsp;
<i>6267</i>&nbsp;    public final NodeOrientation getNodeOrientation() {
<b class="fc"><i>6268</i>&nbsp;        return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();</b>
<i>6269</i>&nbsp;    }
<i>6270</i>&nbsp;
<i>6271</i>&nbsp;    /**
<i>6272</i>&nbsp;     * Property holding NodeOrientation.
<i>6273</i>&nbsp;     * &lt;p&gt;
<i>6274</i>&nbsp;     * Node orientation describes the flow of visual data within a node.
<i>6275</i>&nbsp;     * In the English speaking world, visual data normally flows from
<i>6276</i>&nbsp;     * left-to-right. In an Arabic or Hebrew world, visual data flows
<i>6277</i>&nbsp;     * from right-to-left.  This is consistent with the reading order
<i>6278</i>&nbsp;     * of text in both worlds.  The default value is left-to-right.
<i>6279</i>&nbsp;     * &lt;/p&gt;
<i>6280</i>&nbsp;     *
<i>6281</i>&nbsp;     * @return NodeOrientation
<i>6282</i>&nbsp;     * @since JavaFX 8.0
<i>6283</i>&nbsp;     */
<i>6284</i>&nbsp;    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
<b class="fc"><i>6285</i>&nbsp;        if (nodeOrientation == null) {</b>
<b class="fc"><i>6286</i>&nbsp;            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {</b>
<i>6287</i>&nbsp;                @Override
<i>6288</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>6289</i>&nbsp;                    sceneEffectiveOrientationInvalidated();</b>
<b class="fc"><i>6290</i>&nbsp;                    getRoot().applyCss();</b>
<b class="fc"><i>6291</i>&nbsp;                }</b>
<i>6292</i>&nbsp;
<i>6293</i>&nbsp;                @Override
<i>6294</i>&nbsp;                public Object getBean() {
<b class="nc"><i>6295</i>&nbsp;                    return Scene.this;</b>
<i>6296</i>&nbsp;                }
<i>6297</i>&nbsp;
<i>6298</i>&nbsp;                @Override
<i>6299</i>&nbsp;                public String getName() {
<b class="nc"><i>6300</i>&nbsp;                    return &quot;nodeOrientation&quot;;</b>
<i>6301</i>&nbsp;                }
<i>6302</i>&nbsp;
<i>6303</i>&nbsp;                @Override
<i>6304</i>&nbsp;                public CssMetaData getCssMetaData() {
<i>6305</i>&nbsp;                    //TODO - not yet supported
<b class="nc"><i>6306</i>&nbsp;                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</b>
<i>6307</i>&nbsp;                }
<i>6308</i>&nbsp;            };
<i>6309</i>&nbsp;        }
<b class="fc"><i>6310</i>&nbsp;        return nodeOrientation;</b>
<i>6311</i>&nbsp;    }
<i>6312</i>&nbsp;
<i>6313</i>&nbsp;    public final NodeOrientation getEffectiveNodeOrientation() {
<b class="fc"><i>6314</i>&nbsp;        if (effectiveNodeOrientation == null) {</b>
<b class="fc"><i>6315</i>&nbsp;            effectiveNodeOrientation = calcEffectiveNodeOrientation();</b>
<i>6316</i>&nbsp;        }
<i>6317</i>&nbsp;
<b class="fc"><i>6318</i>&nbsp;        return effectiveNodeOrientation;</b>
<i>6319</i>&nbsp;    }
<i>6320</i>&nbsp;
<i>6321</i>&nbsp;    /**
<i>6322</i>&nbsp;     * The effective node orientation of a scene resolves the inheritance of
<i>6323</i>&nbsp;     * node orientation, returning either left-to-right or right-to-left.
<i>6324</i>&nbsp;     * @return the effective node orientation of this scene
<i>6325</i>&nbsp;     * @since JavaFX 8.0
<i>6326</i>&nbsp;     */
<i>6327</i>&nbsp;    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
<i>6328</i>&nbsp;            effectiveNodeOrientationProperty() {
<b class="nc"><i>6329</i>&nbsp;        if (effectiveNodeOrientationProperty == null) {</b>
<b class="nc"><i>6330</i>&nbsp;            effectiveNodeOrientationProperty =</b>
<i>6331</i>&nbsp;                    new EffectiveOrientationProperty();
<i>6332</i>&nbsp;        }
<i>6333</i>&nbsp;
<b class="nc"><i>6334</i>&nbsp;        return effectiveNodeOrientationProperty;</b>
<i>6335</i>&nbsp;    }
<i>6336</i>&nbsp;
<i>6337</i>&nbsp;    private void parentEffectiveOrientationInvalidated() {
<b class="fc"><i>6338</i>&nbsp;        if (getNodeOrientation() == NodeOrientation.INHERIT) {</b>
<b class="fc"><i>6339</i>&nbsp;            sceneEffectiveOrientationInvalidated();</b>
<i>6340</i>&nbsp;        }
<b class="fc"><i>6341</i>&nbsp;    }</b>
<i>6342</i>&nbsp;
<i>6343</i>&nbsp;    private void sceneEffectiveOrientationInvalidated() {
<b class="fc"><i>6344</i>&nbsp;        effectiveNodeOrientation = null;</b>
<i>6345</i>&nbsp;
<b class="fc"><i>6346</i>&nbsp;        if (effectiveNodeOrientationProperty != null) {</b>
<b class="nc"><i>6347</i>&nbsp;            effectiveNodeOrientationProperty.invalidate();</b>
<i>6348</i>&nbsp;        }
<i>6349</i>&nbsp;
<b class="fc"><i>6350</i>&nbsp;        getRoot().parentResolvedOrientationInvalidated();</b>
<b class="fc"><i>6351</i>&nbsp;    }</b>
<i>6352</i>&nbsp;
<i>6353</i>&nbsp;    private NodeOrientation calcEffectiveNodeOrientation() {
<b class="fc"><i>6354</i>&nbsp;        NodeOrientation orientation = getNodeOrientation();</b>
<b class="fc"><i>6355</i>&nbsp;        if (orientation == NodeOrientation.INHERIT) {</b>
<b class="fc"><i>6356</i>&nbsp;            Window window = getWindow();</b>
<b class="fc"><i>6357</i>&nbsp;            if (window != null) {</b>
<b class="fc"><i>6358</i>&nbsp;                Window parent = null;</b>
<b class="fc"><i>6359</i>&nbsp;                if (window instanceof Stage) {</b>
<b class="fc"><i>6360</i>&nbsp;                    parent = ((Stage)window).getOwner();</b>
<i>6361</i>&nbsp;                } else {
<b class="fc"><i>6362</i>&nbsp;                    if (window instanceof PopupWindow) {</b>
<b class="fc"><i>6363</i>&nbsp;                        parent = ((PopupWindow)window).getOwnerWindow();</b>
<i>6364</i>&nbsp;                    }
<i>6365</i>&nbsp;                }
<b class="fc"><i>6366</i>&nbsp;                if (parent != null) {</b>
<b class="nc"><i>6367</i>&nbsp;                    Scene scene = parent.getScene();</b>
<b class="nc"><i>6368</i>&nbsp;                    if (scene != null) return scene.getEffectiveNodeOrientation();</b>
<i>6369</i>&nbsp;                }
<i>6370</i>&nbsp;            }
<b class="fc"><i>6371</i>&nbsp;            return NodeOrientation.LEFT_TO_RIGHT;</b>
<i>6372</i>&nbsp;        }
<b class="fc"><i>6373</i>&nbsp;        return orientation;</b>
<i>6374</i>&nbsp;    }
<i>6375</i>&nbsp;
<b class="nc"><i>6376</i>&nbsp;    private final class EffectiveOrientationProperty</b>
<i>6377</i>&nbsp;            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
<i>6378</i>&nbsp;        @Override
<i>6379</i>&nbsp;        public NodeOrientation get() {
<b class="nc"><i>6380</i>&nbsp;            return getEffectiveNodeOrientation();</b>
<i>6381</i>&nbsp;        }
<i>6382</i>&nbsp;
<i>6383</i>&nbsp;        @Override
<i>6384</i>&nbsp;        public Object getBean() {
<b class="nc"><i>6385</i>&nbsp;            return Scene.this;</b>
<i>6386</i>&nbsp;        }
<i>6387</i>&nbsp;
<i>6388</i>&nbsp;        @Override
<i>6389</i>&nbsp;        public String getName() {
<b class="nc"><i>6390</i>&nbsp;            return &quot;effectiveNodeOrientation&quot;;</b>
<i>6391</i>&nbsp;        }
<i>6392</i>&nbsp;
<i>6393</i>&nbsp;        public void invalidate() {
<b class="nc"><i>6394</i>&nbsp;            fireValueChangedEvent();</b>
<b class="nc"><i>6395</i>&nbsp;        }</b>
<i>6396</i>&nbsp;    }
<i>6397</i>&nbsp;
<i>6398</i>&nbsp;    private Map&lt;Node, Accessible&gt; accMap;
<i>6399</i>&nbsp;    Accessible removeAccessible(Node node) {
<b class="fc"><i>6400</i>&nbsp;        if (accMap == null) return null;</b>
<b class="nc"><i>6401</i>&nbsp;        return accMap.remove(node);</b>
<i>6402</i>&nbsp;    }
<i>6403</i>&nbsp;
<i>6404</i>&nbsp;    void addAccessible(Node node, Accessible acc) {
<b class="nc"><i>6405</i>&nbsp;        if (accMap == null) {</b>
<b class="nc"><i>6406</i>&nbsp;            accMap = new HashMap&lt;Node, Accessible&gt;();</b>
<i>6407</i>&nbsp;        }
<b class="nc"><i>6408</i>&nbsp;        accMap.put(node, acc);</b>
<b class="nc"><i>6409</i>&nbsp;    }</b>
<i>6410</i>&nbsp;
<i>6411</i>&nbsp;    private void disposeAccessibles() {
<b class="fc"><i>6412</i>&nbsp;        if (accMap != null) {</b>
<b class="nc"><i>6413</i>&nbsp;            for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {</b>
<b class="nc"><i>6414</i>&nbsp;                Node node = entry.getKey();</b>
<b class="nc"><i>6415</i>&nbsp;                Accessible acc = entry.getValue();</b>
<b class="nc"><i>6416</i>&nbsp;                if (node.accessible != null) {</b>
<i>6417</i>&nbsp;                    /* This node has already been initialized to another scene.
<i>6418</i>&nbsp;                     * Note an accessible can be returned to the node before the
<i>6419</i>&nbsp;                     * pulse if getAccessible() is called. In which case it must
<i>6420</i>&nbsp;                     * already being removed from accMap.
<i>6421</i>&nbsp;                     */
<b class="nc"><i>6422</i>&nbsp;                    if (node.accessible == acc) {</b>
<b class="nc"><i>6423</i>&nbsp;                        System.err.println(&quot;[A11y] &#39;node.accessible == acc&#39; should never happen.&quot;);</b>
<i>6424</i>&nbsp;                    }
<b class="nc"><i>6425</i>&nbsp;                    if (node.getScene() == this) {</b>
<b class="nc"><i>6426</i>&nbsp;                        System.err.println(&quot;[A11y] &#39;node.getScene() == this&#39; should never happen.&quot;);</b>
<i>6427</i>&nbsp;                    }
<b class="nc"><i>6428</i>&nbsp;                    acc.dispose();</b>
<i>6429</i>&nbsp;                } else {
<b class="nc"><i>6430</i>&nbsp;                    if (node.getScene() == this) {</b>
<b class="nc"><i>6431</i>&nbsp;                        node.accessible = acc;</b>
<i>6432</i>&nbsp;                    } else {
<b class="nc"><i>6433</i>&nbsp;                        acc.dispose();</b>
<i>6434</i>&nbsp;                    }
<i>6435</i>&nbsp;                }
<b class="nc"><i>6436</i>&nbsp;            }</b>
<b class="nc"><i>6437</i>&nbsp;            accMap.clear();</b>
<i>6438</i>&nbsp;        }
<b class="fc"><i>6439</i>&nbsp;    }</b>
<i>6440</i>&nbsp;
<i>6441</i>&nbsp;    private Accessible accessible;
<i>6442</i>&nbsp;    Accessible getAccessible() {
<i>6443</i>&nbsp;        /*
<i>6444</i>&nbsp;         * The accessible for the Scene should never be
<i>6445</i>&nbsp;         * requested when the peer is not set.
<i>6446</i>&nbsp;         * This can only happen in a error case where a
<i>6447</i>&nbsp;         * descender of this Scene was not disposed and
<i>6448</i>&nbsp;         * it still being used by the AT client and trying
<i>6449</i>&nbsp;         * to reach to the top level window.
<i>6450</i>&nbsp;         */
<b class="nc"><i>6451</i>&nbsp;        if (peer == null) return null;</b>
<b class="nc"><i>6452</i>&nbsp;        if (accessible == null) {</b>
<b class="nc"><i>6453</i>&nbsp;            accessible = Application.GetApplication().createAccessible();</b>
<b class="nc"><i>6454</i>&nbsp;            accessible.setEventHandler(new Accessible.EventHandler() {</b>
<i>6455</i>&nbsp;                @Override public AccessControlContext getAccessControlContext() {
<b class="nc"><i>6456</i>&nbsp;                    return getPeer().getAccessControlContext();</b>
<i>6457</i>&nbsp;                }
<i>6458</i>&nbsp;
<i>6459</i>&nbsp;                @Override public Object getAttribute(AccessibleAttribute attribute,
<i>6460</i>&nbsp;                                                     Object... parameters) {
<b class="nc"><i>6461</i>&nbsp;                    switch (attribute) {</b>
<i>6462</i>&nbsp;                        case CHILDREN: {
<b class="nc"><i>6463</i>&nbsp;                            Parent root = getRoot();</b>
<b class="nc"><i>6464</i>&nbsp;                            if (root != null) {</b>
<b class="nc"><i>6465</i>&nbsp;                                return FXCollections.observableArrayList(root);</b>
<i>6466</i>&nbsp;                            }
<i>6467</i>&nbsp;                            break;
<i>6468</i>&nbsp;                        }
<i>6469</i>&nbsp;                        case TEXT: {
<b class="nc"><i>6470</i>&nbsp;                            Window w = getWindow();</b>
<b class="nc"><i>6471</i>&nbsp;                            if (w instanceof Stage) {</b>
<b class="nc"><i>6472</i>&nbsp;                                return ((Stage)w).getTitle();</b>
<i>6473</i>&nbsp;                            }
<i>6474</i>&nbsp;                            break;
<i>6475</i>&nbsp;                        }
<i>6476</i>&nbsp;                        case NODE_AT_POINT: {
<b class="nc"><i>6477</i>&nbsp;                            Window window = getWindow();</b>
<i>6478</i>&nbsp;                            /* is this screen to scene translation correct ? not considering camera ? */
<b class="nc"><i>6479</i>&nbsp;                            Point2D pt = (Point2D)parameters[0];</b>
<b class="nc"><i>6480</i>&nbsp;                            PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());</b>
<b class="nc"><i>6481</i>&nbsp;                            if (res != null) {</b>
<b class="nc"><i>6482</i>&nbsp;                                Node node = res.getIntersectedNode();</b>
<b class="nc"><i>6483</i>&nbsp;                                if (node != null) return node;</b>
<i>6484</i>&nbsp;                            }
<b class="nc"><i>6485</i>&nbsp;                            return getRoot();//not sure</b>
<i>6486</i>&nbsp;                        }
<b class="nc"><i>6487</i>&nbsp;                        case ROLE: return AccessibleRole.PARENT;</b>
<b class="nc"><i>6488</i>&nbsp;                        case SCENE: return Scene.this;</b>
<i>6489</i>&nbsp;                        case FOCUS_NODE: {
<b class="nc"><i>6490</i>&nbsp;                            if (transientFocusContainer != null) {</b>
<b class="nc"><i>6491</i>&nbsp;                                return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);</b>
<i>6492</i>&nbsp;                            }
<b class="nc"><i>6493</i>&nbsp;                            return getFocusOwner();</b>
<i>6494</i>&nbsp;                        }
<i>6495</i>&nbsp;                        default:
<i>6496</i>&nbsp;                    }
<b class="nc"><i>6497</i>&nbsp;                    return super.getAttribute(attribute, parameters);</b>
<i>6498</i>&nbsp;                }
<i>6499</i>&nbsp;            });
<b class="nc"><i>6500</i>&nbsp;            PlatformImpl.accessibilityActiveProperty().set(true);</b>
<i>6501</i>&nbsp;        }
<b class="nc"><i>6502</i>&nbsp;        return accessible;</b>
<i>6503</i>&nbsp;    }
<i>6504</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2017-12-04 21:49</div>
</div>
</body>
</html>
