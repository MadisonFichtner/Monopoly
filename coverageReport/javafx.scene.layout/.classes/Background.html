


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Background</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javafx.scene.layout</a> ]
</div>

<h1>Coverage Summary for Class: Background (javafx.scene.layout)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Background</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (12/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.7%
  </span>
  <span class="absValue">
    (132/ 221)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package javafx.scene.layout;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import javafx.beans.NamedArg;
<i>29</i>&nbsp;import javafx.css.CssMetaData;
<i>30</i>&nbsp;import javafx.css.Styleable;
<i>31</i>&nbsp;import javafx.geometry.Insets;
<i>32</i>&nbsp;import javafx.scene.Node;
<i>33</i>&nbsp;import javafx.scene.image.Image;
<i>34</i>&nbsp;import javafx.scene.paint.Color;
<i>35</i>&nbsp;import javafx.scene.paint.Paint;
<i>36</i>&nbsp;import java.util.Arrays;
<i>37</i>&nbsp;import java.util.Collections;
<i>38</i>&nbsp;import java.util.List;
<i>39</i>&nbsp;import com.sun.javafx.UnmodifiableArrayList;
<i>40</i>&nbsp;import com.sun.javafx.css.SubCssMetaData;
<i>41</i>&nbsp;import javafx.css.converter.InsetsConverter;
<i>42</i>&nbsp;import javafx.css.converter.PaintConverter;
<i>43</i>&nbsp;import javafx.css.converter.URLConverter;
<i>44</i>&nbsp;import com.sun.javafx.scene.layout.region.LayeredBackgroundPositionConverter;
<i>45</i>&nbsp;import com.sun.javafx.scene.layout.region.LayeredBackgroundSizeConverter;
<i>46</i>&nbsp;import com.sun.javafx.scene.layout.region.CornerRadiiConverter;
<i>47</i>&nbsp;import com.sun.javafx.scene.layout.region.RepeatStruct;
<i>48</i>&nbsp;import com.sun.javafx.scene.layout.region.RepeatStructConverter;
<i>49</i>&nbsp;import com.sun.javafx.tk.Toolkit;
<i>50</i>&nbsp;
<i>51</i>&nbsp;/**
<i>52</i>&nbsp; * The Background of a {@link Region}. A Background is an immutable object which
<i>53</i>&nbsp; * encapsulates the entire set of data required to render the background
<i>54</i>&nbsp; * of a Region. Because this class is immutable, you can freely reuse the same
<i>55</i>&nbsp; * Background on many different Regions. Please refer to
<i>56</i>&nbsp; * &lt;a href=&quot;../doc-files/cssref.html&quot;&gt;JavaFX CSS Reference Guide&lt;/a&gt; for a
<i>57</i>&nbsp; * complete description of the CSS rules for styling the background of a Region.
<i>58</i>&nbsp; * &lt;p&gt;
<i>59</i>&nbsp; * Every Background is comprised of {@link #getFills() fills} and / or
<i>60</i>&nbsp; * {@link #getImages() images}. Neither list will ever be null, but either or
<i>61</i>&nbsp; * both may be empty. Each defined {@link BackgroundFill} is rendered in order,
<i>62</i>&nbsp; * followed by each defined {@link BackgroundImage}.
<i>63</i>&nbsp; * &lt;p&gt;
<i>64</i>&nbsp; * The Background&#39;s {@link #getOutsets() outsets} define any extension of the drawing area of a Region
<i>65</i>&nbsp; * which is necessary to account for all background drawing. These outsets are strictly
<i>66</i>&nbsp; * defined by the BackgroundFills that are specified on this Background, if any, because
<i>67</i>&nbsp; * all BackgroundImages are clipped to the drawing area, and do not define it. The
<i>68</i>&nbsp; * outsets values are strictly non-negative.
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * @since JavaFX 8.0
<i>71</i>&nbsp; */
<i>72</i>&nbsp;@SuppressWarnings(&quot;unchecked&quot;)
<i>73</i>&nbsp;public final class Background {
<b class="fc"><i>74</i>&nbsp;    static final CssMetaData&lt;Node,Paint[]&gt; BACKGROUND_COLOR =</b>
<i>75</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-color&quot;,
<b class="fc"><i>76</i>&nbsp;                    PaintConverter.SequenceConverter.getInstance(),</b>
<i>77</i>&nbsp;                    new Paint[] {Color.TRANSPARENT});
<i>78</i>&nbsp;
<b class="fc"><i>79</i>&nbsp;    static final CssMetaData&lt;Node,CornerRadii[]&gt; BACKGROUND_RADIUS =</b>
<i>80</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-radius&quot;,
<b class="fc"><i>81</i>&nbsp;                    CornerRadiiConverter.getInstance(),</b>
<i>82</i>&nbsp;                    new CornerRadii[] {CornerRadii.EMPTY});
<i>83</i>&nbsp;
<b class="fc"><i>84</i>&nbsp;    static final CssMetaData&lt;Node,Insets[]&gt; BACKGROUND_INSETS =</b>
<i>85</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-insets&quot;,
<b class="fc"><i>86</i>&nbsp;                    InsetsConverter.SequenceConverter.getInstance(),</b>
<i>87</i>&nbsp;                    new Insets[] {Insets.EMPTY});
<i>88</i>&nbsp;
<b class="fc"><i>89</i>&nbsp;    static final CssMetaData&lt;Node,Image[]&gt; BACKGROUND_IMAGE =</b>
<i>90</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-image&quot;,
<b class="fc"><i>91</i>&nbsp;                    URLConverter.SequenceConverter.getInstance());</b>
<i>92</i>&nbsp;
<b class="fc"><i>93</i>&nbsp;    static final CssMetaData&lt;Node,RepeatStruct[]&gt; BACKGROUND_REPEAT =</b>
<i>94</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-repeat&quot;,
<b class="fc"><i>95</i>&nbsp;                    RepeatStructConverter.getInstance(),</b>
<i>96</i>&nbsp;                    new RepeatStruct[] {new RepeatStruct(BackgroundRepeat.REPEAT,
<i>97</i>&nbsp;                                                         BackgroundRepeat.REPEAT) });
<i>98</i>&nbsp;
<b class="fc"><i>99</i>&nbsp;    static final CssMetaData&lt;Node,BackgroundPosition[]&gt; BACKGROUND_POSITION =</b>
<i>100</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-position&quot;,
<b class="fc"><i>101</i>&nbsp;                    LayeredBackgroundPositionConverter.getInstance(),</b>
<i>102</i>&nbsp;                    new BackgroundPosition[] { BackgroundPosition.DEFAULT });
<i>103</i>&nbsp;
<b class="fc"><i>104</i>&nbsp;    static final CssMetaData&lt;Node,BackgroundSize[]&gt; BACKGROUND_SIZE =</b>
<i>105</i>&nbsp;            new SubCssMetaData&lt;&gt;(&quot;-fx-background-size&quot;,
<b class="fc"><i>106</i>&nbsp;                    LayeredBackgroundSizeConverter.getInstance(),</b>
<i>107</i>&nbsp;                    new BackgroundSize[] { BackgroundSize.DEFAULT } );
<i>108</i>&nbsp;
<b class="fc"><i>109</i>&nbsp;    private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES =</b>
<b class="fc"><i>110</i>&nbsp;            (List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;) (List) Collections.unmodifiableList(</b>
<i>111</i>&nbsp;                    // Unchecked!
<b class="fc"><i>112</i>&nbsp;                    Arrays.asList(BACKGROUND_COLOR,</b>
<i>113</i>&nbsp;                            BACKGROUND_INSETS,
<i>114</i>&nbsp;                            BACKGROUND_RADIUS,
<i>115</i>&nbsp;                            BACKGROUND_IMAGE,
<i>116</i>&nbsp;                            BACKGROUND_REPEAT,
<i>117</i>&nbsp;                            BACKGROUND_POSITION,
<i>118</i>&nbsp;                            BACKGROUND_SIZE));
<i>119</i>&nbsp;
<i>120</i>&nbsp;    /**
<i>121</i>&nbsp;     * @return The CssMetaData associated with this class, which may include the
<i>122</i>&nbsp;     * CssMetaData of its superclasses.
<i>123</i>&nbsp;     */
<i>124</i>&nbsp;    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
<b class="fc"><i>125</i>&nbsp;        return STYLEABLES;</b>
<i>126</i>&nbsp;    }
<i>127</i>&nbsp;
<i>128</i>&nbsp;    /**
<i>129</i>&nbsp;     * An empty Background, useful to use instead of null.
<i>130</i>&nbsp;     */
<b class="fc"><i>131</i>&nbsp;    public static final Background EMPTY = new Background((BackgroundFill[])null, null);</b>
<i>132</i>&nbsp;
<i>133</i>&nbsp;    /**
<i>134</i>&nbsp;     * The list of BackgroundFills which together define the filled portion
<i>135</i>&nbsp;     * of this Background. This List is unmodifiable and immutable. It
<i>136</i>&nbsp;     * will never be null. The elements of this list will also never be null.
<i>137</i>&nbsp;     * @return the list of BackgroundFills
<i>138</i>&nbsp;     */
<b class="fc"><i>139</i>&nbsp;    public final List&lt;BackgroundFill&gt; getFills() { return fills; }</b>
<i>140</i>&nbsp;    final List&lt;BackgroundFill&gt; fills;
<i>141</i>&nbsp;
<i>142</i>&nbsp;    /**
<i>143</i>&nbsp;     * The list of BackgroundImages which together define the image portion
<i>144</i>&nbsp;     * of this Background. This List is unmodifiable and immutable. It
<i>145</i>&nbsp;     * will never be null. The elements of this list will also never be null.
<i>146</i>&nbsp;     * @return the list of BackgroundImages
<i>147</i>&nbsp;     */
<b class="fc"><i>148</i>&nbsp;    public final List&lt;BackgroundImage&gt; getImages() { return images; }</b>
<i>149</i>&nbsp;    final List&lt;BackgroundImage&gt; images;
<i>150</i>&nbsp;
<i>151</i>&nbsp;    /**
<i>152</i>&nbsp;     * The outsets of this Background. This represents the largest
<i>153</i>&nbsp;     * bounding rectangle within which all drawing for the Background
<i>154</i>&nbsp;     * will take place. The outsets will never be negative, and represent
<i>155</i>&nbsp;     * the distance from the edge of the Region outward. Any BackgroundImages
<i>156</i>&nbsp;     * which would extend beyond the outsets will be clipped. Only the
<i>157</i>&nbsp;     * BackgroundFills contribute to the outsets.
<i>158</i>&nbsp;     * @return the outsets
<i>159</i>&nbsp;     */
<b class="fc"><i>160</i>&nbsp;    public final Insets getOutsets() { return outsets; }</b>
<i>161</i>&nbsp;    final Insets outsets;
<i>162</i>&nbsp;
<i>163</i>&nbsp;    /**
<i>164</i>&nbsp;     * Gets whether the background is empty. It is empty if there are no fills or images.
<i>165</i>&nbsp;     * @return true if the Background is empty, false otherwise.
<i>166</i>&nbsp;     */
<i>167</i>&nbsp;    public final boolean isEmpty() {
<b class="fc"><i>168</i>&nbsp;        return fills.isEmpty() &amp;&amp; images.isEmpty();</b>
<i>169</i>&nbsp;    }
<i>170</i>&nbsp;
<i>171</i>&nbsp;    /**
<i>172</i>&nbsp;     * Specifies whether the Background has at least one opaque fill.
<i>173</i>&nbsp;     */
<i>174</i>&nbsp;    private final boolean hasOpaqueFill;
<i>175</i>&nbsp;
<i>176</i>&nbsp;    /**
<i>177</i>&nbsp;     * Package-private immutable fields referring to the opaque insets
<i>178</i>&nbsp;     * of this Background.
<i>179</i>&nbsp;     */
<i>180</i>&nbsp;    private final double opaqueFillTop, opaqueFillRight, opaqueFillBottom, opaqueFillLeft;
<i>181</i>&nbsp;    final boolean hasPercentageBasedOpaqueFills;
<i>182</i>&nbsp;
<i>183</i>&nbsp;    /**
<i>184</i>&nbsp;     * True if there are any fills that are in some way based on the size of the region.
<i>185</i>&nbsp;     * For example, if a CornerRadii on the fill is percentage based in either or both
<i>186</i>&nbsp;     * dimensions.
<i>187</i>&nbsp;     */
<i>188</i>&nbsp;    final boolean hasPercentageBasedFills;
<i>189</i>&nbsp;
<i>190</i>&nbsp;    /**
<i>191</i>&nbsp;     * The cached hash code computation for the Background. One very big
<i>192</i>&nbsp;     * reason for making Background immutable was to make it possible to
<i>193</i>&nbsp;     * cache and reuse the same Background instance for multiple
<i>194</i>&nbsp;     * Regions (for example, every un-hovered Button should have the same
<i>195</i>&nbsp;     * Background instance). To enable efficient caching, we cache the hash.
<i>196</i>&nbsp;     */
<i>197</i>&nbsp;    private final int hash;
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /**
<i>200</i>&nbsp;     * Create a new Background by supplying an array of BackgroundFills.
<i>201</i>&nbsp;     * This array may be null, or may contain null values. Any null values
<i>202</i>&nbsp;     * will be ignored and will not contribute to the {@link #getFills() fills}
<i>203</i>&nbsp;     * or {@link #getOutsets() outsets}.
<i>204</i>&nbsp;     *
<i>205</i>&nbsp;     * @param fills     The fills. This may be null, and may contain nulls. Any
<i>206</i>&nbsp;     *                  contained nulls are filtered out and not included in the
<i>207</i>&nbsp;     *                  final List of fills. A null array becomes an empty List.
<i>208</i>&nbsp;     */
<i>209</i>&nbsp;    public Background(final @NamedArg(&quot;fills&quot;) BackgroundFill... fills) {
<b class="nc"><i>210</i>&nbsp;        this(fills, null);</b>
<b class="nc"><i>211</i>&nbsp;    }</b>
<i>212</i>&nbsp;
<i>213</i>&nbsp;    /**
<i>214</i>&nbsp;     * Create a new Background by supplying an array of BackgroundImages.
<i>215</i>&nbsp;     * This array may be null, or may contain null values. Any null values will
<i>216</i>&nbsp;     * be ignored and will not contribute to the {@link #getImages() images}.
<i>217</i>&nbsp;     *
<i>218</i>&nbsp;     * @param images    The images. This may be null, and may contain nulls. Any
<i>219</i>&nbsp;     *                  contained nulls are filtered out and not included in the
<i>220</i>&nbsp;     *                  final List of images. A null array becomes an empty List.
<i>221</i>&nbsp;     */
<i>222</i>&nbsp;    public Background(final @NamedArg(&quot;images&quot;) BackgroundImage... images) {
<b class="nc"><i>223</i>&nbsp;        this(null, images);</b>
<b class="nc"><i>224</i>&nbsp;    }</b>
<i>225</i>&nbsp;
<i>226</i>&nbsp;    /**
<i>227</i>&nbsp;     * Create a new Background supply two Lists, one for background fills and
<i>228</i>&nbsp;     * one for background images. Either list may be null, and may contain nulls.
<i>229</i>&nbsp;     * Any null values in these lists will be ignored and will not
<i>230</i>&nbsp;     * contribute to the {@link #getFills() fills}, {@link #getImages() images}, or
<i>231</i>&nbsp;     * {@link #getOutsets() outsets}.
<i>232</i>&nbsp;     *
<i>233</i>&nbsp;     * @param fills     The fills. This may be null, and may contain nulls. Any
<i>234</i>&nbsp;     *                  contained nulls are filtered out and not included in the
<i>235</i>&nbsp;     *                  final List of fills. A null List becomes an empty List.
<i>236</i>&nbsp;     * @param images    The images. This may be null, and may contain nulls. Any
<i>237</i>&nbsp;     *                  contained nulls are filtered out and not included in the
<i>238</i>&nbsp;     *                  final List of images. A null List becomes an empty List.
<i>239</i>&nbsp;     */
<i>240</i>&nbsp;    public Background(final @NamedArg(&quot;fills&quot;) List&lt;BackgroundFill&gt; fills, final @NamedArg(&quot;images&quot;) List&lt;BackgroundImage&gt; images) {
<i>241</i>&nbsp;        // NOTE: This constructor had to be supplied in order to cause a Builder
<i>242</i>&nbsp;        // to be auto-generated, because otherwise the types of the fills and images
<i>243</i>&nbsp;        // properties didn&#39;t match the types of the array based constructor parameters.
<i>244</i>&nbsp;        // So a Builder will use this constructor, while the CSS engine uses the
<i>245</i>&nbsp;        // array based constructor (for speed).
<b class="nc"><i>246</i>&nbsp;        this(fills == null ? null : fills.toArray(new BackgroundFill[fills.size()]),</b>
<b class="nc"><i>247</i>&nbsp;             images == null ? null : images.toArray(new BackgroundImage[images.size()]));</b>
<b class="nc"><i>248</i>&nbsp;    }</b>
<i>249</i>&nbsp;
<i>250</i>&nbsp;    /**
<i>251</i>&nbsp;     * Create a new Background by supplying two arrays, one for background fills,
<i>252</i>&nbsp;     * and one for background images. Either array may be null, and may contain null
<i>253</i>&nbsp;     * values. Any null values in these arrays will be ignored and will not
<i>254</i>&nbsp;     * contribute to the {@link #getFills() fills}, {@link #getImages() images}, or
<i>255</i>&nbsp;     * {@link #getOutsets() outsets}.
<i>256</i>&nbsp;     *
<i>257</i>&nbsp;     * @param fills     The fills. This may be null, and may contain nulls. Any
<i>258</i>&nbsp;     *                  contained nulls are filtered out and not included in the
<i>259</i>&nbsp;     *                  final List of fills. A null array becomes an empty List.
<i>260</i>&nbsp;     * @param images    The images. This may be null, and may contain nulls. Any
<i>261</i>&nbsp;     *                  contained nulls are filtered out and not included in the
<i>262</i>&nbsp;     *                  final List of images. A null array becomes an empty List.
<i>263</i>&nbsp;     */
<b class="fc"><i>264</i>&nbsp;    public Background(final @NamedArg(&quot;fills&quot;) BackgroundFill[] fills, final @NamedArg(&quot;images&quot;) BackgroundImage[] images) {</b>
<i>265</i>&nbsp;        // The cumulative insets
<b class="fc"><i>266</i>&nbsp;        double outerTop = 0, outerRight = 0, outerBottom = 0, outerLeft = 0;</b>
<b class="fc"><i>267</i>&nbsp;        boolean hasPercentOpaqueInsets = false;</b>
<b class="fc"><i>268</i>&nbsp;        boolean hasPercentFillRadii = false;</b>
<b class="fc"><i>269</i>&nbsp;        boolean opaqueFill = false;</b>
<i>270</i>&nbsp;
<i>271</i>&nbsp;        // If the fills is empty or null then we know we can just use the shared
<i>272</i>&nbsp;        // immutable empty list from Collections.
<b class="fc"><i>273</i>&nbsp;        if (fills == null || fills.length == 0) {</b>
<b class="fc"><i>274</i>&nbsp;            this.fills = Collections.emptyList();</b>
<i>275</i>&nbsp;        } else {
<i>276</i>&nbsp;            // We need to iterate over all of the supplied elements in the fills array.
<i>277</i>&nbsp;            // Each null element is ignored. Each non-null element is inspected to
<i>278</i>&nbsp;            // see if it contributes to the outsets.
<b class="fc"><i>279</i>&nbsp;            final BackgroundFill[] noNulls = new BackgroundFill[fills.length];</b>
<b class="fc"><i>280</i>&nbsp;            int size = 0;</b>
<b class="fc"><i>281</i>&nbsp;            for (int i=0; i&lt;fills.length; i++) {</b>
<b class="fc"><i>282</i>&nbsp;                final BackgroundFill fill = fills[i];</b>
<b class="fc"><i>283</i>&nbsp;                if (fill != null) {</b>
<b class="fc"><i>284</i>&nbsp;                    noNulls[size++] = fill;</b>
<b class="fc"><i>285</i>&nbsp;                    final Insets fillInsets = fill.getInsets();</b>
<b class="fc"><i>286</i>&nbsp;                    final double fillTop = fillInsets.getTop();</b>
<b class="fc"><i>287</i>&nbsp;                    final double fillRight = fillInsets.getRight();</b>
<b class="fc"><i>288</i>&nbsp;                    final double fillBottom = fillInsets.getBottom();</b>
<b class="fc"><i>289</i>&nbsp;                    final double fillLeft = fillInsets.getLeft();</b>
<b class="fc"><i>290</i>&nbsp;                    outerTop = outerTop &lt;= fillTop ? outerTop : fillTop; // min</b>
<b class="fc"><i>291</i>&nbsp;                    outerRight = outerRight &lt;= fillRight ? outerRight : fillRight; // min</b>
<b class="fc"><i>292</i>&nbsp;                    outerBottom = outerBottom &lt;= fillBottom ? outerBottom : fillBottom; // min</b>
<b class="fc"><i>293</i>&nbsp;                    outerLeft = outerLeft &lt;= fillLeft ? outerLeft : fillLeft; // min</b>
<i>294</i>&nbsp;
<i>295</i>&nbsp;                    // The common case is to NOT have percent based radii
<b class="fc"><i>296</i>&nbsp;                    final boolean b = fill.getRadii().hasPercentBasedRadii;</b>
<b class="fc"><i>297</i>&nbsp;                    hasPercentFillRadii |= b;</b>
<b class="fc"><i>298</i>&nbsp;                    if (fill.fill.isOpaque()) {</b>
<b class="fc"><i>299</i>&nbsp;                        opaqueFill = true;</b>
<b class="fc"><i>300</i>&nbsp;                        if (b) {</b>
<b class="nc"><i>301</i>&nbsp;                            hasPercentOpaqueInsets = true;</b>
<i>302</i>&nbsp;                        }
<i>303</i>&nbsp;                    }
<i>304</i>&nbsp;                }
<i>305</i>&nbsp;            }
<b class="fc"><i>306</i>&nbsp;            this.fills = new UnmodifiableArrayList&lt;&gt;(noNulls, size);</b>
<i>307</i>&nbsp;        }
<b class="fc"><i>308</i>&nbsp;        hasPercentageBasedFills = hasPercentFillRadii;</b>
<i>309</i>&nbsp;
<i>310</i>&nbsp;        // This ensures that we either have outsets of 0, if all the insets were positive,
<i>311</i>&nbsp;        // or a value greater than zero if they were negative.
<b class="fc"><i>312</i>&nbsp;        outsets = new Insets(</b>
<b class="fc"><i>313</i>&nbsp;                Math.max(0, -outerTop),</b>
<b class="fc"><i>314</i>&nbsp;                Math.max(0, -outerRight),</b>
<b class="fc"><i>315</i>&nbsp;                Math.max(0, -outerBottom),</b>
<b class="fc"><i>316</i>&nbsp;                Math.max(0, -outerLeft));</b>
<i>317</i>&nbsp;
<i>318</i>&nbsp;        // An null or empty images array results in an empty list
<b class="fc"><i>319</i>&nbsp;        if (images == null || images.length == 0) {</b>
<b class="fc"><i>320</i>&nbsp;            this.images = Collections.emptyList();</b>
<i>321</i>&nbsp;        } else {
<i>322</i>&nbsp;            // Filter out any  null values and create an immutable array list
<b class="nc"><i>323</i>&nbsp;            final BackgroundImage[] noNulls = new BackgroundImage[images.length];</b>
<b class="nc"><i>324</i>&nbsp;            int size = 0;</b>
<b class="nc"><i>325</i>&nbsp;            for (int i=0; i&lt;images.length; i++) {</b>
<b class="nc"><i>326</i>&nbsp;                final BackgroundImage image = images[i];</b>
<b class="nc"><i>327</i>&nbsp;                if (image != null) noNulls[size++] = image;</b>
<i>328</i>&nbsp;            }
<b class="nc"><i>329</i>&nbsp;            this.images = new UnmodifiableArrayList&lt;&gt;(noNulls, size);</b>
<i>330</i>&nbsp;        }
<i>331</i>&nbsp;
<b class="fc"><i>332</i>&nbsp;        hasOpaqueFill = opaqueFill;</b>
<b class="fc"><i>333</i>&nbsp;        if (hasPercentOpaqueInsets) {</b>
<b class="nc"><i>334</i>&nbsp;            opaqueFillTop = Double.NaN;</b>
<b class="nc"><i>335</i>&nbsp;            opaqueFillRight = Double.NaN;</b>
<b class="nc"><i>336</i>&nbsp;            opaqueFillBottom = Double.NaN;</b>
<b class="nc"><i>337</i>&nbsp;            opaqueFillLeft = Double.NaN;</b>
<i>338</i>&nbsp;        } else {
<b class="fc"><i>339</i>&nbsp;            double[] trbl = new double[4];</b>
<b class="fc"><i>340</i>&nbsp;            computeOpaqueInsets(1, 1, true, trbl);</b>
<b class="fc"><i>341</i>&nbsp;            opaqueFillTop = trbl[0];</b>
<b class="fc"><i>342</i>&nbsp;            opaqueFillRight = trbl[1];</b>
<b class="fc"><i>343</i>&nbsp;            opaqueFillBottom = trbl[2];</b>
<b class="fc"><i>344</i>&nbsp;            opaqueFillLeft = trbl[3];</b>
<i>345</i>&nbsp;        }
<b class="fc"><i>346</i>&nbsp;        hasPercentageBasedOpaqueFills = hasPercentOpaqueInsets;</b>
<i>347</i>&nbsp;
<i>348</i>&nbsp;        // Pre-compute the hash code. NOTE: all variables are prefixed with &quot;this&quot; so that we
<i>349</i>&nbsp;        // do not accidentally compute the hash based on the constructor arguments rather than
<i>350</i>&nbsp;        // based on the fields themselves!
<b class="fc"><i>351</i>&nbsp;        int result = this.fills.hashCode();</b>
<b class="fc"><i>352</i>&nbsp;        result = 31 * result + this.images.hashCode();</b>
<b class="fc"><i>353</i>&nbsp;        hash = result;</b>
<b class="fc"><i>354</i>&nbsp;    }</b>
<i>355</i>&nbsp;
<i>356</i>&nbsp;    /**
<i>357</i>&nbsp;     * Gets whether the fill of this Background is based on percentages (that is, relative to the
<i>358</i>&nbsp;     * size of the region being styled). Specifically, this returns true if any of the CornerRadii
<i>359</i>&nbsp;     * on any of the fills on this Background has a radius that is based on percentages.
<i>360</i>&nbsp;     *
<i>361</i>&nbsp;     * @return True if any CornerRadii of any BackgroundFill on this background would return true, false otherwise.
<i>362</i>&nbsp;     * @since JavaFX 8.0
<i>363</i>&nbsp;     */
<i>364</i>&nbsp;    public boolean isFillPercentageBased() {
<b class="fc"><i>365</i>&nbsp;        return hasPercentageBasedFills;</b>
<i>366</i>&nbsp;    }
<i>367</i>&nbsp;
<i>368</i>&nbsp;    /**
<i>369</i>&nbsp;     * Computes the opaque insets for a region with the specified width and height. This call
<i>370</i>&nbsp;     * must be made whenever the width or height of the region change, because the opaque insets
<i>371</i>&nbsp;     * are based on background fills, and the corner radii of a background fill can be percentage
<i>372</i>&nbsp;     * based. Thus, we need to potentially recompute the opaque insets whenever the width or
<i>373</i>&nbsp;     * height of the region change. On the other hand, if there are no percentage based corner
<i>374</i>&nbsp;     * radii, then we can simply return the pre-computed and cached answers.
<i>375</i>&nbsp;     *
<i>376</i>&nbsp;     * @param width     The width of the region
<i>377</i>&nbsp;     * @param height    The height of the region
<i>378</i>&nbsp;     * @param trbl      A four-element array of doubles in order: top, right, bottom, left.
<i>379</i>&nbsp;     */
<i>380</i>&nbsp;    void computeOpaqueInsets(double width, double height, double[] trbl) {
<b class="fc"><i>381</i>&nbsp;        computeOpaqueInsets(width, height, false, trbl);</b>
<b class="fc"><i>382</i>&nbsp;    }</b>
<i>383</i>&nbsp;
<i>384</i>&nbsp;    /**
<i>385</i>&nbsp;     * Computes the opaque insets. The first time this is called from the constructor
<i>386</i>&nbsp;     * we want to take the long route through and compute everything, whether there are
<i>387</i>&nbsp;     * percentage based insets or not (the constructor ensures not to call it in the case
<i>388</i>&nbsp;     * that it has percentage based insets!). All other times, this is called by the other
<i>389</i>&nbsp;     * computeOpaqueInsets method with &quot;firstTime&quot; set to false, such that if we have
<i>390</i>&nbsp;     * percentage based insets, then we will bail early.
<i>391</i>&nbsp;     *
<i>392</i>&nbsp;     * This method takes into account both fills and images. Because images can be
<i>393</i>&nbsp;     * lazy loaded, we cannot pre-compute a bunch of things in the constructor for images
<i>394</i>&nbsp;     * the way we can with fills. Instead, each time the method is called, we have to
<i>395</i>&nbsp;     * inspect the images. However, we do have fast paths for cases where fills are used
<i>396</i>&nbsp;     * and not images.
<i>397</i>&nbsp;     *
<i>398</i>&nbsp;     * @param width        The width of the region
<i>399</i>&nbsp;     * @param height       The height of the region
<i>400</i>&nbsp;     * @param firstTime    Whether this is being called from the constructor
<i>401</i>&nbsp;     * @param trbl         A four-element array of doubles in order: top, right, bottom, left.
<i>402</i>&nbsp;     */
<i>403</i>&nbsp;    private void computeOpaqueInsets(double width, double height, boolean firstTime, double[] trbl) {
<b class="fc"><i>404</i>&nbsp;        double opaqueRegionTop = Double.NaN,</b>
<b class="fc"><i>405</i>&nbsp;               opaqueRegionRight = Double.NaN,</b>
<b class="fc"><i>406</i>&nbsp;               opaqueRegionBottom = Double.NaN,</b>
<b class="fc"><i>407</i>&nbsp;               opaqueRegionLeft = Double.NaN;</b>
<i>408</i>&nbsp;
<i>409</i>&nbsp;        // If during object construction we determined that there is an opaque fill, then we need
<i>410</i>&nbsp;        // to visit the fills and figure out which ones contribute to the opaque insets
<b class="fc"><i>411</i>&nbsp;        if (hasOpaqueFill) {</b>
<i>412</i>&nbsp;            // If during construction time we determined that none of the fills had a percentage based
<i>413</i>&nbsp;            // opaque inset, then we can just use the pre-computed values. This is worth doing since
<i>414</i>&nbsp;            // at this time all CSS based radii for BackgroundFills are literal values!
<b class="fc"><i>415</i>&nbsp;            if (!firstTime &amp;&amp; !hasPercentageBasedOpaqueFills) {</b>
<b class="fc"><i>416</i>&nbsp;                opaqueRegionTop = opaqueFillTop;</b>
<b class="fc"><i>417</i>&nbsp;                opaqueRegionRight = opaqueFillRight;</b>
<b class="fc"><i>418</i>&nbsp;                opaqueRegionBottom = opaqueFillBottom;</b>
<b class="fc"><i>419</i>&nbsp;                opaqueRegionLeft = opaqueFillLeft;</b>
<i>420</i>&nbsp;            } else {
<i>421</i>&nbsp;                // NOTE: We know at this point that there is an opaque fill, and that at least one
<i>422</i>&nbsp;                // of them uses a percentage for at least one corner radius. Iterate over each
<i>423</i>&nbsp;                // BackgroundFill. If the fill is opaque, then we will compute the largest rectangle
<i>424</i>&nbsp;                // which will fit within its opaque area, taking the corner radii into account.
<i>425</i>&nbsp;                // Initialize them to the &quot;I Don&#39;t Know&quot; answer.
<i>426</i>&nbsp;
<b class="fc"><i>427</i>&nbsp;                for (int i=0, max=fills.size(); i&lt;max; i++) {</b>
<b class="fc"><i>428</i>&nbsp;                    final BackgroundFill fill = fills.get(i);</b>
<b class="fc"><i>429</i>&nbsp;                    final Insets fillInsets = fill.getInsets();</b>
<b class="fc"><i>430</i>&nbsp;                    final double fillTop = fillInsets.getTop();</b>
<b class="fc"><i>431</i>&nbsp;                    final double fillRight = fillInsets.getRight();</b>
<b class="fc"><i>432</i>&nbsp;                    final double fillBottom = fillInsets.getBottom();</b>
<b class="fc"><i>433</i>&nbsp;                    final double fillLeft = fillInsets.getLeft();</b>
<i>434</i>&nbsp;
<b class="fc"><i>435</i>&nbsp;                    if (fill.fill.isOpaque()) {</b>
<i>436</i>&nbsp;                        // Some possible configurations:
<i>437</i>&nbsp;                        //     (a) rect1 is completely contained by rect2
<i>438</i>&nbsp;                        //     (b) rect2 is completely contained by rect1
<i>439</i>&nbsp;                        //     (c) rect1 is the same height as rect 2 and they overlap on the left or right
<i>440</i>&nbsp;                        //     (d) rect1 is the same width as rect 2 and they overlap on the top or bottom
<i>441</i>&nbsp;                        //     (e) they are disjoint or overlap in an unsupported manner.
<b class="fc"><i>442</i>&nbsp;                        final CornerRadii radii = fill.getRadii();</b>
<b class="fc"><i>443</i>&nbsp;                        final double topLeftHorizontalRadius = radii.isTopLeftHorizontalRadiusAsPercentage() ?</b>
<b class="nc"><i>444</i>&nbsp;                                width * radii.getTopLeftHorizontalRadius() : radii.getTopLeftHorizontalRadius();</b>
<b class="fc"><i>445</i>&nbsp;                        final double topLeftVerticalRadius = radii.isTopLeftVerticalRadiusAsPercentage() ?</b>
<b class="nc"><i>446</i>&nbsp;                                height * radii.getTopLeftVerticalRadius() : radii.getTopLeftVerticalRadius();</b>
<b class="fc"><i>447</i>&nbsp;                        final double topRightVerticalRadius = radii.isTopRightVerticalRadiusAsPercentage() ?</b>
<b class="nc"><i>448</i>&nbsp;                                height * radii.getTopRightVerticalRadius() : radii.getTopRightVerticalRadius();</b>
<b class="fc"><i>449</i>&nbsp;                        final double topRightHorizontalRadius = radii.isTopRightHorizontalRadiusAsPercentage() ?</b>
<b class="nc"><i>450</i>&nbsp;                                width * radii.getTopRightHorizontalRadius() : radii.getTopRightHorizontalRadius();</b>
<b class="fc"><i>451</i>&nbsp;                        final double bottomRightHorizontalRadius = radii.isBottomRightHorizontalRadiusAsPercentage() ?</b>
<b class="nc"><i>452</i>&nbsp;                                width * radii.getBottomRightHorizontalRadius() : radii.getBottomRightHorizontalRadius();</b>
<b class="fc"><i>453</i>&nbsp;                        final double bottomRightVerticalRadius = radii.isBottomRightVerticalRadiusAsPercentage() ?</b>
<b class="nc"><i>454</i>&nbsp;                                height * radii.getBottomRightVerticalRadius() : radii.getBottomRightVerticalRadius();</b>
<b class="fc"><i>455</i>&nbsp;                        final double bottomLeftVerticalRadius = radii.isBottomLeftVerticalRadiusAsPercentage() ?</b>
<b class="nc"><i>456</i>&nbsp;                                height * radii.getBottomLeftVerticalRadius() : radii.getBottomLeftVerticalRadius();</b>
<b class="fc"><i>457</i>&nbsp;                        final double bottomLeftHorizontalRadius = radii.isBottomLeftHorizontalRadiusAsPercentage() ?</b>
<b class="nc"><i>458</i>&nbsp;                                width * radii.getBottomLeftHorizontalRadius() : radii.getBottomLeftHorizontalRadius();</b>
<i>459</i>&nbsp;
<b class="fc"><i>460</i>&nbsp;                        final double t = fillTop + (Math.max(topLeftVerticalRadius, topRightVerticalRadius) / 2);</b>
<b class="fc"><i>461</i>&nbsp;                        final double r = fillRight + (Math.max(topRightHorizontalRadius, bottomRightHorizontalRadius) / 2);</b>
<b class="fc"><i>462</i>&nbsp;                        final double b = fillBottom + (Math.max(bottomLeftVerticalRadius, bottomRightVerticalRadius) / 2);</b>
<b class="fc"><i>463</i>&nbsp;                        final double l = fillLeft + (Math.max(topLeftHorizontalRadius, bottomLeftHorizontalRadius) / 2);</b>
<b class="fc"><i>464</i>&nbsp;                        if (Double.isNaN(opaqueRegionTop)) {</b>
<i>465</i>&nbsp;                            // This only happens for the first opaque fill we encounter
<b class="fc"><i>466</i>&nbsp;                            opaqueRegionTop = t;</b>
<b class="fc"><i>467</i>&nbsp;                            opaqueRegionRight = r;</b>
<b class="fc"><i>468</i>&nbsp;                            opaqueRegionBottom = b;</b>
<b class="fc"><i>469</i>&nbsp;                            opaqueRegionLeft = l;</b>
<i>470</i>&nbsp;                        } else {
<b class="fc"><i>471</i>&nbsp;                            final boolean largerTop = t &gt;= opaqueRegionTop;</b>
<b class="fc"><i>472</i>&nbsp;                            final boolean largerRight = r &gt;= opaqueRegionRight;</b>
<b class="fc"><i>473</i>&nbsp;                            final boolean largerBottom = b &gt;= opaqueRegionBottom;</b>
<b class="fc"><i>474</i>&nbsp;                            final boolean largerLeft = l &gt;= opaqueRegionLeft;</b>
<b class="fc"><i>475</i>&nbsp;                            if (largerTop &amp;&amp; largerRight &amp;&amp; largerBottom &amp;&amp; largerLeft) {</b>
<i>476</i>&nbsp;                                // The new fill is completely contained within the existing rect, so no change
<b class="fc"><i>477</i>&nbsp;                                continue;</b>
<b class="nc"><i>478</i>&nbsp;                            } else if (!largerTop &amp;&amp; !largerRight &amp;&amp; !largerBottom &amp;&amp; !largerLeft) {</b>
<i>479</i>&nbsp;                                // The new fill completely contains the existing rect, so use these
<i>480</i>&nbsp;                                // new values for our opaque region
<b class="nc"><i>481</i>&nbsp;                                opaqueRegionTop = fillTop;</b>
<b class="nc"><i>482</i>&nbsp;                                opaqueRegionRight = fillRight;</b>
<b class="nc"><i>483</i>&nbsp;                                opaqueRegionBottom = fillBottom;</b>
<b class="nc"><i>484</i>&nbsp;                                opaqueRegionLeft = fillLeft;</b>
<b class="nc"><i>485</i>&nbsp;                            } else if (l == opaqueRegionLeft &amp;&amp; r == opaqueRegionRight) {</b>
<i>486</i>&nbsp;                                // The left and right insets are the same between the two rects, so just pick
<i>487</i>&nbsp;                                // the smallest top and bottom
<b class="nc"><i>488</i>&nbsp;                                opaqueRegionTop = Math.min(t, opaqueRegionTop);</b>
<b class="nc"><i>489</i>&nbsp;                                opaqueRegionBottom = Math.min(b, opaqueRegionBottom);</b>
<b class="nc"><i>490</i>&nbsp;                            } else if (t == opaqueRegionTop &amp;&amp; b == opaqueRegionBottom) {</b>
<i>491</i>&nbsp;                                // The top and bottom are the same between the two rects so just pick
<i>492</i>&nbsp;                                // the smallest left and right
<b class="nc"><i>493</i>&nbsp;                                opaqueRegionLeft = Math.min(l, opaqueRegionLeft);</b>
<b class="nc"><i>494</i>&nbsp;                                opaqueRegionRight = Math.min(r, opaqueRegionRight);</b>
<i>495</i>&nbsp;                            } else {
<i>496</i>&nbsp;                                // They are disjoint or overlap in some other manner. So we will just
<i>497</i>&nbsp;                                // ignore this region.
<i>498</i>&nbsp;                                continue;
<i>499</i>&nbsp;                            }
<i>500</i>&nbsp;                        }
<i>501</i>&nbsp;                    }
<i>502</i>&nbsp;                }
<i>503</i>&nbsp;            }
<i>504</i>&nbsp;        }
<i>505</i>&nbsp;
<i>506</i>&nbsp;        // Check the background images. Since the image of a BackgroundImage might load asynchronously
<i>507</i>&nbsp;        // and since we must inspect the image to check for opacity, we just have to visit all the
<i>508</i>&nbsp;        // images each time this method is called rather than pre-computing results. With some work
<i>509</i>&nbsp;        // we could end up caching the result eventually.
<b class="fc"><i>510</i>&nbsp;        final Toolkit.ImageAccessor acc = Toolkit.getImageAccessor();</b>
<b class="fc"><i>511</i>&nbsp;        for (BackgroundImage bi : images) {</b>
<b class="nc"><i>512</i>&nbsp;            if (bi.opaque == null) {</b>
<i>513</i>&nbsp;                // If the image is not yet loaded, just skip it
<i>514</i>&nbsp;                // Note: Unit test wants this to be com.sun.javafx.tk.PlatformImage, not com.sun.prism.Image
<b class="nc"><i>515</i>&nbsp;                final com.sun.javafx.tk.PlatformImage platformImage = acc.getImageProperty(bi.image).get();</b>
<b class="nc"><i>516</i>&nbsp;                if (platformImage == null) continue;</b>
<i>517</i>&nbsp;
<i>518</i>&nbsp;                // The image has been loaded, so update the opaque flag
<b class="nc"><i>519</i>&nbsp;                if (platformImage instanceof com.sun.prism.Image) {</b>
<b class="nc"><i>520</i>&nbsp;                    bi.opaque = ((com.sun.prism.Image)platformImage).isOpaque();</b>
<i>521</i>&nbsp;                } else {
<i>522</i>&nbsp;                    continue;
<i>523</i>&nbsp;                }
<i>524</i>&nbsp;            }
<i>525</i>&nbsp;
<i>526</i>&nbsp;            // At this point we know that we&#39;re processing an image which has already been resolved
<i>527</i>&nbsp;            // and we know whether it is opaque or not. Of course, we only care about processing
<i>528</i>&nbsp;            // opaque images.
<b class="nc"><i>529</i>&nbsp;            if (bi.opaque) {</b>
<b class="nc"><i>530</i>&nbsp;                if (bi.size.cover ||</b>
<i>531</i>&nbsp;                        (bi.size.height == BackgroundSize.AUTO &amp;&amp; bi.size.width == BackgroundSize.AUTO &amp;&amp;
<i>532</i>&nbsp;                        bi.size.widthAsPercentage &amp;&amp; bi.size.heightAsPercentage)) {
<i>533</i>&nbsp;                    // If the size mode is &quot;cover&quot; or AUTO, AUTO, and percentage based, then we&#39;re done -- we can simply
<i>534</i>&nbsp;                    // accumulate insets of &quot;0&quot;
<b class="nc"><i>535</i>&nbsp;                    opaqueRegionTop = Double.isNaN(opaqueRegionTop) ? 0 : Math.min(0, opaqueRegionTop);</b>
<b class="nc"><i>536</i>&nbsp;                    opaqueRegionRight = Double.isNaN(opaqueRegionRight) ? 0 : Math.min(0, opaqueRegionRight);</b>
<b class="nc"><i>537</i>&nbsp;                    opaqueRegionBottom = Double.isNaN(opaqueRegionBottom) ? 0 : Math.min(0, opaqueRegionBottom);</b>
<b class="nc"><i>538</i>&nbsp;                    opaqueRegionLeft = Double.isNaN(opaqueRegionLeft) ? 0 : Math.min(0, opaqueRegionLeft);</b>
<b class="nc"><i>539</i>&nbsp;                    break;</b>
<i>540</i>&nbsp;                } else {
<i>541</i>&nbsp;                    // Here we are taking into account all potential tiling cases including &quot;contain&quot;. Basically,
<i>542</i>&nbsp;                    // as long as the repeat is *not* SPACE, we know that we&#39;ll be touching every pixel, and we
<i>543</i>&nbsp;                    // don&#39;t really care how big the tiles end up being. The only case where we care about the
<i>544</i>&nbsp;                    // actual tile size is in the NO_REPEAT modes.
<i>545</i>&nbsp;
<i>546</i>&nbsp;                    // If the repeatX or repeatY includes &quot;SPACE&quot; Then we bail, because we can&#39;t be happy about
<i>547</i>&nbsp;                    // spaces strewn about within the region.
<b class="nc"><i>548</i>&nbsp;                    if (bi.repeatX == BackgroundRepeat.SPACE || bi.repeatY == BackgroundRepeat.SPACE) {</b>
<b class="nc"><i>549</i>&nbsp;                        bi.opaque = false; // We&#39;ll treat it as false in the future</b>
<b class="nc"><i>550</i>&nbsp;                        continue;</b>
<i>551</i>&nbsp;                    }
<i>552</i>&nbsp;
<i>553</i>&nbsp;                    // If the repeatX and repeatY are &quot;REPEAT&quot; and/or &quot;ROUND&quot; (any combination thereof) then
<i>554</i>&nbsp;                    // we know all pixels within the region width / height are being touched, so we can just
<i>555</i>&nbsp;                    // set the opaqueRegion variables and we&#39;re done.
<b class="nc"><i>556</i>&nbsp;                    final boolean filledX = bi.repeatX == BackgroundRepeat.REPEAT || bi.repeatX == BackgroundRepeat.ROUND;</b>
<b class="nc"><i>557</i>&nbsp;                    final boolean filledY = bi.repeatY == BackgroundRepeat.REPEAT || bi.repeatY == BackgroundRepeat.ROUND;</b>
<b class="nc"><i>558</i>&nbsp;                    if (filledX &amp;&amp; filledY) {</b>
<b class="nc"><i>559</i>&nbsp;                        opaqueRegionTop = Double.isNaN(opaqueRegionTop) ? 0 : Math.min(0, opaqueRegionTop);</b>
<b class="nc"><i>560</i>&nbsp;                        opaqueRegionRight = Double.isNaN(opaqueRegionRight) ? 0 : Math.min(0, opaqueRegionRight);</b>
<b class="nc"><i>561</i>&nbsp;                        opaqueRegionBottom = Double.isNaN(opaqueRegionBottom) ? 0 : Math.min(0, opaqueRegionBottom);</b>
<b class="nc"><i>562</i>&nbsp;                        opaqueRegionLeft = Double.isNaN(opaqueRegionLeft) ? 0 : Math.min(0, opaqueRegionLeft);</b>
<b class="nc"><i>563</i>&nbsp;                        break;</b>
<i>564</i>&nbsp;                    }
<i>565</i>&nbsp;
<i>566</i>&nbsp;                    // We know that one or the other dimension is not filled, so we have to compute the right
<i>567</i>&nbsp;                    // width / height. This is basically a big copy/paste from NGRegion! Blah!
<b class="nc"><i>568</i>&nbsp;                    final double w = bi.size.widthAsPercentage ? bi.size.width * width : bi.size.width;</b>
<b class="nc"><i>569</i>&nbsp;                    final double h = bi.size.heightAsPercentage ? bi.size.height * height : bi.size.height;</b>
<b class="nc"><i>570</i>&nbsp;                    final double imgUnscaledWidth = bi.image.getWidth();</b>
<b class="nc"><i>571</i>&nbsp;                    final double imgUnscaledHeight = bi.image.getHeight();</b>
<i>572</i>&nbsp;
<i>573</i>&nbsp;                    // Now figure out the width and height of each tile to be drawn. The actual image
<i>574</i>&nbsp;                    // dimensions may be one thing, but we need to figure out what the size of the image
<i>575</i>&nbsp;                    // in the destination is going to be.
<i>576</i>&nbsp;                    final double tileWidth, tileHeight;
<b class="nc"><i>577</i>&nbsp;                    if (bi.size.contain) {</b>
<i>578</i>&nbsp;                        // In the case of &quot;contain&quot;, we compute the destination size based on the largest
<i>579</i>&nbsp;                        // possible scale such that the aspect ratio is maintained, yet one side of the
<i>580</i>&nbsp;                        // region is completely filled.
<b class="nc"><i>581</i>&nbsp;                        final double scaleX = width / imgUnscaledWidth;</b>
<b class="nc"><i>582</i>&nbsp;                        final double scaleY = height / imgUnscaledHeight;</b>
<b class="nc"><i>583</i>&nbsp;                        final double scale = Math.min(scaleX, scaleY);</b>
<b class="nc"><i>584</i>&nbsp;                        tileWidth = Math.ceil(scale * imgUnscaledWidth);</b>
<b class="nc"><i>585</i>&nbsp;                        tileHeight = Math.ceil(scale * imgUnscaledHeight);</b>
<b class="nc"><i>586</i>&nbsp;                    } else if (bi.size.width &gt;= 0 &amp;&amp; bi.size.height &gt;= 0) {</b>
<i>587</i>&nbsp;                        // The width and height have been expressly defined. Note that AUTO is -1,
<i>588</i>&nbsp;                        // and all other negative values are disallowed, so by checking &gt;= 0, we
<i>589</i>&nbsp;                        // are essentially saying &quot;if neither is AUTO&quot;
<b class="nc"><i>590</i>&nbsp;                        tileWidth = w;</b>
<b class="nc"><i>591</i>&nbsp;                        tileHeight = h;</b>
<b class="nc"><i>592</i>&nbsp;                    } else if (w &gt;= 0) {</b>
<i>593</i>&nbsp;                        // In this case, the width is specified, but the height is AUTO
<b class="nc"><i>594</i>&nbsp;                        tileWidth = w;</b>
<b class="nc"><i>595</i>&nbsp;                        final double scale = tileWidth / imgUnscaledWidth;</b>
<b class="nc"><i>596</i>&nbsp;                        tileHeight = imgUnscaledHeight * scale;</b>
<b class="nc"><i>597</i>&nbsp;                    } else if (h &gt;= 0) {</b>
<i>598</i>&nbsp;                        // Here the height is specified and the width is AUTO
<b class="nc"><i>599</i>&nbsp;                        tileHeight = h;</b>
<b class="nc"><i>600</i>&nbsp;                        final double scale = tileHeight / imgUnscaledHeight;</b>
<b class="nc"><i>601</i>&nbsp;                        tileWidth = imgUnscaledWidth * scale;</b>
<b class="nc"><i>602</i>&nbsp;                    } else {</b>
<i>603</i>&nbsp;                        // Both are auto.
<b class="nc"><i>604</i>&nbsp;                        tileWidth = imgUnscaledWidth;</b>
<b class="nc"><i>605</i>&nbsp;                        tileHeight = imgUnscaledHeight;</b>
<i>606</i>&nbsp;                    }
<i>607</i>&nbsp;
<b class="nc"><i>608</i>&nbsp;                    opaqueRegionTop = Double.isNaN(opaqueRegionTop) ? 0 : Math.min(0, opaqueRegionTop);</b>
<b class="nc"><i>609</i>&nbsp;                    opaqueRegionRight = Double.isNaN(opaqueRegionRight) ? (width - tileWidth) : Math.min(width - tileWidth, opaqueRegionRight);</b>
<b class="nc"><i>610</i>&nbsp;                    opaqueRegionBottom = Double.isNaN(opaqueRegionBottom) ? (height - tileHeight) : Math.min(height - tileHeight, opaqueRegionBottom);</b>
<b class="nc"><i>611</i>&nbsp;                    opaqueRegionLeft = Double.isNaN(opaqueRegionLeft) ? 0 : Math.min(0, opaqueRegionLeft);</b>
<i>612</i>&nbsp;                }
<i>613</i>&nbsp;            }
<b class="nc"><i>614</i>&nbsp;        }</b>
<i>615</i>&nbsp;
<b class="fc"><i>616</i>&nbsp;        trbl[0] = opaqueRegionTop;</b>
<b class="fc"><i>617</i>&nbsp;        trbl[1] = opaqueRegionRight;</b>
<b class="fc"><i>618</i>&nbsp;        trbl[2] = opaqueRegionBottom;</b>
<b class="fc"><i>619</i>&nbsp;        trbl[3] = opaqueRegionLeft;</b>
<b class="fc"><i>620</i>&nbsp;    }</b>
<i>621</i>&nbsp;
<i>622</i>&nbsp;    /**
<i>623</i>&nbsp;     * {@inheritDoc}
<i>624</i>&nbsp;     */
<i>625</i>&nbsp;    @Override public boolean equals(Object o) {
<b class="fc"><i>626</i>&nbsp;        if (this == o) return true;</b>
<b class="fc"><i>627</i>&nbsp;        if (o == null || getClass() != o.getClass()) return false;</b>
<b class="fc"><i>628</i>&nbsp;        Background that = (Background) o;</b>
<i>629</i>&nbsp;        // Because the hash is cached, this can be a very fast check
<b class="fc"><i>630</i>&nbsp;        if (hash != that.hash) return false;</b>
<b class="fc"><i>631</i>&nbsp;        if (!fills.equals(that.fills)) return false;</b>
<b class="fc"><i>632</i>&nbsp;        if (!images.equals(that.images)) return false;</b>
<i>633</i>&nbsp;
<b class="fc"><i>634</i>&nbsp;        return true;</b>
<i>635</i>&nbsp;    }
<i>636</i>&nbsp;
<i>637</i>&nbsp;    /**
<i>638</i>&nbsp;     * {@inheritDoc}
<i>639</i>&nbsp;     */
<i>640</i>&nbsp;    @Override public int hashCode() {
<b class="fc"><i>641</i>&nbsp;        return hash;</b>
<i>642</i>&nbsp;    }
<i>643</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2017-12-04 21:49</div>
</div>
</body>
</html>
