


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: PopupWindow</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javafx.stage</a> ]
</div>

<h1>Coverage Summary for Class: PopupWindow (javafx.stage)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PopupWindow</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (35/ 63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.7%
  </span>
  <span class="absValue">
    (213/ 285)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PopupWindow$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.5%
  </span>
  <span class="absValue">
    (2/ 21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$4</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$5</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$6</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$AnchorLocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PopupWindow$PopupEventRedirector</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.5%
  </span>
  <span class="absValue">
    (10/ 57)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    57.7%
  </span>
  <span class="absValue">
    (56/ 97)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.2%
  </span>
  <span class="absValue">
    (262/ 408)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package javafx.stage;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.javafx.util.Utils;
<i>29</i>&nbsp;import com.sun.javafx.event.DirectEvent;
<i>30</i>&nbsp;import java.util.ArrayList;
<i>31</i>&nbsp;import java.util.List;
<i>32</i>&nbsp;
<i>33</i>&nbsp;import javafx.beans.InvalidationListener;
<i>34</i>&nbsp;import javafx.beans.Observable;
<i>35</i>&nbsp;import javafx.beans.property.BooleanProperty;
<i>36</i>&nbsp;import javafx.beans.property.BooleanPropertyBase;
<i>37</i>&nbsp;import javafx.beans.property.ObjectProperty;
<i>38</i>&nbsp;import javafx.beans.property.ReadOnlyDoubleProperty;
<i>39</i>&nbsp;import javafx.beans.property.ReadOnlyDoubleWrapper;
<i>40</i>&nbsp;import javafx.beans.property.SimpleBooleanProperty;
<i>41</i>&nbsp;import javafx.beans.property.SimpleObjectProperty;
<i>42</i>&nbsp;import javafx.beans.value.ChangeListener;
<i>43</i>&nbsp;import javafx.collections.ObservableList;
<i>44</i>&nbsp;import javafx.event.Event;
<i>45</i>&nbsp;import javafx.event.EventHandler;
<i>46</i>&nbsp;import javafx.geometry.BoundingBox;
<i>47</i>&nbsp;import javafx.geometry.Bounds;
<i>48</i>&nbsp;import javafx.geometry.Rectangle2D;
<i>49</i>&nbsp;import javafx.scene.Group;
<i>50</i>&nbsp;import javafx.scene.Node;
<i>51</i>&nbsp;import javafx.scene.Parent;
<i>52</i>&nbsp;import javafx.scene.Scene;
<i>53</i>&nbsp;
<i>54</i>&nbsp;import com.sun.javafx.event.EventHandlerManager;
<i>55</i>&nbsp;import com.sun.javafx.event.EventRedirector;
<i>56</i>&nbsp;import com.sun.javafx.event.EventUtil;
<i>57</i>&nbsp;import com.sun.javafx.perf.PerformanceTracker;
<i>58</i>&nbsp;import com.sun.javafx.scene.SceneHelper;
<i>59</i>&nbsp;import com.sun.javafx.stage.FocusUngrabEvent;
<i>60</i>&nbsp;import com.sun.javafx.stage.PopupWindowPeerListener;
<i>61</i>&nbsp;import com.sun.javafx.stage.WindowCloseRequestHandler;
<i>62</i>&nbsp;import com.sun.javafx.stage.WindowEventDispatcher;
<i>63</i>&nbsp;import com.sun.javafx.tk.Toolkit;
<i>64</i>&nbsp;import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;
<i>65</i>&nbsp;import com.sun.javafx.scene.NodeHelper;
<i>66</i>&nbsp;import com.sun.javafx.stage.PopupWindowHelper;
<i>67</i>&nbsp;import com.sun.javafx.stage.WindowHelper;
<i>68</i>&nbsp;import javafx.beans.property.ObjectPropertyBase;
<i>69</i>&nbsp;import javafx.beans.property.ReadOnlyObjectProperty;
<i>70</i>&nbsp;import javafx.beans.property.ReadOnlyObjectWrapper;
<i>71</i>&nbsp;import javafx.beans.value.WeakChangeListener;
<i>72</i>&nbsp;import javafx.event.EventTarget;
<i>73</i>&nbsp;import javafx.event.EventType;
<i>74</i>&nbsp;import javafx.scene.input.KeyCombination;
<i>75</i>&nbsp;import javafx.scene.input.KeyEvent;
<i>76</i>&nbsp;import javafx.scene.input.MouseEvent;
<i>77</i>&nbsp;import javafx.scene.input.ScrollEvent;
<i>78</i>&nbsp;import javafx.scene.layout.Background;
<i>79</i>&nbsp;import javafx.scene.layout.Pane;
<i>80</i>&nbsp;
<i>81</i>&nbsp;/**
<i>82</i>&nbsp; * PopupWindow is the parent for a variety of different types of popup
<i>83</i>&nbsp; * based windows including {@link Popup} and {@link javafx.scene.control.Tooltip}
<i>84</i>&nbsp; * and {@link javafx.scene.control.ContextMenu}.
<i>85</i>&nbsp; * &lt;p&gt;
<i>86</i>&nbsp; * A PopupWindow is a secondary window which has no window decorations or title bar.
<i>87</i>&nbsp; * It doesn&#39;t show up in the OS as a top-level window. It is typically
<i>88</i>&nbsp; * used for tool tip like notification, drop down boxes, menus, and so forth.
<i>89</i>&nbsp; * &lt;p&gt;
<i>90</i>&nbsp; * The PopupWindow &lt;strong&gt;cannot be shown without an owner&lt;/strong&gt;.
<i>91</i>&nbsp; * PopupWindows require that an owner window exist in order to be shown. However,
<i>92</i>&nbsp; * it is possible to create a PopupWindow ahead of time and simply set the owner
<i>93</i>&nbsp; * (or change the owner) before first being made visible. Attempting to change
<i>94</i>&nbsp; * the owner while the PopupWindow is visible will result in an IllegalStateException.
<i>95</i>&nbsp; * &lt;p&gt;
<i>96</i>&nbsp; * The PopupWindow encapsulates much of the behavior and functionality common to popups,
<i>97</i>&nbsp; * such as the ability to close when the &quot;esc&quot; key is pressed, or the ability to
<i>98</i>&nbsp; * hide all child popup windows whenever this window is hidden. These abilities can
<i>99</i>&nbsp; * be enabled or disabled via properties.
<i>100</i>&nbsp; * @since JavaFX 2.0
<i>101</i>&nbsp; */
<b class="fc"><i>102</i>&nbsp;public abstract class PopupWindow extends Window {</b>
<i>103</i>&nbsp;
<i>104</i>&nbsp;     static {
<b class="fc"><i>105</i>&nbsp;        PopupWindowHelper.setPopupWindowAccessor(new PopupWindowHelper.PopupWindowAccessor() {</b>
<i>106</i>&nbsp;            @Override public void doVisibleChanging(Window window, boolean visible) {
<b class="fc"><i>107</i>&nbsp;                ((PopupWindow) window).doVisibleChanging(visible);</b>
<b class="fc"><i>108</i>&nbsp;            }</b>
<i>109</i>&nbsp;
<i>110</i>&nbsp;            @Override public void doVisibleChanged(Window window, boolean visible) {
<b class="fc"><i>111</i>&nbsp;                ((PopupWindow) window).doVisibleChanged(visible);</b>
<b class="fc"><i>112</i>&nbsp;            }</b>
<i>113</i>&nbsp;
<i>114</i>&nbsp;            @Override
<i>115</i>&nbsp;            public ObservableList&lt;Node&gt; getContent(PopupWindow popupWindow) {
<b class="fc"><i>116</i>&nbsp;                return popupWindow.getContent();</b>
<i>117</i>&nbsp;            }
<i>118</i>&nbsp;        });
<b class="fc"><i>119</i>&nbsp;    }</b>
<i>120</i>&nbsp;
<i>121</i>&nbsp;    /**
<i>122</i>&nbsp;     * A private list of all child popups.
<i>123</i>&nbsp;     */
<b class="fc"><i>124</i>&nbsp;    private final List&lt;PopupWindow&gt; children = new ArrayList&lt;PopupWindow&gt;();</b>
<i>125</i>&nbsp;
<i>126</i>&nbsp;    /**
<i>127</i>&nbsp;     * Keeps track of the bounds of the content, and adjust the position and
<i>128</i>&nbsp;     * size of the popup window accordingly. This way as the popup content
<i>129</i>&nbsp;     * changes, the window will be changed to match.
<i>130</i>&nbsp;     */
<b class="fc"><i>131</i>&nbsp;    private final InvalidationListener popupWindowUpdater =</b>
<b class="fc"><i>132</i>&nbsp;            new InvalidationListener() {</b>
<i>133</i>&nbsp;                @Override
<i>134</i>&nbsp;                public void invalidated(final Observable observable) {
<b class="fc"><i>135</i>&nbsp;                    cachedExtendedBounds = null;</b>
<b class="fc"><i>136</i>&nbsp;                    cachedAnchorBounds = null;</b>
<b class="fc"><i>137</i>&nbsp;                    updateWindow(getAnchorX(), getAnchorY());</b>
<b class="fc"><i>138</i>&nbsp;                }</b>
<i>139</i>&nbsp;            };
<i>140</i>&nbsp;
<i>141</i>&nbsp;    /**
<i>142</i>&nbsp;     * RT-28454: When a parent node or parent window we are associated with is not
<i>143</i>&nbsp;     * visible anymore, possibly because the scene was not valid anymore, we should hide.
<i>144</i>&nbsp;     */
<b class="fc"><i>145</i>&nbsp;    private ChangeListener&lt;Boolean&gt; changeListener = (observable, oldValue, newValue) -&gt; {</b>
<b class="nc"><i>146</i>&nbsp;        if (oldValue &amp;&amp; !newValue) {</b>
<b class="nc"><i>147</i>&nbsp;            hide();</b>
<i>148</i>&nbsp;        }
<b class="nc"><i>149</i>&nbsp;    };</b>
<i>150</i>&nbsp;
<b class="fc"><i>151</i>&nbsp;    private WeakChangeListener&lt;Boolean&gt; weakOwnerNodeListener = new WeakChangeListener(changeListener);</b>
<i>152</i>&nbsp;
<b class="fc"><i>153</i>&nbsp;    public PopupWindow() {</b>
<b class="fc"><i>154</i>&nbsp;        final Pane popupRoot = new Pane();</b>
<b class="fc"><i>155</i>&nbsp;        popupRoot.setBackground(Background.EMPTY);</b>
<b class="fc"><i>156</i>&nbsp;        popupRoot.getStyleClass().add(&quot;popup&quot;);</b>
<i>157</i>&nbsp;
<b class="fc"><i>158</i>&nbsp;        final Scene scene = SceneHelper.createPopupScene(popupRoot);</b>
<b class="fc"><i>159</i>&nbsp;        scene.setFill(null);</b>
<b class="fc"><i>160</i>&nbsp;        super.setScene(scene);</b>
<i>161</i>&nbsp;
<b class="fc"><i>162</i>&nbsp;        popupRoot.layoutBoundsProperty().addListener(popupWindowUpdater);</b>
<b class="fc"><i>163</i>&nbsp;        popupRoot.boundsInLocalProperty().addListener(popupWindowUpdater);</b>
<b class="fc"><i>164</i>&nbsp;        scene.rootProperty().addListener(</b>
<b class="fc"><i>165</i>&nbsp;                new InvalidationListener() {</b>
<b class="fc"><i>166</i>&nbsp;                    private Node oldRoot = scene.getRoot();</b>
<i>167</i>&nbsp;
<i>168</i>&nbsp;                    @Override
<i>169</i>&nbsp;                    public void invalidated(final Observable observable) {
<b class="nc"><i>170</i>&nbsp;                        final Node newRoot = scene.getRoot();</b>
<b class="nc"><i>171</i>&nbsp;                        if (oldRoot != newRoot) {</b>
<b class="nc"><i>172</i>&nbsp;                            if (oldRoot != null) {</b>
<b class="nc"><i>173</i>&nbsp;                                oldRoot.layoutBoundsProperty()</b>
<b class="nc"><i>174</i>&nbsp;                                       .removeListener(popupWindowUpdater);</b>
<b class="nc"><i>175</i>&nbsp;                                oldRoot.boundsInLocalProperty()</b>
<b class="nc"><i>176</i>&nbsp;                                       .removeListener(popupWindowUpdater);</b>
<b class="nc"><i>177</i>&nbsp;                                oldRoot.getStyleClass().remove(&quot;popup&quot;);</b>
<i>178</i>&nbsp;                            }
<i>179</i>&nbsp;
<b class="nc"><i>180</i>&nbsp;                            if (newRoot != null) {</b>
<b class="nc"><i>181</i>&nbsp;                                newRoot.layoutBoundsProperty()</b>
<b class="nc"><i>182</i>&nbsp;                                       .addListener(popupWindowUpdater);</b>
<b class="nc"><i>183</i>&nbsp;                                newRoot.boundsInLocalProperty()</b>
<b class="nc"><i>184</i>&nbsp;                                       .addListener(popupWindowUpdater);</b>
<b class="nc"><i>185</i>&nbsp;                                newRoot.getStyleClass().add(&quot;popup&quot;);</b>
<i>186</i>&nbsp;                            }
<i>187</i>&nbsp;
<b class="nc"><i>188</i>&nbsp;                            oldRoot = newRoot;</b>
<i>189</i>&nbsp;
<b class="nc"><i>190</i>&nbsp;                            cachedExtendedBounds = null;</b>
<b class="nc"><i>191</i>&nbsp;                            cachedAnchorBounds = null;</b>
<b class="nc"><i>192</i>&nbsp;                            updateWindow(getAnchorX(), getAnchorY());</b>
<i>193</i>&nbsp;                        }
<b class="nc"><i>194</i>&nbsp;                    }</b>
<i>195</i>&nbsp;                });
<b class="fc"><i>196</i>&nbsp;        PopupWindowHelper.initHelper(this);</b>
<b class="fc"><i>197</i>&nbsp;    }</b>
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /*
<i>200</i>&nbsp;     * Gets the observable, modifiable list of children which are placed in this
<i>201</i>&nbsp;     * PopupWindow.
<i>202</i>&nbsp;     *
<i>203</i>&nbsp;     * @return the PopupWindow content
<i>204</i>&nbsp;     */
<i>205</i>&nbsp;    ObservableList&lt;Node&gt; getContent() {
<b class="fc"><i>206</i>&nbsp;        final Parent rootNode = getScene().getRoot();</b>
<b class="fc"><i>207</i>&nbsp;        if (rootNode instanceof Group) {</b>
<b class="nc"><i>208</i>&nbsp;            return ((Group) rootNode).getChildren();</b>
<i>209</i>&nbsp;        }
<i>210</i>&nbsp;
<b class="fc"><i>211</i>&nbsp;        if (rootNode instanceof Pane) {</b>
<b class="fc"><i>212</i>&nbsp;            return ((Pane) rootNode).getChildren();</b>
<i>213</i>&nbsp;        }
<i>214</i>&nbsp;
<b class="nc"><i>215</i>&nbsp;        throw new IllegalStateException(</b>
<i>216</i>&nbsp;                &quot;The content of the Popup can&#39;t be accessed&quot;);
<i>217</i>&nbsp;    }
<i>218</i>&nbsp;
<i>219</i>&nbsp;    /**
<i>220</i>&nbsp;     * The window which is the parent of this popup. All popups must have an
<i>221</i>&nbsp;     * owner window.
<i>222</i>&nbsp;     */
<b class="fc"><i>223</i>&nbsp;    private ReadOnlyObjectWrapper&lt;Window&gt; ownerWindow =</b>
<i>224</i>&nbsp;            new ReadOnlyObjectWrapper&lt;Window&gt;(this, &quot;ownerWindow&quot;);
<i>225</i>&nbsp;    public final Window getOwnerWindow() {
<b class="fc"><i>226</i>&nbsp;        return ownerWindow.get();</b>
<i>227</i>&nbsp;    }
<i>228</i>&nbsp;    public final ReadOnlyObjectProperty&lt;Window&gt; ownerWindowProperty() {
<b class="nc"><i>229</i>&nbsp;        return ownerWindow.getReadOnlyProperty();</b>
<i>230</i>&nbsp;    }
<i>231</i>&nbsp;
<i>232</i>&nbsp;    /**
<i>233</i>&nbsp;     * The node which is the owner of this popup. All popups must have an
<i>234</i>&nbsp;     * owner window but are not required to be associated with an owner node.
<i>235</i>&nbsp;     * If an autohide Popup has an owner node, mouse press inside the owner node
<i>236</i>&nbsp;     * doesn&#39;t cause the Popup to hide.
<i>237</i>&nbsp;     */
<b class="fc"><i>238</i>&nbsp;    private ReadOnlyObjectWrapper&lt;Node&gt; ownerNode =</b>
<i>239</i>&nbsp;            new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;ownerNode&quot;);
<i>240</i>&nbsp;    public final Node getOwnerNode() {
<b class="fc"><i>241</i>&nbsp;        return ownerNode.get();</b>
<i>242</i>&nbsp;    }
<i>243</i>&nbsp;    public final ReadOnlyObjectProperty&lt;Node&gt; ownerNodeProperty() {
<b class="nc"><i>244</i>&nbsp;        return ownerNode.getReadOnlyProperty();</b>
<i>245</i>&nbsp;    }
<i>246</i>&nbsp;
<i>247</i>&nbsp;    /**
<i>248</i>&nbsp;     * Note to subclasses: the scene used by PopupWindow is very specifically
<i>249</i>&nbsp;     * managed by PopupWindow. This method is overridden to throw
<i>250</i>&nbsp;     * UnsupportedOperationException. You cannot specify your own scene.
<i>251</i>&nbsp;     *
<i>252</i>&nbsp;     * @param scene the scene to be rendered on this window
<i>253</i>&nbsp;     */
<i>254</i>&nbsp;    @Override protected final void setScene(Scene scene) {
<b class="nc"><i>255</i>&nbsp;        throw new UnsupportedOperationException();</b>
<i>256</i>&nbsp;    }
<i>257</i>&nbsp;
<i>258</i>&nbsp;    /**
<i>259</i>&nbsp;     * This convenience variable indicates whether, when the popup is shown,
<i>260</i>&nbsp;     * it should automatically correct its position such that it doesn&#39;t end
<i>261</i>&nbsp;     * up positioned off the screen.
<i>262</i>&nbsp;     * @defaultValue true
<i>263</i>&nbsp;     */
<b class="fc"><i>264</i>&nbsp;    private BooleanProperty autoFix =</b>
<b class="fc"><i>265</i>&nbsp;            new BooleanPropertyBase(true) {</b>
<i>266</i>&nbsp;                @Override
<i>267</i>&nbsp;                protected void invalidated() {
<b class="nc"><i>268</i>&nbsp;                    handleAutofixActivation(isShowing(), get());</b>
<b class="nc"><i>269</i>&nbsp;                }</b>
<i>270</i>&nbsp;
<i>271</i>&nbsp;                @Override
<i>272</i>&nbsp;                public Object getBean() {
<b class="nc"><i>273</i>&nbsp;                    return PopupWindow.this;</b>
<i>274</i>&nbsp;                }
<i>275</i>&nbsp;
<i>276</i>&nbsp;                @Override
<i>277</i>&nbsp;                public String getName() {
<b class="nc"><i>278</i>&nbsp;                    return &quot;autoFix&quot;;</b>
<i>279</i>&nbsp;                }
<i>280</i>&nbsp;            };
<b class="nc"><i>281</i>&nbsp;    public final void setAutoFix(boolean value) { autoFix.set(value); }</b>
<b class="fc"><i>282</i>&nbsp;    public final boolean isAutoFix() { return autoFix.get(); }</b>
<b class="nc"><i>283</i>&nbsp;    public final BooleanProperty autoFixProperty() { return autoFix; }</b>
<i>284</i>&nbsp;
<i>285</i>&nbsp;    /**
<i>286</i>&nbsp;     * Specifies whether Popups should auto hide. If a popup loses focus and
<i>287</i>&nbsp;     * autoHide is true, then the popup will be hidden automatically.
<i>288</i>&nbsp;     * &lt;p&gt;
<i>289</i>&nbsp;     * The only exception is when owner Node is specified using {@link #show(javafx.scene.Node, double, double)}.
<i>290</i>&nbsp;     * Focusing owner Node will not hide the PopupWindow.
<i>291</i>&nbsp;     * &lt;/p&gt;
<i>292</i>&nbsp;     * @defaultValue false
<i>293</i>&nbsp;     */
<b class="fc"><i>294</i>&nbsp;    private BooleanProperty autoHide =</b>
<b class="fc"><i>295</i>&nbsp;            new BooleanPropertyBase() {</b>
<i>296</i>&nbsp;                @Override
<i>297</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>298</i>&nbsp;                    handleAutohideActivation(isShowing(), get());</b>
<b class="fc"><i>299</i>&nbsp;                }</b>
<i>300</i>&nbsp;
<i>301</i>&nbsp;                @Override
<i>302</i>&nbsp;                public Object getBean() {
<b class="nc"><i>303</i>&nbsp;                    return PopupWindow.this;</b>
<i>304</i>&nbsp;                }
<i>305</i>&nbsp;
<i>306</i>&nbsp;                @Override
<i>307</i>&nbsp;                public String getName() {
<b class="nc"><i>308</i>&nbsp;                    return &quot;autoHide&quot;;</b>
<i>309</i>&nbsp;                }
<i>310</i>&nbsp;            };
<b class="fc"><i>311</i>&nbsp;    public final void setAutoHide(boolean value) { autoHide.set(value); }</b>
<b class="fc"><i>312</i>&nbsp;    public final boolean isAutoHide() { return autoHide.get(); }</b>
<b class="nc"><i>313</i>&nbsp;    public final BooleanProperty autoHideProperty() { return autoHide; }</b>
<i>314</i>&nbsp;
<i>315</i>&nbsp;    /**
<i>316</i>&nbsp;     * Called after autoHide is run.
<i>317</i>&nbsp;     */
<b class="fc"><i>318</i>&nbsp;    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onAutoHide =</b>
<i>319</i>&nbsp;            new SimpleObjectProperty&lt;EventHandler&lt;Event&gt;&gt;(this, &quot;onAutoHide&quot;);
<b class="nc"><i>320</i>&nbsp;    public final void setOnAutoHide(EventHandler&lt;Event&gt; value) { onAutoHide.set(value); }</b>
<b class="nc"><i>321</i>&nbsp;    public final EventHandler&lt;Event&gt; getOnAutoHide() { return onAutoHide.get(); }</b>
<b class="nc"><i>322</i>&nbsp;    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onAutoHideProperty() { return onAutoHide; }</b>
<i>323</i>&nbsp;
<i>324</i>&nbsp;    /**
<i>325</i>&nbsp;     * Specifies whether the PopupWindow should be hidden when an unhandled escape key
<i>326</i>&nbsp;     * is pressed while the popup has focus.
<i>327</i>&nbsp;     * @defaultValue true
<i>328</i>&nbsp;     */
<b class="fc"><i>329</i>&nbsp;    private BooleanProperty hideOnEscape =</b>
<i>330</i>&nbsp;            new SimpleBooleanProperty(this, &quot;hideOnEscape&quot;, true);
<b class="nc"><i>331</i>&nbsp;    public final void setHideOnEscape(boolean value) { hideOnEscape.set(value); }</b>
<b class="nc"><i>332</i>&nbsp;    public final boolean isHideOnEscape() { return hideOnEscape.get(); }</b>
<b class="nc"><i>333</i>&nbsp;    public final BooleanProperty hideOnEscapeProperty() { return hideOnEscape; }</b>
<i>334</i>&nbsp;
<i>335</i>&nbsp;    /**
<i>336</i>&nbsp;     * Specifies whether the event, which caused the Popup to hide, should be
<i>337</i>&nbsp;     * consumed. Having the event consumed prevents it from triggering some
<i>338</i>&nbsp;     * additional UI response in the Popup&#39;s owner window.
<i>339</i>&nbsp;     * @defaultValue true
<i>340</i>&nbsp;     * @since JavaFX 2.2
<i>341</i>&nbsp;     */
<b class="fc"><i>342</i>&nbsp;    private BooleanProperty consumeAutoHidingEvents =</b>
<i>343</i>&nbsp;            new SimpleBooleanProperty(this, &quot;consumeAutoHidingEvents&quot;,
<i>344</i>&nbsp;                                      true);
<i>345</i>&nbsp;
<i>346</i>&nbsp;    public final void setConsumeAutoHidingEvents(boolean value) {
<b class="fc"><i>347</i>&nbsp;        consumeAutoHidingEvents.set(value);</b>
<b class="fc"><i>348</i>&nbsp;    }</b>
<i>349</i>&nbsp;
<i>350</i>&nbsp;    public final boolean getConsumeAutoHidingEvents() {
<b class="nc"><i>351</i>&nbsp;        return consumeAutoHidingEvents.get();</b>
<i>352</i>&nbsp;    }
<i>353</i>&nbsp;
<i>354</i>&nbsp;    public final BooleanProperty consumeAutoHidingEventsProperty() {
<b class="nc"><i>355</i>&nbsp;        return consumeAutoHidingEvents;</b>
<i>356</i>&nbsp;    }
<i>357</i>&nbsp;
<i>358</i>&nbsp;    /**
<i>359</i>&nbsp;     * Show the popup.
<i>360</i>&nbsp;     * @param owner The owner of the popup. This must not be null.
<i>361</i>&nbsp;     * @throws NullPointerException if owner is null
<i>362</i>&nbsp;     * @throws IllegalArgumentException if the specified owner window would
<i>363</i>&nbsp;     *      create cycle in the window hierarchy
<i>364</i>&nbsp;     */
<i>365</i>&nbsp;    public void show(Window owner) {
<b class="nc"><i>366</i>&nbsp;        validateOwnerWindow(owner);</b>
<b class="nc"><i>367</i>&nbsp;        showImpl(owner);</b>
<b class="nc"><i>368</i>&nbsp;    }</b>
<i>369</i>&nbsp;
<i>370</i>&nbsp;    /**
<i>371</i>&nbsp;     * Shows the popup at the specified location on the screen. The popup window
<i>372</i>&nbsp;     * is positioned in such way that its anchor point ({@link #anchorLocation})
<i>373</i>&nbsp;     * is displayed at the specified {@code anchorX} and {@code anchorY}
<i>374</i>&nbsp;     * coordinates.
<i>375</i>&nbsp;     * &lt;p&gt;
<i>376</i>&nbsp;     * The popup is associated with the specified owner node. The {@code Window}
<i>377</i>&nbsp;     * which contains the owner node at the time of the call becomes an owner
<i>378</i>&nbsp;     * window of the displayed popup.
<i>379</i>&nbsp;     * &lt;/p&gt;
<i>380</i>&nbsp;     * &lt;p&gt;
<i>381</i>&nbsp;     * Note that when {@link #autoHideProperty()} is set to true, mouse press on the owner Node
<i>382</i>&nbsp;     * will not hide the PopupWindow.
<i>383</i>&nbsp;     * &lt;/p&gt;
<i>384</i>&nbsp;     *
<i>385</i>&nbsp;     * @param ownerNode The owner Node of the popup. It must not be null
<i>386</i>&nbsp;     *        and must be associated with a Window.
<i>387</i>&nbsp;     * @param anchorX the x position of the popup anchor in screen coordinates
<i>388</i>&nbsp;     * @param anchorY the y position of the popup anchor in screen coordinates
<i>389</i>&nbsp;     * @throws NullPointerException if ownerNode is null
<i>390</i>&nbsp;     * @throws IllegalArgumentException if the specified owner node is not
<i>391</i>&nbsp;     *      associated with a Window or when the window would create cycle
<i>392</i>&nbsp;     *      in the window hierarchy
<i>393</i>&nbsp;     */
<i>394</i>&nbsp;    public void show(Node ownerNode, double anchorX, double anchorY) {
<b class="fc"><i>395</i>&nbsp;        if (ownerNode == null) {</b>
<b class="nc"><i>396</i>&nbsp;            throw new NullPointerException(&quot;The owner node must not be null&quot;);</b>
<i>397</i>&nbsp;        }
<i>398</i>&nbsp;
<b class="fc"><i>399</i>&nbsp;        final Scene ownerNodeScene = ownerNode.getScene();</b>
<b class="fc"><i>400</i>&nbsp;        if ((ownerNodeScene == null)</b>
<b class="fc"><i>401</i>&nbsp;                || (ownerNodeScene.getWindow() == null)) {</b>
<b class="nc"><i>402</i>&nbsp;            throw new IllegalArgumentException(</b>
<i>403</i>&nbsp;                    &quot;The owner node needs to be associated with a window&quot;);
<i>404</i>&nbsp;        }
<i>405</i>&nbsp;
<b class="fc"><i>406</i>&nbsp;        final Window newOwnerWindow = ownerNodeScene.getWindow();</b>
<b class="fc"><i>407</i>&nbsp;        validateOwnerWindow(newOwnerWindow);</b>
<i>408</i>&nbsp;
<b class="fc"><i>409</i>&nbsp;        this.ownerNode.set(ownerNode);</b>
<i>410</i>&nbsp;
<i>411</i>&nbsp;        // PopupWindow should disappear when owner node is not visible
<b class="fc"><i>412</i>&nbsp;        if (ownerNode != null) {</b>
<b class="fc"><i>413</i>&nbsp;            NodeHelper.treeShowingProperty(ownerNode).addListener(weakOwnerNodeListener);</b>
<i>414</i>&nbsp;        }
<i>415</i>&nbsp;
<b class="fc"><i>416</i>&nbsp;        updateWindow(anchorX, anchorY);</b>
<b class="fc"><i>417</i>&nbsp;        showImpl(newOwnerWindow);</b>
<b class="fc"><i>418</i>&nbsp;    }</b>
<i>419</i>&nbsp;
<i>420</i>&nbsp;    /**
<i>421</i>&nbsp;     * Shows the popup at the specified location on the screen. The popup window
<i>422</i>&nbsp;     * is positioned in such way that its anchor point ({@link #anchorLocation})
<i>423</i>&nbsp;     * is displayed at the specified {@code anchorX} and {@code anchorY}
<i>424</i>&nbsp;     * coordinates.
<i>425</i>&nbsp;     *
<i>426</i>&nbsp;     * @param ownerWindow The owner of the popup. This must not be null.
<i>427</i>&nbsp;     * @param anchorX the x position of the popup anchor in screen coordinates
<i>428</i>&nbsp;     * @param anchorY the y position of the popup anchor in screen coordinates
<i>429</i>&nbsp;     * @throws NullPointerException if ownerWindow is null
<i>430</i>&nbsp;     * @throws IllegalArgumentException if the specified owner window would
<i>431</i>&nbsp;     *      create cycle in the window hierarchy
<i>432</i>&nbsp;     */
<i>433</i>&nbsp;    public void show(Window ownerWindow, double anchorX, double anchorY) {
<b class="nc"><i>434</i>&nbsp;        validateOwnerWindow(ownerWindow);</b>
<i>435</i>&nbsp;
<b class="nc"><i>436</i>&nbsp;        updateWindow(anchorX, anchorY);</b>
<b class="nc"><i>437</i>&nbsp;        showImpl(ownerWindow);</b>
<b class="nc"><i>438</i>&nbsp;    }</b>
<i>439</i>&nbsp;
<i>440</i>&nbsp;    private void showImpl(final Window owner) {
<i>441</i>&nbsp;        // Update the owner field
<b class="fc"><i>442</i>&nbsp;        this.ownerWindow.set(owner);</b>
<b class="fc"><i>443</i>&nbsp;        if (owner instanceof PopupWindow) {</b>
<b class="nc"><i>444</i>&nbsp;            ((PopupWindow)owner).children.add(this);</b>
<i>445</i>&nbsp;        }
<i>446</i>&nbsp;        // PopupWindow should disappear when owner node is not visible
<b class="fc"><i>447</i>&nbsp;        if (owner != null) {</b>
<b class="fc"><i>448</i>&nbsp;            owner.showingProperty().addListener(weakOwnerNodeListener);</b>
<i>449</i>&nbsp;        }
<i>450</i>&nbsp;
<b class="fc"><i>451</i>&nbsp;        final Scene sceneValue = getScene();</b>
<b class="fc"><i>452</i>&nbsp;        SceneHelper.parentEffectiveOrientationInvalidated(sceneValue);</b>
<i>453</i>&nbsp;
<i>454</i>&nbsp;        // RT-28447
<b class="fc"><i>455</i>&nbsp;        final Scene ownerScene = getRootWindow(owner).getScene();</b>
<b class="fc"><i>456</i>&nbsp;        if (ownerScene != null) {</b>
<b class="fc"><i>457</i>&nbsp;            if (ownerScene.getUserAgentStylesheet() != null) {</b>
<b class="nc"><i>458</i>&nbsp;                sceneValue.setUserAgentStylesheet(ownerScene.getUserAgentStylesheet());</b>
<i>459</i>&nbsp;            }
<b class="fc"><i>460</i>&nbsp;            sceneValue.getStylesheets().setAll(ownerScene.getStylesheets());</b>
<b class="fc"><i>461</i>&nbsp;            if (sceneValue.getCursor() == null) {</b>
<b class="fc"><i>462</i>&nbsp;                sceneValue.setCursor(ownerScene.getCursor());</b>
<i>463</i>&nbsp;            }
<i>464</i>&nbsp;        }
<i>465</i>&nbsp;
<i>466</i>&nbsp;        // It is required that the root window exist and be visible to show the popup.
<b class="fc"><i>467</i>&nbsp;        if (getRootWindow(owner).isShowing()) {</b>
<i>468</i>&nbsp;            // We do show() first so that the width and height of the
<i>469</i>&nbsp;            // popup window are initialized. This way the x,y location of the
<i>470</i>&nbsp;            // popup calculated below uses the right width and height values for
<i>471</i>&nbsp;            // its calculation. (fix for part of RT-10675).
<b class="fc"><i>472</i>&nbsp;            show();</b>
<i>473</i>&nbsp;        }
<b class="fc"><i>474</i>&nbsp;    }</b>
<i>475</i>&nbsp;
<i>476</i>&nbsp;    /**
<i>477</i>&nbsp;     * Hide this Popup and all its children
<i>478</i>&nbsp;     */
<i>479</i>&nbsp;    @Override public void hide() {
<b class="fc"><i>480</i>&nbsp;        for (PopupWindow c : children) {</b>
<b class="nc"><i>481</i>&nbsp;            if (c.isShowing()) {</b>
<b class="nc"><i>482</i>&nbsp;                c.hide();</b>
<i>483</i>&nbsp;            }
<b class="nc"><i>484</i>&nbsp;        }</b>
<b class="fc"><i>485</i>&nbsp;        children.clear();</b>
<b class="fc"><i>486</i>&nbsp;        super.hide();</b>
<i>487</i>&nbsp;
<i>488</i>&nbsp;        // When popup hides, remove listeners; these are added when the popup shows.
<b class="fc"><i>489</i>&nbsp;        if (getOwnerWindow() != null) getOwnerWindow().showingProperty().removeListener(weakOwnerNodeListener);</b>
<b class="fc"><i>490</i>&nbsp;        if (getOwnerNode() != null) NodeHelper.treeShowingProperty(getOwnerNode()).removeListener(weakOwnerNodeListener);</b>
<b class="fc"><i>491</i>&nbsp;    }</b>
<i>492</i>&nbsp;
<i>493</i>&nbsp;    /*
<i>494</i>&nbsp;     * This can be replaced by listening for the onShowing/onHiding events
<i>495</i>&nbsp;     * Note: This method MUST only be called via its accessor method.
<i>496</i>&nbsp;     */
<i>497</i>&nbsp;    private void doVisibleChanging(boolean visible) {
<b class="fc"><i>498</i>&nbsp;        PerformanceTracker.logEvent(&quot;PopupWindow.storeVisible for [PopupWindow]&quot;);</b>
<i>499</i>&nbsp;
<b class="fc"><i>500</i>&nbsp;        Toolkit toolkit = Toolkit.getToolkit();</b>
<b class="fc"><i>501</i>&nbsp;        if (visible &amp;&amp; (getPeer() == null)) {</b>
<i>502</i>&nbsp;            // Setup the peer
<i>503</i>&nbsp;            StageStyle popupStyle;
<i>504</i>&nbsp;            try {
<i>505</i>&nbsp;                final SecurityManager securityManager =
<b class="fc"><i>506</i>&nbsp;                        System.getSecurityManager();</b>
<b class="fc"><i>507</i>&nbsp;                if (securityManager != null) {</b>
<b class="nc"><i>508</i>&nbsp;                    securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);</b>
<i>509</i>&nbsp;                }
<b class="fc"><i>510</i>&nbsp;                popupStyle = StageStyle.TRANSPARENT;</b>
<b class="nc"><i>511</i>&nbsp;            } catch (final SecurityException e) {</b>
<b class="nc"><i>512</i>&nbsp;                popupStyle = StageStyle.UNDECORATED;</b>
<b class="fc"><i>513</i>&nbsp;            }</b>
<b class="fc"><i>514</i>&nbsp;            setPeer(toolkit.createTKPopupStage(this, popupStyle, getOwnerWindow().getPeer(), acc));</b>
<b class="fc"><i>515</i>&nbsp;            setPeerListener(new PopupWindowPeerListener(PopupWindow.this));</b>
<i>516</i>&nbsp;        }
<b class="fc"><i>517</i>&nbsp;    }</b>
<i>518</i>&nbsp;
<i>519</i>&nbsp;    private Window rootWindow;
<i>520</i>&nbsp;
<i>521</i>&nbsp;    /*
<i>522</i>&nbsp;     * This can be replaced by listening for the onShown/onHidden events
<i>523</i>&nbsp;     * Note: This method MUST only be called via its accessor method.
<i>524</i>&nbsp;     */
<i>525</i>&nbsp;    private void doVisibleChanged(boolean visible) {
<b class="fc"><i>526</i>&nbsp;        final Window ownerWindowValue = getOwnerWindow();</b>
<b class="fc"><i>527</i>&nbsp;        if (visible) {</b>
<b class="fc"><i>528</i>&nbsp;            rootWindow = getRootWindow(ownerWindowValue);</b>
<i>529</i>&nbsp;
<b class="fc"><i>530</i>&nbsp;            startMonitorOwnerEvents(ownerWindowValue);</b>
<i>531</i>&nbsp;            // currently we consider popup window to be focused when it is
<i>532</i>&nbsp;            // visible and its owner window is focused (we need to track
<i>533</i>&nbsp;            // that through listener on owner window focused property)
<i>534</i>&nbsp;            // a better solution would require some focus manager, which can
<i>535</i>&nbsp;            // track focus state across multiple windows
<b class="fc"><i>536</i>&nbsp;            bindOwnerFocusedProperty(ownerWindowValue);</b>
<b class="fc"><i>537</i>&nbsp;            WindowHelper.setFocused(this, ownerWindowValue.isFocused());</b>
<b class="fc"><i>538</i>&nbsp;            handleAutofixActivation(true, isAutoFix());</b>
<b class="fc"><i>539</i>&nbsp;            handleAutohideActivation(true, isAutoHide());</b>
<i>540</i>&nbsp;        } else {
<b class="fc"><i>541</i>&nbsp;            stopMonitorOwnerEvents(ownerWindowValue);</b>
<b class="fc"><i>542</i>&nbsp;            unbindOwnerFocusedProperty(ownerWindowValue);</b>
<b class="fc"><i>543</i>&nbsp;            WindowHelper.setFocused(this, false);</b>
<b class="fc"><i>544</i>&nbsp;            handleAutofixActivation(false, isAutoFix());</b>
<b class="fc"><i>545</i>&nbsp;            handleAutohideActivation(false, isAutoHide());</b>
<b class="fc"><i>546</i>&nbsp;            rootWindow = null;</b>
<i>547</i>&nbsp;        }
<i>548</i>&nbsp;
<b class="fc"><i>549</i>&nbsp;        PerformanceTracker.logEvent(&quot;PopupWindow.storeVisible for [PopupWindow] finished&quot;);</b>
<b class="fc"><i>550</i>&nbsp;    }</b>
<i>551</i>&nbsp;
<i>552</i>&nbsp;    /**
<i>553</i>&nbsp;     * Specifies the x coordinate of the popup anchor point on the screen. If
<i>554</i>&nbsp;     * the {@code anchorLocation} is set to {@code WINDOW_TOP_LEFT} or
<i>555</i>&nbsp;     * {@code WINDOW_BOTTOM_LEFT} the {@code x} and {@code anchorX} values will
<i>556</i>&nbsp;     * be identical.
<i>557</i>&nbsp;     *
<i>558</i>&nbsp;     * @since JavaFX 8.0
<i>559</i>&nbsp;     */
<b class="fc"><i>560</i>&nbsp;    private final ReadOnlyDoubleWrapper anchorX =</b>
<i>561</i>&nbsp;            new ReadOnlyDoubleWrapper(this, &quot;anchorX&quot;, Double.NaN);
<i>562</i>&nbsp;
<i>563</i>&nbsp;    public final void setAnchorX(final double value) {
<b class="nc"><i>564</i>&nbsp;        updateWindow(value, getAnchorY());</b>
<b class="nc"><i>565</i>&nbsp;    }</b>
<i>566</i>&nbsp;    public final double getAnchorX() {
<b class="fc"><i>567</i>&nbsp;        return anchorX.get();</b>
<i>568</i>&nbsp;    }
<i>569</i>&nbsp;    public final ReadOnlyDoubleProperty anchorXProperty() {
<b class="nc"><i>570</i>&nbsp;        return anchorX.getReadOnlyProperty();</b>
<i>571</i>&nbsp;    }
<i>572</i>&nbsp;
<i>573</i>&nbsp;    /**
<i>574</i>&nbsp;     * Specifies the y coordinate of the popup anchor point on the screen. If
<i>575</i>&nbsp;     * the {@code anchorLocation} is set to {@code WINDOW_TOP_LEFT} or
<i>576</i>&nbsp;     * {@code WINDOW_TOP_RIGHT} the {@code y} and {@code anchorY} values will
<i>577</i>&nbsp;     * be identical.
<i>578</i>&nbsp;     *
<i>579</i>&nbsp;     * @since JavaFX 8.0
<i>580</i>&nbsp;     */
<b class="fc"><i>581</i>&nbsp;    private final ReadOnlyDoubleWrapper anchorY =</b>
<i>582</i>&nbsp;            new ReadOnlyDoubleWrapper(this, &quot;anchorY&quot;, Double.NaN);
<i>583</i>&nbsp;
<i>584</i>&nbsp;    public final void setAnchorY(final double value) {
<b class="nc"><i>585</i>&nbsp;        updateWindow(getAnchorX(), value);</b>
<b class="nc"><i>586</i>&nbsp;    }</b>
<i>587</i>&nbsp;    public final double getAnchorY() {
<b class="fc"><i>588</i>&nbsp;        return anchorY.get();</b>
<i>589</i>&nbsp;    }
<i>590</i>&nbsp;    public final ReadOnlyDoubleProperty anchorYProperty() {
<b class="nc"><i>591</i>&nbsp;        return anchorY.getReadOnlyProperty();</b>
<i>592</i>&nbsp;    }
<i>593</i>&nbsp;
<i>594</i>&nbsp;    /**
<i>595</i>&nbsp;     * Specifies the popup anchor point which is used in popup positioning. The
<i>596</i>&nbsp;     * point can be set to a corner of the popup window or a corner of its
<i>597</i>&nbsp;     * content. In this context the content corners are derived from the popup
<i>598</i>&nbsp;     * root node&#39;s layout bounds.
<i>599</i>&nbsp;     * &lt;p&gt;
<i>600</i>&nbsp;     * In general changing of the anchor location won&#39;t change the current
<i>601</i>&nbsp;     * window position. Instead of that, the {@code anchorX} and {@code anchorY}
<i>602</i>&nbsp;     * values are recalculated to correspond to the new anchor point.
<i>603</i>&nbsp;     * &lt;/p&gt;
<i>604</i>&nbsp;     * @since JavaFX 8.0
<i>605</i>&nbsp;     */
<b class="fc"><i>606</i>&nbsp;    private final ObjectProperty&lt;AnchorLocation&gt; anchorLocation =</b>
<i>607</i>&nbsp;            new ObjectPropertyBase&lt;AnchorLocation&gt;(
<b class="fc"><i>608</i>&nbsp;                    AnchorLocation.WINDOW_TOP_LEFT) {</b>
<i>609</i>&nbsp;                @Override
<i>610</i>&nbsp;                protected void invalidated() {
<b class="fc"><i>611</i>&nbsp;                    cachedAnchorBounds = null;</b>
<b class="fc"><i>612</i>&nbsp;                    updateWindow(windowToAnchorX(getX()),</b>
<b class="fc"><i>613</i>&nbsp;                                 windowToAnchorY(getY()));</b>
<b class="fc"><i>614</i>&nbsp;                }</b>
<i>615</i>&nbsp;
<i>616</i>&nbsp;                @Override
<i>617</i>&nbsp;                public Object getBean() {
<b class="nc"><i>618</i>&nbsp;                    return PopupWindow.this;</b>
<i>619</i>&nbsp;                }
<i>620</i>&nbsp;
<i>621</i>&nbsp;                @Override
<i>622</i>&nbsp;                public String getName() {
<b class="nc"><i>623</i>&nbsp;                    return &quot;anchorLocation&quot;;</b>
<i>624</i>&nbsp;                }
<i>625</i>&nbsp;            };
<i>626</i>&nbsp;    public final void setAnchorLocation(final AnchorLocation value) {
<b class="fc"><i>627</i>&nbsp;        anchorLocation.set(value);</b>
<b class="fc"><i>628</i>&nbsp;    }</b>
<i>629</i>&nbsp;    public final AnchorLocation getAnchorLocation() {
<b class="fc"><i>630</i>&nbsp;        return anchorLocation.get();</b>
<i>631</i>&nbsp;    }
<i>632</i>&nbsp;    public final ObjectProperty&lt;AnchorLocation&gt; anchorLocationProperty() {
<b class="nc"><i>633</i>&nbsp;        return anchorLocation;</b>
<i>634</i>&nbsp;    }
<i>635</i>&nbsp;
<i>636</i>&nbsp;    /**
<i>637</i>&nbsp;     * Anchor location constants for popup anchor point selection.
<i>638</i>&nbsp;     *
<i>639</i>&nbsp;     * @since JavaFX 8.0
<i>640</i>&nbsp;     */
<b class="fc"><i>641</i>&nbsp;    public enum AnchorLocation {</b>
<i>642</i>&nbsp;        /** Represents top left window corner. */
<b class="fc"><i>643</i>&nbsp;        WINDOW_TOP_LEFT(0, 0, false),</b>
<i>644</i>&nbsp;        /** Represents top right window corner. */
<b class="fc"><i>645</i>&nbsp;        WINDOW_TOP_RIGHT(1, 0, false),</b>
<i>646</i>&nbsp;        /** Represents bottom left window corner. */
<b class="fc"><i>647</i>&nbsp;        WINDOW_BOTTOM_LEFT(0, 1, false),</b>
<i>648</i>&nbsp;        /** Represents bottom right window corner. */
<b class="fc"><i>649</i>&nbsp;        WINDOW_BOTTOM_RIGHT(1, 1, false),</b>
<i>650</i>&nbsp;        /** Represents top left content corner. */
<b class="fc"><i>651</i>&nbsp;        CONTENT_TOP_LEFT(0, 0, true),</b>
<i>652</i>&nbsp;        /** Represents top right content corner. */
<b class="fc"><i>653</i>&nbsp;        CONTENT_TOP_RIGHT(1, 0, true),</b>
<i>654</i>&nbsp;        /** Represents bottom left content corner. */
<b class="fc"><i>655</i>&nbsp;        CONTENT_BOTTOM_LEFT(0, 1, true),</b>
<i>656</i>&nbsp;        /** Represents bottom right content corner. */
<b class="fc"><i>657</i>&nbsp;        CONTENT_BOTTOM_RIGHT(1, 1, true);</b>
<i>658</i>&nbsp;
<i>659</i>&nbsp;        private final double xCoef;
<i>660</i>&nbsp;        private final double yCoef;
<i>661</i>&nbsp;        private final boolean contentLocation;
<i>662</i>&nbsp;
<i>663</i>&nbsp;        private AnchorLocation(final double xCoef, final double yCoef,
<b class="fc"><i>664</i>&nbsp;                               final boolean contentLocation) {</b>
<b class="fc"><i>665</i>&nbsp;            this.xCoef = xCoef;</b>
<b class="fc"><i>666</i>&nbsp;            this.yCoef = yCoef;</b>
<b class="fc"><i>667</i>&nbsp;            this.contentLocation = contentLocation;</b>
<b class="fc"><i>668</i>&nbsp;        }</b>
<i>669</i>&nbsp;
<i>670</i>&nbsp;        double getXCoef() {
<b class="fc"><i>671</i>&nbsp;            return xCoef;</b>
<i>672</i>&nbsp;        }
<i>673</i>&nbsp;
<i>674</i>&nbsp;        double getYCoef() {
<b class="fc"><i>675</i>&nbsp;            return yCoef;</b>
<i>676</i>&nbsp;        }
<i>677</i>&nbsp;
<i>678</i>&nbsp;        boolean isContentLocation() {
<b class="fc"><i>679</i>&nbsp;            return contentLocation;</b>
<i>680</i>&nbsp;        }
<i>681</i>&nbsp;    };
<i>682</i>&nbsp;
<i>683</i>&nbsp;    @Override
<i>684</i>&nbsp;    void setXInternal(final double value) {
<b class="nc"><i>685</i>&nbsp;        updateWindow(windowToAnchorX(value), getAnchorY());</b>
<b class="nc"><i>686</i>&nbsp;    }</b>
<i>687</i>&nbsp;
<i>688</i>&nbsp;    @Override
<i>689</i>&nbsp;    void setYInternal(final double value) {
<b class="nc"><i>690</i>&nbsp;        updateWindow(getAnchorX(), windowToAnchorY(value));</b>
<b class="nc"><i>691</i>&nbsp;    }</b>
<i>692</i>&nbsp;
<i>693</i>&nbsp;    @Override
<i>694</i>&nbsp;    void notifyLocationChanged(final double newX, final double newY) {
<b class="nc"><i>695</i>&nbsp;        super.notifyLocationChanged(newX, newY);</b>
<b class="nc"><i>696</i>&nbsp;        anchorX.set(windowToAnchorX(newX));</b>
<b class="nc"><i>697</i>&nbsp;        anchorY.set(windowToAnchorY(newY));</b>
<b class="nc"><i>698</i>&nbsp;    }</b>
<i>699</i>&nbsp;
<i>700</i>&nbsp;    private Bounds cachedExtendedBounds;
<i>701</i>&nbsp;    private Bounds cachedAnchorBounds;
<i>702</i>&nbsp;
<i>703</i>&nbsp;    private Bounds getExtendedBounds() {
<b class="fc"><i>704</i>&nbsp;        if (cachedExtendedBounds == null) {</b>
<b class="fc"><i>705</i>&nbsp;            final Parent rootNode = getScene().getRoot();</b>
<b class="fc"><i>706</i>&nbsp;            cachedExtendedBounds = union(rootNode.getLayoutBounds(),</b>
<b class="fc"><i>707</i>&nbsp;                                         rootNode.getBoundsInLocal());</b>
<i>708</i>&nbsp;        }
<i>709</i>&nbsp;
<b class="fc"><i>710</i>&nbsp;        return cachedExtendedBounds;</b>
<i>711</i>&nbsp;    }
<i>712</i>&nbsp;
<i>713</i>&nbsp;    private Bounds getAnchorBounds() {
<b class="fc"><i>714</i>&nbsp;        if (cachedAnchorBounds == null) {</b>
<b class="fc"><i>715</i>&nbsp;            cachedAnchorBounds = getAnchorLocation().isContentLocation()</b>
<b class="fc"><i>716</i>&nbsp;                                         ? getScene().getRoot()</b>
<b class="fc"><i>717</i>&nbsp;                                                     .getLayoutBounds()</b>
<b class="nc"><i>718</i>&nbsp;                                         : getExtendedBounds();</b>
<i>719</i>&nbsp;        }
<i>720</i>&nbsp;
<b class="fc"><i>721</i>&nbsp;        return cachedAnchorBounds;</b>
<i>722</i>&nbsp;    }
<i>723</i>&nbsp;
<i>724</i>&nbsp;    private void updateWindow(final double newAnchorX,
<i>725</i>&nbsp;                              final double newAnchorY) {
<b class="fc"><i>726</i>&nbsp;        final AnchorLocation anchorLocationValue = getAnchorLocation();</b>
<b class="fc"><i>727</i>&nbsp;        final Parent rootNode = getScene().getRoot();</b>
<b class="fc"><i>728</i>&nbsp;        final Bounds extendedBounds = getExtendedBounds();</b>
<b class="fc"><i>729</i>&nbsp;        final Bounds anchorBounds = getAnchorBounds();</b>
<i>730</i>&nbsp;
<b class="fc"><i>731</i>&nbsp;        final double anchorXCoef = anchorLocationValue.getXCoef();</b>
<b class="fc"><i>732</i>&nbsp;        final double anchorYCoef = anchorLocationValue.getYCoef();</b>
<b class="fc"><i>733</i>&nbsp;        final double anchorDeltaX = anchorXCoef * anchorBounds.getWidth();</b>
<b class="fc"><i>734</i>&nbsp;        final double anchorDeltaY = anchorYCoef * anchorBounds.getHeight();</b>
<b class="fc"><i>735</i>&nbsp;        double anchorScrMinX = newAnchorX - anchorDeltaX;</b>
<b class="fc"><i>736</i>&nbsp;        double anchorScrMinY = newAnchorY - anchorDeltaY;</b>
<i>737</i>&nbsp;
<b class="fc"><i>738</i>&nbsp;        if (autofixActive) {</b>
<b class="fc"><i>739</i>&nbsp;            final Screen currentScreen =</b>
<b class="fc"><i>740</i>&nbsp;                    Utils.getScreenForPoint(newAnchorX, newAnchorY);</b>
<i>741</i>&nbsp;            final Rectangle2D screenBounds =
<b class="fc"><i>742</i>&nbsp;                    Utils.hasFullScreenStage(currentScreen)</b>
<b class="nc"><i>743</i>&nbsp;                            ? currentScreen.getBounds()</b>
<b class="fc"><i>744</i>&nbsp;                            : currentScreen.getVisualBounds();</b>
<i>745</i>&nbsp;
<b class="fc"><i>746</i>&nbsp;            if (anchorXCoef &lt;= 0.5) {</b>
<i>747</i>&nbsp;                // left side of the popup is more important, try to keep it
<i>748</i>&nbsp;                // visible if the popup width is larger than screen width
<b class="fc"><i>749</i>&nbsp;                anchorScrMinX = Math.min(anchorScrMinX,</b>
<b class="fc"><i>750</i>&nbsp;                                         screenBounds.getMaxX()</b>
<b class="fc"><i>751</i>&nbsp;                                             - anchorBounds.getWidth());</b>
<b class="fc"><i>752</i>&nbsp;                anchorScrMinX = Math.max(anchorScrMinX, screenBounds.getMinX());</b>
<i>753</i>&nbsp;            } else {
<i>754</i>&nbsp;                // right side of the popup is more important
<b class="nc"><i>755</i>&nbsp;                anchorScrMinX = Math.max(anchorScrMinX, screenBounds.getMinX());</b>
<b class="nc"><i>756</i>&nbsp;                anchorScrMinX = Math.min(anchorScrMinX,</b>
<b class="nc"><i>757</i>&nbsp;                                         screenBounds.getMaxX()</b>
<b class="nc"><i>758</i>&nbsp;                                             - anchorBounds.getWidth());</b>
<i>759</i>&nbsp;            }
<i>760</i>&nbsp;
<b class="fc"><i>761</i>&nbsp;            if (anchorYCoef &lt;= 0.5) {</b>
<i>762</i>&nbsp;                // top side of the popup is more important
<b class="fc"><i>763</i>&nbsp;                anchorScrMinY = Math.min(anchorScrMinY,</b>
<b class="fc"><i>764</i>&nbsp;                                         screenBounds.getMaxY()</b>
<b class="fc"><i>765</i>&nbsp;                                             - anchorBounds.getHeight());</b>
<b class="fc"><i>766</i>&nbsp;                anchorScrMinY = Math.max(anchorScrMinY, screenBounds.getMinY());</b>
<i>767</i>&nbsp;            } else {
<i>768</i>&nbsp;                // bottom side of the popup is more important
<b class="nc"><i>769</i>&nbsp;                anchorScrMinY = Math.max(anchorScrMinY, screenBounds.getMinY());</b>
<b class="nc"><i>770</i>&nbsp;                anchorScrMinY = Math.min(anchorScrMinY,</b>
<b class="nc"><i>771</i>&nbsp;                                         screenBounds.getMaxY()</b>
<b class="nc"><i>772</i>&nbsp;                                             - anchorBounds.getHeight());</b>
<i>773</i>&nbsp;            }
<i>774</i>&nbsp;        }
<i>775</i>&nbsp;
<b class="fc"><i>776</i>&nbsp;        final double windowScrMinX =</b>
<b class="fc"><i>777</i>&nbsp;                anchorScrMinX - anchorBounds.getMinX()</b>
<b class="fc"><i>778</i>&nbsp;                              + extendedBounds.getMinX();</b>
<b class="fc"><i>779</i>&nbsp;        final double windowScrMinY =</b>
<b class="fc"><i>780</i>&nbsp;                anchorScrMinY - anchorBounds.getMinY()</b>
<b class="fc"><i>781</i>&nbsp;                              + extendedBounds.getMinY();</b>
<i>782</i>&nbsp;
<i>783</i>&nbsp;        // update popup dimensions
<b class="fc"><i>784</i>&nbsp;        setWidth(extendedBounds.getWidth());</b>
<b class="fc"><i>785</i>&nbsp;        setHeight(extendedBounds.getHeight());</b>
<i>786</i>&nbsp;        // update transform
<b class="fc"><i>787</i>&nbsp;        rootNode.setTranslateX(-extendedBounds.getMinX());</b>
<b class="fc"><i>788</i>&nbsp;        rootNode.setTranslateY(-extendedBounds.getMinY());</b>
<i>789</i>&nbsp;
<i>790</i>&nbsp;        // update popup position
<i>791</i>&nbsp;        // don&#39;t set Window.xExplicit unnecessarily
<b class="fc"><i>792</i>&nbsp;        if (!Double.isNaN(windowScrMinX)) {</b>
<b class="fc"><i>793</i>&nbsp;            super.setXInternal(windowScrMinX);</b>
<i>794</i>&nbsp;        }
<i>795</i>&nbsp;        // don&#39;t set Window.yExplicit unnecessarily
<b class="fc"><i>796</i>&nbsp;        if (!Double.isNaN(windowScrMinY)) {</b>
<b class="fc"><i>797</i>&nbsp;            super.setYInternal(windowScrMinY);</b>
<i>798</i>&nbsp;        }
<i>799</i>&nbsp;
<i>800</i>&nbsp;        // set anchor x, anchor y
<b class="fc"><i>801</i>&nbsp;        anchorX.set(anchorScrMinX + anchorDeltaX);</b>
<b class="fc"><i>802</i>&nbsp;        anchorY.set(anchorScrMinY + anchorDeltaY);</b>
<b class="fc"><i>803</i>&nbsp;    }</b>
<i>804</i>&nbsp;
<i>805</i>&nbsp;    private Bounds union(final Bounds bounds1, final Bounds bounds2) {
<b class="fc"><i>806</i>&nbsp;        final double minX = Math.min(bounds1.getMinX(), bounds2.getMinX());</b>
<b class="fc"><i>807</i>&nbsp;        final double minY = Math.min(bounds1.getMinY(), bounds2.getMinY());</b>
<b class="fc"><i>808</i>&nbsp;        final double maxX = Math.max(bounds1.getMaxX(), bounds2.getMaxX());</b>
<b class="fc"><i>809</i>&nbsp;        final double maxY = Math.max(bounds1.getMaxY(), bounds2.getMaxY());</b>
<i>810</i>&nbsp;
<b class="fc"><i>811</i>&nbsp;        return new BoundingBox(minX, minY, maxX - minX, maxY - minY);</b>
<i>812</i>&nbsp;    }
<i>813</i>&nbsp;
<i>814</i>&nbsp;    private double windowToAnchorX(final double windowX) {
<b class="fc"><i>815</i>&nbsp;        final Bounds anchorBounds = getAnchorBounds();</b>
<b class="fc"><i>816</i>&nbsp;        return windowX - getExtendedBounds().getMinX()</b>
<b class="fc"><i>817</i>&nbsp;                       + anchorBounds.getMinX()</b>
<b class="fc"><i>818</i>&nbsp;                       + getAnchorLocation().getXCoef()</b>
<b class="fc"><i>819</i>&nbsp;                             * anchorBounds.getWidth();</b>
<i>820</i>&nbsp;    }
<i>821</i>&nbsp;
<i>822</i>&nbsp;    private double windowToAnchorY(final double windowY) {
<b class="fc"><i>823</i>&nbsp;        final Bounds anchorBounds = getAnchorBounds();</b>
<b class="fc"><i>824</i>&nbsp;        return windowY - getExtendedBounds().getMinY()</b>
<b class="fc"><i>825</i>&nbsp;                       + anchorBounds.getMinY()</b>
<b class="fc"><i>826</i>&nbsp;                       + getAnchorLocation().getYCoef()</b>
<b class="fc"><i>827</i>&nbsp;                             * anchorBounds.getHeight();</b>
<i>828</i>&nbsp;    }
<i>829</i>&nbsp;
<i>830</i>&nbsp;    /**
<i>831</i>&nbsp;     *
<i>832</i>&nbsp;     * Gets the root (non PopupWindow) Window for the provided window.
<i>833</i>&nbsp;     *
<i>834</i>&nbsp;     * @param win the Window for which to get the root window
<i>835</i>&nbsp;     */
<i>836</i>&nbsp;    private static Window getRootWindow(Window win) {
<i>837</i>&nbsp;        // should be enough to traverse PopupWindow hierarchy here to get to the
<i>838</i>&nbsp;        // first non-popup focusable window
<b class="fc"><i>839</i>&nbsp;        while (win instanceof PopupWindow) {</b>
<b class="nc"><i>840</i>&nbsp;            win = ((PopupWindow) win).getOwnerWindow();</b>
<i>841</i>&nbsp;        }
<b class="fc"><i>842</i>&nbsp;        return win;</b>
<i>843</i>&nbsp;    }
<i>844</i>&nbsp;
<i>845</i>&nbsp;    void doAutoHide() {
<i>846</i>&nbsp;        // There is a timing problem here. I would like to have this isVisible
<i>847</i>&nbsp;        // check, such that we don&#39;t send an onAutoHide event if it was already
<i>848</i>&nbsp;        // invisible. However, visible is already false by the time this method
<i>849</i>&nbsp;        // gets called, when done by certain code paths.
<i>850</i>&nbsp;//        if (isVisible()) {
<i>851</i>&nbsp;        // hide this popup
<b class="nc"><i>852</i>&nbsp;        hide();</b>
<b class="nc"><i>853</i>&nbsp;        if (getOnAutoHide() != null) {</b>
<b class="nc"><i>854</i>&nbsp;            getOnAutoHide().handle(new Event(this, this, Event.ANY));</b>
<i>855</i>&nbsp;        }
<i>856</i>&nbsp;//        }
<b class="nc"><i>857</i>&nbsp;    }</b>
<i>858</i>&nbsp;
<i>859</i>&nbsp;    @Override
<i>860</i>&nbsp;    WindowEventDispatcher createInternalEventDispatcher() {
<b class="fc"><i>861</i>&nbsp;        return new WindowEventDispatcher(new PopupEventRedirector(this),</b>
<i>862</i>&nbsp;                                         new WindowCloseRequestHandler(this),
<i>863</i>&nbsp;                                         new EventHandlerManager(this));
<i>864</i>&nbsp;
<i>865</i>&nbsp;    }
<i>866</i>&nbsp;
<i>867</i>&nbsp;    @Override
<i>868</i>&nbsp;    Window getWindowOwner() {
<b class="nc"><i>869</i>&nbsp;        return getOwnerWindow();</b>
<i>870</i>&nbsp;    }
<i>871</i>&nbsp;
<i>872</i>&nbsp;    private void startMonitorOwnerEvents(final Window ownerWindowValue) {
<b class="fc"><i>873</i>&nbsp;        final EventRedirector parentEventRedirector =</b>
<b class="fc"><i>874</i>&nbsp;                ownerWindowValue.getInternalEventDispatcher()</b>
<b class="fc"><i>875</i>&nbsp;                                .getEventRedirector();</b>
<b class="fc"><i>876</i>&nbsp;        parentEventRedirector.addEventDispatcher(getEventDispatcher());</b>
<b class="fc"><i>877</i>&nbsp;    }</b>
<i>878</i>&nbsp;
<i>879</i>&nbsp;    private void stopMonitorOwnerEvents(final Window ownerWindowValue) {
<b class="fc"><i>880</i>&nbsp;        final EventRedirector parentEventRedirector =</b>
<b class="fc"><i>881</i>&nbsp;                ownerWindowValue.getInternalEventDispatcher()</b>
<b class="fc"><i>882</i>&nbsp;                                .getEventRedirector();</b>
<b class="fc"><i>883</i>&nbsp;        parentEventRedirector.removeEventDispatcher(getEventDispatcher());</b>
<b class="fc"><i>884</i>&nbsp;    }</b>
<i>885</i>&nbsp;
<i>886</i>&nbsp;    private ChangeListener&lt;Boolean&gt; ownerFocusedListener;
<i>887</i>&nbsp;
<i>888</i>&nbsp;    private void bindOwnerFocusedProperty(final Window ownerWindowValue) {
<b class="fc"><i>889</i>&nbsp;        ownerFocusedListener =</b>
<b class="nc"><i>890</i>&nbsp;                (observable, oldValue, newValue) -&gt; WindowHelper.setFocused(this, newValue);</b>
<b class="fc"><i>891</i>&nbsp;        ownerWindowValue.focusedProperty().addListener(ownerFocusedListener);</b>
<b class="fc"><i>892</i>&nbsp;    }</b>
<i>893</i>&nbsp;
<i>894</i>&nbsp;    private void unbindOwnerFocusedProperty(final Window ownerWindowValue) {
<b class="fc"><i>895</i>&nbsp;        ownerWindowValue.focusedProperty().removeListener(ownerFocusedListener);</b>
<b class="fc"><i>896</i>&nbsp;        ownerFocusedListener = null;</b>
<b class="fc"><i>897</i>&nbsp;    }</b>
<i>898</i>&nbsp;
<i>899</i>&nbsp;    private boolean autofixActive;
<i>900</i>&nbsp;    private void handleAutofixActivation(final boolean visible,
<i>901</i>&nbsp;                                         final boolean autofix) {
<b class="fc"><i>902</i>&nbsp;        final boolean newAutofixActive = visible &amp;&amp; autofix;</b>
<b class="fc"><i>903</i>&nbsp;        if (autofixActive != newAutofixActive) {</b>
<b class="fc"><i>904</i>&nbsp;            autofixActive = newAutofixActive;</b>
<b class="fc"><i>905</i>&nbsp;            if (newAutofixActive) {</b>
<b class="fc"><i>906</i>&nbsp;                Screen.getScreens().addListener(popupWindowUpdater);</b>
<b class="fc"><i>907</i>&nbsp;                updateWindow(getAnchorX(), getAnchorY());</b>
<i>908</i>&nbsp;            } else {
<b class="fc"><i>909</i>&nbsp;                Screen.getScreens().removeListener(popupWindowUpdater);</b>
<i>910</i>&nbsp;            }
<i>911</i>&nbsp;        }
<b class="fc"><i>912</i>&nbsp;    }</b>
<i>913</i>&nbsp;
<i>914</i>&nbsp;    private boolean autohideActive;
<i>915</i>&nbsp;    private void handleAutohideActivation(final boolean visible,
<i>916</i>&nbsp;                                          final boolean autohide) {
<b class="fc"><i>917</i>&nbsp;        final boolean newAutohideActive = visible &amp;&amp; autohide;</b>
<b class="fc"><i>918</i>&nbsp;        if (autohideActive != newAutohideActive) {</b>
<i>919</i>&nbsp;            // assert rootWindow != null;
<b class="fc"><i>920</i>&nbsp;            autohideActive = newAutohideActive;</b>
<b class="fc"><i>921</i>&nbsp;            if (newAutohideActive) {</b>
<b class="fc"><i>922</i>&nbsp;                rootWindow.increaseFocusGrabCounter();</b>
<i>923</i>&nbsp;            } else {
<b class="fc"><i>924</i>&nbsp;                rootWindow.decreaseFocusGrabCounter();</b>
<i>925</i>&nbsp;            }
<i>926</i>&nbsp;        }
<b class="fc"><i>927</i>&nbsp;    }</b>
<i>928</i>&nbsp;
<i>929</i>&nbsp;    private void validateOwnerWindow(final Window owner) {
<b class="fc"><i>930</i>&nbsp;        if (owner == null) {</b>
<b class="nc"><i>931</i>&nbsp;            throw new NullPointerException(&quot;Owner window must not be null&quot;);</b>
<i>932</i>&nbsp;        }
<i>933</i>&nbsp;
<b class="fc"><i>934</i>&nbsp;        if (wouldCreateCycle(owner, this)) {</b>
<b class="nc"><i>935</i>&nbsp;            throw new IllegalArgumentException(</b>
<i>936</i>&nbsp;                    &quot;Specified owner window would create cycle&quot;
<i>937</i>&nbsp;                        + &quot; in the window hierarchy&quot;);
<i>938</i>&nbsp;        }
<i>939</i>&nbsp;
<b class="fc"><i>940</i>&nbsp;        if (isShowing() &amp;&amp; (getOwnerWindow() != owner)) {</b>
<b class="nc"><i>941</i>&nbsp;            throw new IllegalStateException(</b>
<i>942</i>&nbsp;                    &quot;Popup is already shown with different owner window&quot;);
<i>943</i>&nbsp;        }
<b class="fc"><i>944</i>&nbsp;    }</b>
<i>945</i>&nbsp;
<i>946</i>&nbsp;    private static boolean wouldCreateCycle(Window parent, final Window child) {
<b class="fc"><i>947</i>&nbsp;       while (parent != null) {</b>
<b class="fc"><i>948</i>&nbsp;           if (parent == child) {</b>
<b class="nc"><i>949</i>&nbsp;               return true;</b>
<i>950</i>&nbsp;           }
<i>951</i>&nbsp;
<b class="fc"><i>952</i>&nbsp;           parent = parent.getWindowOwner();</b>
<i>953</i>&nbsp;       }
<i>954</i>&nbsp;
<b class="fc"><i>955</i>&nbsp;       return false;</b>
<i>956</i>&nbsp;    }
<i>957</i>&nbsp;
<i>958</i>&nbsp;    static class PopupEventRedirector extends EventRedirector {
<i>959</i>&nbsp;
<b class="fc"><i>960</i>&nbsp;        private static final KeyCombination ESCAPE_KEY_COMBINATION =</b>
<b class="fc"><i>961</i>&nbsp;                KeyCombination.keyCombination(&quot;Esc&quot;);</b>
<i>962</i>&nbsp;        private final PopupWindow popupWindow;
<i>963</i>&nbsp;
<i>964</i>&nbsp;        public PopupEventRedirector(final PopupWindow popupWindow) {
<b class="fc"><i>965</i>&nbsp;            super(popupWindow);</b>
<b class="fc"><i>966</i>&nbsp;            this.popupWindow = popupWindow;</b>
<b class="fc"><i>967</i>&nbsp;        }</b>
<i>968</i>&nbsp;
<i>969</i>&nbsp;        @Override
<i>970</i>&nbsp;        protected void handleRedirectedEvent(final Object eventSource,
<i>971</i>&nbsp;                final Event event) {
<b class="fc"><i>972</i>&nbsp;            if (event instanceof KeyEvent) {</b>
<b class="nc"><i>973</i>&nbsp;                handleKeyEvent((KeyEvent) event);</b>
<b class="nc"><i>974</i>&nbsp;                return;</b>
<i>975</i>&nbsp;            }
<i>976</i>&nbsp;
<b class="fc"><i>977</i>&nbsp;            final EventType&lt;?&gt; eventType = event.getEventType();</b>
<i>978</i>&nbsp;
<b class="fc"><i>979</i>&nbsp;            if (eventType == MouseEvent.MOUSE_PRESSED</b>
<i>980</i>&nbsp;                    || eventType == ScrollEvent.SCROLL) {
<b class="nc"><i>981</i>&nbsp;                handleAutoHidingEvents(eventSource, event);</b>
<b class="nc"><i>982</i>&nbsp;                return;</b>
<i>983</i>&nbsp;            }
<i>984</i>&nbsp;
<b class="fc"><i>985</i>&nbsp;            if (eventType == FocusUngrabEvent.FOCUS_UNGRAB) {</b>
<b class="nc"><i>986</i>&nbsp;                handleFocusUngrabEvent();</b>
<b class="nc"><i>987</i>&nbsp;                return;</b>
<i>988</i>&nbsp;            }
<b class="fc"><i>989</i>&nbsp;        }</b>
<i>990</i>&nbsp;
<i>991</i>&nbsp;        private void handleKeyEvent(final KeyEvent event) {
<b class="nc"><i>992</i>&nbsp;            if (event.isConsumed()) {</b>
<b class="nc"><i>993</i>&nbsp;                return;</b>
<i>994</i>&nbsp;            }
<i>995</i>&nbsp;
<b class="nc"><i>996</i>&nbsp;            final Scene scene = popupWindow.getScene();</b>
<b class="nc"><i>997</i>&nbsp;            if (scene != null) {</b>
<b class="nc"><i>998</i>&nbsp;                final Node sceneFocusOwner = scene.getFocusOwner();</b>
<i>999</i>&nbsp;                final EventTarget eventTarget =
<b class="nc"><i>1000</i>&nbsp;                        (sceneFocusOwner != null) ? sceneFocusOwner : scene;</b>
<b class="nc"><i>1001</i>&nbsp;                if (EventUtil.fireEvent(eventTarget, new DirectEvent(event.copyFor(popupWindow, eventTarget)))</b>
<i>1002</i>&nbsp;                        == null) {
<b class="nc"><i>1003</i>&nbsp;                    event.consume();</b>
<b class="nc"><i>1004</i>&nbsp;                    return;</b>
<i>1005</i>&nbsp;                }
<i>1006</i>&nbsp;            }
<i>1007</i>&nbsp;
<b class="nc"><i>1008</i>&nbsp;            if ((event.getEventType() == KeyEvent.KEY_PRESSED)</b>
<b class="nc"><i>1009</i>&nbsp;                    &amp;&amp; ESCAPE_KEY_COMBINATION.match(event)) {</b>
<b class="nc"><i>1010</i>&nbsp;                handleEscapeKeyPressedEvent(event);</b>
<i>1011</i>&nbsp;            }
<b class="nc"><i>1012</i>&nbsp;        }</b>
<i>1013</i>&nbsp;
<i>1014</i>&nbsp;        private void handleEscapeKeyPressedEvent(final Event event) {
<b class="nc"><i>1015</i>&nbsp;            if (popupWindow.isHideOnEscape()) {</b>
<b class="nc"><i>1016</i>&nbsp;                popupWindow.doAutoHide();</b>
<i>1017</i>&nbsp;
<b class="nc"><i>1018</i>&nbsp;                if (popupWindow.getConsumeAutoHidingEvents()) {</b>
<b class="nc"><i>1019</i>&nbsp;                    event.consume();</b>
<i>1020</i>&nbsp;                }
<i>1021</i>&nbsp;            }
<b class="nc"><i>1022</i>&nbsp;        }</b>
<i>1023</i>&nbsp;
<i>1024</i>&nbsp;        private void handleAutoHidingEvents(final Object eventSource,
<i>1025</i>&nbsp;                                            final Event event) {
<i>1026</i>&nbsp;            // we handle mouse pressed only for the immediate parent window,
<i>1027</i>&nbsp;            // where we can check whether the mouse press is inside of the owner
<i>1028</i>&nbsp;            // control or not, we will force possible child popups to close
<i>1029</i>&nbsp;            // by sending the FOCUS_UNGRAB event
<b class="nc"><i>1030</i>&nbsp;            if (popupWindow.getOwnerWindow() != eventSource) {</b>
<b class="nc"><i>1031</i>&nbsp;                return;</b>
<i>1032</i>&nbsp;            }
<i>1033</i>&nbsp;
<b class="nc"><i>1034</i>&nbsp;            if (popupWindow.isAutoHide() &amp;&amp; !isOwnerNodeEvent(event)) {</b>
<i>1035</i>&nbsp;                // the mouse press is outside of the owner control,
<i>1036</i>&nbsp;                // fire FOCUS_UNGRAB to child popups
<b class="nc"><i>1037</i>&nbsp;                Event.fireEvent(popupWindow, new FocusUngrabEvent());</b>
<i>1038</i>&nbsp;
<b class="nc"><i>1039</i>&nbsp;                popupWindow.doAutoHide();</b>
<i>1040</i>&nbsp;
<b class="nc"><i>1041</i>&nbsp;                if (popupWindow.getConsumeAutoHidingEvents()) {</b>
<b class="nc"><i>1042</i>&nbsp;                    event.consume();</b>
<i>1043</i>&nbsp;                }
<i>1044</i>&nbsp;            }
<b class="nc"><i>1045</i>&nbsp;        }</b>
<i>1046</i>&nbsp;
<i>1047</i>&nbsp;        private void handleFocusUngrabEvent() {
<b class="nc"><i>1048</i>&nbsp;            if (popupWindow.isAutoHide()) {</b>
<b class="nc"><i>1049</i>&nbsp;                popupWindow.doAutoHide();</b>
<i>1050</i>&nbsp;            }
<b class="nc"><i>1051</i>&nbsp;        }</b>
<i>1052</i>&nbsp;
<i>1053</i>&nbsp;        private boolean isOwnerNodeEvent(final Event event) {
<b class="nc"><i>1054</i>&nbsp;            final Node ownerNode = popupWindow.getOwnerNode();</b>
<b class="nc"><i>1055</i>&nbsp;            if (ownerNode == null) {</b>
<b class="nc"><i>1056</i>&nbsp;                return false;</b>
<i>1057</i>&nbsp;            }
<i>1058</i>&nbsp;
<b class="nc"><i>1059</i>&nbsp;            final EventTarget eventTarget = event.getTarget();</b>
<b class="nc"><i>1060</i>&nbsp;            if (!(eventTarget instanceof Node)) {</b>
<b class="nc"><i>1061</i>&nbsp;                return false;</b>
<i>1062</i>&nbsp;            }
<i>1063</i>&nbsp;
<b class="nc"><i>1064</i>&nbsp;            Node node = (Node) eventTarget;</b>
<i>1065</i>&nbsp;            do {
<b class="nc"><i>1066</i>&nbsp;                if (node == ownerNode) {</b>
<b class="nc"><i>1067</i>&nbsp;                    return true;</b>
<i>1068</i>&nbsp;                }
<b class="nc"><i>1069</i>&nbsp;                node = node.getParent();</b>
<b class="nc"><i>1070</i>&nbsp;            } while (node != null);</b>
<i>1071</i>&nbsp;
<b class="nc"><i>1072</i>&nbsp;            return false;</b>
<i>1073</i>&nbsp;        }
<i>1074</i>&nbsp;    }
<i>1075</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2017-12-04 21:49</div>
</div>
</body>
</html>
